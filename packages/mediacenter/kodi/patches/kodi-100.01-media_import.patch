From 18874401c6c92b4db0a3ed2eef8b0ef541524ea2 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 12 Jan 2020 01:48:37 +0100
Subject: [PATCH 01/88] [dbwrappers] support both LEAST() / MIN() and
 GREATEST() / MAX() for SQLite and MySQL

---
 xbmc/dbwrappers/sqlitedataset.cpp | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/xbmc/dbwrappers/sqlitedataset.cpp b/xbmc/dbwrappers/sqlitedataset.cpp
index fe5ba449c5ee..e50d981bb7ed 100644
--- a/xbmc/dbwrappers/sqlitedataset.cpp
+++ b/xbmc/dbwrappers/sqlitedataset.cpp
@@ -548,6 +548,21 @@ std::string SqliteDatabase::vprepare(const char *format, va_list args)
     sqlite3_free(p);
   }
 
+  //  GREATEST(x,y,...) is the mysql form of MAX(x,y,...)
+  pos = 0;
+  while ((pos = strResult.find("GREATEST(", pos)) != std::string::npos)
+  {
+    strResult.replace(pos++, 9, "MAX(");
+    pos += 4;
+  }
+  //  LEAST(x,y,...) is the mysql form of MIN(x,y,...)
+  pos = 0;
+  while ((pos = strResult.find("LEAST(", pos)) != std::string::npos)
+  {
+    strResult.replace(pos++, 6, "MIN(");
+    pos += 4;
+  }
+
   // Strip SEPARATOR from all GROUP_CONCAT statements:
   // before: GROUP_CONCAT(field SEPARATOR '; ')
   // after:  GROUP_CONCAT(field, '; ')

From 0c28c40055af01d599a8021e361f6b225eca8450 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 1 Jul 2017 15:21:12 +0200
Subject: [PATCH 02/88] [utils] extend URIUtils::Split() with an option to
 ignore/keep URL parameters/options

---
 xbmc/utils/URIUtils.cpp      |  7 ++++---
 xbmc/utils/URIUtils.h        |  2 +-
 xbmc/video/VideoDatabase.cpp | 11 +----------
 3 files changed, 6 insertions(+), 14 deletions(-)

diff --git a/xbmc/utils/URIUtils.cpp b/xbmc/utils/URIUtils.cpp
index 738c946a50ac..b2b9a42f94a2 100644
--- a/xbmc/utils/URIUtils.cpp
+++ b/xbmc/utils/URIUtils.cpp
@@ -198,7 +198,8 @@ std::string URIUtils::GetFileName(const std::string& strFileNameAndPath)
 }
 
 void URIUtils::Split(const std::string& strFileNameAndPath,
-                     std::string& strPath, std::string& strFileName)
+                     std::string& strPath, std::string& strFileName,
+                     bool ignoreOptions /* = true */)
 {
   //Splits a full filename in path and file.
   //ex. smb://computer/share/directory/filename.ext -> strPath:smb://computer/share/directory/ and strFileName:filename.ext
@@ -221,8 +222,8 @@ void URIUtils::Split(const std::string& strFileNameAndPath,
   // everything to the right of the directory separator
   strFileName = strFileNameAndPath.substr(i+1);
 
-  // if actual uri, ignore options
-  if (IsURL(strFileNameAndPath))
+  // ignore options
+  if (IsURL(strFileNameAndPath) && ignoreOptions)
   {
     i = strFileName.size() - 1;
     while (i > 0)
diff --git a/xbmc/utils/URIUtils.h b/xbmc/utils/URIUtils.h
index 31db0ec16181..b34630f28e3b 100644
--- a/xbmc/utils/URIUtils.h
+++ b/xbmc/utils/URIUtils.h
@@ -54,7 +54,7 @@ class URIUtils
   static std::string ReplaceExtension(const std::string& strFile,
                                      const std::string& strNewExtension);
   static void Split(const std::string& strFileNameAndPath,
-                    std::string& strPath, std::string& strFileName);
+                    std::string& strPath, std::string& strFileName, bool ignoreOptions = true);
   static std::vector<std::string> SplitPath(const std::string& strPath);
 
   static void GetCommonPath(std::string& strPath, const std::string& strPath2);
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 10e4afa22fb2..1ad2f601bd71 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -10270,16 +10270,7 @@ void CVideoDatabase::SplitPath(const std::string& strFileNameAndPath, std::strin
     strFileName = strFileNameAndPath;
   }
   else
-  {
-    URIUtils::Split(strFileNameAndPath, strPath, strFileName);
-    // Keep protocol options as part of the path
-    if (URIUtils::IsURL(strFileNameAndPath))
-    {
-      CURL url(strFileNameAndPath);
-      if (!url.GetProtocolOptions().empty())
-        strPath += "|" + url.GetProtocolOptions();
-    }
-  }
+    URIUtils::Split(strFileNameAndPath, strPath, strFileName, false);
 }
 
 void CVideoDatabase::InvalidatePathHash(const std::string& strPath)

From 73dcdb73b63a44842a77260b1b8a74f339e134d7 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Mon, 16 Sep 2013 23:49:02 +0200
Subject: [PATCH 03/88] [utils] add SpecialSort with SortTopologically

---
 xbmc/utils/CMakeLists.txt |   1 +
 xbmc/utils/SpecialSort.h  | 108 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 109 insertions(+)
 create mode 100644 xbmc/utils/SpecialSort.h

diff --git a/xbmc/utils/CMakeLists.txt b/xbmc/utils/CMakeLists.txt
index a04870e91c70..660f933a3e42 100644
--- a/xbmc/utils/CMakeLists.txt
+++ b/xbmc/utils/CMakeLists.txt
@@ -147,6 +147,7 @@ set(HEADERS ActorProtocol.h
             ScraperUrl.h
             Screenshot.h
             SortUtils.h
+            SpecialSort.h
             Speed.h
             StaticLoggerBase.h
             Stopwatch.h
diff --git a/xbmc/utils/SpecialSort.h b/xbmc/utils/SpecialSort.h
new file mode 100644
index 000000000000..7aaa81687050
--- /dev/null
+++ b/xbmc/utils/SpecialSort.h
@@ -0,0 +1,108 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <map>
+#include <set>
+#include <vector>
+
+class SpecialSort
+{
+public:
+  template<typename T>
+  static std::vector<T> SortTopologically(const std::vector<std::pair<T, T>>& topology);
+
+private:
+  static void sortTopologically(int current,
+                                const std::vector<std::set<int>>& edges,
+                                std::vector<bool>& visited,
+                                std::vector<int>& stack);
+};
+
+template<typename T>
+std::vector<T> SpecialSort::SortTopologically(const std::vector<std::pair<T, T>>& topology)
+{
+  typename std::map<int, T> key2ValueMapping;
+  typename std::map<T, int> value2KeyMapping;
+  std::vector<std::set<int>> edges;
+
+  int key = 0;
+  // map the values to comparable and usable keys and build a map with all
+  // the sources and their destinations
+  for (const auto& topologyIt : topology)
+  {
+    size_t sourceKey = -1, destKey = -1;
+    // handle the source item
+    typename std::map<T, int>::const_iterator it = value2KeyMapping.find(topologyIt.first);
+    if (it == value2KeyMapping.end())
+    {
+      sourceKey = key;
+      value2KeyMapping.insert(make_pair(topologyIt.first, sourceKey));
+      key2ValueMapping.insert(make_pair(sourceKey, topologyIt.first));
+      key++;
+    }
+    else
+      sourceKey = it->second;
+
+    // handle the destination item
+    it = value2KeyMapping.find(topologyIt.second);
+    if (it == value2KeyMapping.end())
+    {
+      destKey = key;
+      value2KeyMapping.insert(make_pair(topologyIt.second, destKey));
+      key2ValueMapping.insert(make_pair(destKey, topologyIt.second));
+      key++;
+    }
+    else
+      destKey = it->second;
+
+    // add the combination to the edges mapping
+    if (edges.size() <= sourceKey)
+      edges.insert(edges.end(), sourceKey + 1 - edges.size(), std::set<int>());
+    edges[sourceKey].insert(destKey);
+  }
+
+  size_t size = value2KeyMapping.size();
+  std::vector<int> stack;
+  stack.reserve(size);
+  if (edges.size() < size)
+    edges.insert(edges.end(), size - edges.size(), std::set<int>());
+  std::vector<bool> visited(size, false);
+
+  // perform a topology sort
+  for (size_t i = 0; i < size; i++)
+  {
+    if (!visited[i])
+      sortTopologically(i, edges, visited, stack);
+  }
+
+  // translate the keys back to the real values
+  typename std::vector<T> result;
+  for (const auto& key : stack)
+    result.push_back(key2ValueMapping[key]);
+
+  return result;
+}
+
+void SpecialSort::sortTopologically(int current,
+                                    const std::vector<std::set<int>>& edges,
+                                    std::vector<bool>& visited,
+                                    std::vector<int>& stack)
+{
+  // mark the current node as visited
+  visited[current] = true;
+
+  for (const auto i : edges.at(current))
+  {
+    if (!visited[i])
+      sortTopologically(i, edges, visited, stack);
+  }
+
+  stack.push_back(current);
+}

From da450538347eec9ffdabaecae7ce94a8a853ad17 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Thu, 17 Sep 2015 12:08:10 +0200
Subject: [PATCH 04/88] [media] add aliases for std::vector<MediaType> and
 std::set<MediaType>

---
 xbmc/media/MediaType.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/media/MediaType.h b/xbmc/media/MediaType.h
index 2c7d9e021f7c..18454536b7ee 100644
--- a/xbmc/media/MediaType.h
+++ b/xbmc/media/MediaType.h
@@ -11,8 +11,11 @@
 #include <map>
 #include <set>
 #include <string>
+#include <vector>
 
 using MediaType = std::string;
+using MediaTypes = std::set<MediaType>;
+using GroupedMediaTypes = std::vector<MediaType>;
 
 #define MediaTypeNone             ""
 #define MediaTypeMusic            "music"

From 090c8565269fb8f7948572b4658bae25d9133c71 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Thu, 17 Sep 2015 11:46:44 +0200
Subject: [PATCH 05/88] [media] CMediaTypes: add Join() and Split() helper
 methods

---
 xbmc/media/MediaType.cpp | 17 +++++++++++++++++
 xbmc/media/MediaType.h   |  4 ++++
 2 files changed, 21 insertions(+)

diff --git a/xbmc/media/MediaType.cpp b/xbmc/media/MediaType.cpp
index b4cb8214e534..0f1a86aab2d2 100644
--- a/xbmc/media/MediaType.cpp
+++ b/xbmc/media/MediaType.cpp
@@ -13,6 +13,8 @@
 
 #include <utility>
 
+static const std::string MediaTypeStringSeparator = ",";
+
 static std::map<std::string, CMediaTypes::MediaTypeInfo> fillDefaultMediaTypes()
 {
   std::map<std::string, CMediaTypes::MediaTypeInfo> mediaTypes;
@@ -132,3 +134,18 @@ std::string CMediaTypes::GetCapitalPluralLocalization(const MediaType &mediaType
 
   return g_localizeStrings.Get(mediaTypeIt->second.localizationPluralCapital);
 }
+
+std::string CMediaTypes::Join(const MediaTypes& mediaTypes)
+{
+  return Join(std::vector<std::string>(mediaTypes.begin(), mediaTypes.end()));
+}
+
+std::string CMediaTypes::Join(const GroupedMediaTypes& mediaTypes)
+{
+  return StringUtils::Join(mediaTypes, MediaTypeStringSeparator);
+}
+
+GroupedMediaTypes CMediaTypes::Split(const std::string& mediaTypes)
+{
+  return StringUtils::Split(mediaTypes, MediaTypeStringSeparator);
+}
diff --git a/xbmc/media/MediaType.h b/xbmc/media/MediaType.h
index 18454536b7ee..90679d7bc4e2 100644
--- a/xbmc/media/MediaType.h
+++ b/xbmc/media/MediaType.h
@@ -45,6 +45,10 @@ class CMediaTypes
   static std::string GetCapitalLocalization(const MediaType &mediaType);
   static std::string GetCapitalPluralLocalization(const MediaType &mediaType);
 
+  static std::string Join(const MediaTypes& mediaTypes);
+  static std::string Join(const GroupedMediaTypes& mediaTypes);
+  static GroupedMediaTypes Split(const std::string& mediaTypes);
+
   typedef struct MediaTypeInfo {
     MediaTypeInfo(const MediaType &mediaType, const std::string &plural, bool container,
                   int localizationSingular, int localizationPlural,

From 881717f454d43d3371862c9c63349e645742e074 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Thu, 10 Oct 2013 19:06:29 +0200
Subject: [PATCH 06/88] [CFileItem] add IsEnabled() and SetEnabled()

---
 xbmc/FileItem.cpp                   |  6 ++++++
 xbmc/FileItem.h                     |  4 ++++
 xbmc/GUIInfoManager.cpp             | 18 ++++++++++++++++++
 xbmc/guilib/guiinfo/GUIInfoLabels.h |  1 +
 4 files changed, 29 insertions(+)

diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index ab14fa3355bf..3cc63ac959fa 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -386,6 +386,7 @@ CFileItem& CFileItem::operator=(const CFileItem& item)
     return *this;
 
   CGUIListItem::operator=(item);
+  m_enabled = item.m_enabled;
   m_bLabelPreformatted=item.m_bLabelPreformatted;
   FreeMemory();
   m_strPath = item.m_strPath;
@@ -481,6 +482,7 @@ void CFileItem::Initialize()
   m_videoInfoTag = NULL;
   m_pictureInfoTag = NULL;
   m_gameInfoTag = NULL;
+  m_enabled = true;
   m_bLabelPreformatted = false;
   m_bIsAlbum = false;
   m_dwSize = 0;
@@ -596,6 +598,8 @@ void CFileItem::Archive(CArchive& ar)
     }
     else
       ar << 0;
+
+    ar << m_enabled;
   }
   else
   {
@@ -640,6 +644,8 @@ void CFileItem::Archive(CArchive& ar)
     if (iType == 1)
       ar >> *GetGameInfoTag();
 
+    ar >> m_enabled;
+
     SetInvalid();
   }
 }
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 347009d7d1e3..00d5e6b3f06a 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -145,6 +145,9 @@ class CFileItem :
   void ToSortable(SortItem &sortable, const Fields &fields) const;
   bool IsFileItem() const override { return true; };
 
+  bool IsEnabled() const { return m_enabled; }
+  void SetEnabled(bool enabled) { m_enabled = enabled; }
+
   bool Exists(bool bUseCache = true) const;
 
   /*!
@@ -562,6 +565,7 @@ class CFileItem :
 
   std::string m_strPath;            ///< complete path to item
   std::string m_strDynPath;
+  bool m_enabled;
 
   SortSpecial m_specialSort;
   bool m_bIsParentFolder;
diff --git a/xbmc/GUIInfoManager.cpp b/xbmc/GUIInfoManager.cpp
index 828fe1da269a..18676819285c 100644
--- a/xbmc/GUIInfoManager.cpp
+++ b/xbmc/GUIInfoManager.cpp
@@ -6466,6 +6466,14 @@ const infomap container_str[]  = {{ "property",         CONTAINER_PROPERTY },
 ///     @skinning_v19 **[New Infolabel]** \link ListItem_AlbumStatus `ListItem.AlbumStatus`\endlink
 ///     <p>
 ///   }
+///   \table_row3{   <b>`ListItem.IsEnabled`</b>,
+///                  \anchor ListItem_IsEnabled
+///                  _boolean_,
+///     @return **True** if the item is enabled.
+///     <p><hr>
+///     @skinning_v19 **[New Infolabel]** \link ListItem_IsEnabled `ListItem.IsEnabled`\endlink
+///     <p>
+///   }
 /// \table_end
 ///
 /// -----------------------------------------------------------------------------
@@ -6674,6 +6682,7 @@ const infomap listitem_labels[]= {{ "thumb",            LISTITEM_THUMB },
                                   { "islive",           LISTITEM_IS_LIVE },
                                   { "tvshowdbid",       LISTITEM_TVSHOWDBID },
                                   { "albumstatus",      LISTITEM_ALBUMSTATUS },
+                                  { "isenabled",        LISTITEM_ISENABLED },
 };
 
 /// \page modules__infolabels_boolean_conditions
@@ -10729,6 +10738,15 @@ bool CGUIInfoManager::GetItemBool(const CGUIListItem *item, int contextWindow, i
         }
         break;
       }
+      case LISTITEM_ISENABLED:
+      {
+        if (item->IsFileItem())
+        {
+          const CFileItem *pItem = static_cast<const CFileItem *>(item);
+          return pItem->IsEnabled();
+        }
+        break;
+      }
     }
   }
 
diff --git a/xbmc/guilib/guiinfo/GUIInfoLabels.h b/xbmc/guilib/guiinfo/GUIInfoLabels.h
index 683476e60435..b2c14f7c08e4 100644
--- a/xbmc/guilib/guiinfo/GUIInfoLabels.h
+++ b/xbmc/guilib/guiinfo/GUIInfoLabels.h
@@ -921,6 +921,7 @@
 #define LISTITEM_IS_LIVE            (LISTITEM_START + 202)
 #define LISTITEM_TVSHOWDBID         (LISTITEM_START + 203)
 #define LISTITEM_ALBUMSTATUS        (LISTITEM_START + 204)
+#define LISTITEM_ISENABLED          (LISTITEM_START + 205)
 
 #define LISTITEM_END                (LISTITEM_START + 2500)
 

From 2ad59bf8cb3302f2012c08f4c21a4a1cfb31d887 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 29 Jan 2017 11:58:08 +0100
Subject: [PATCH 07/88] [CFileItem] add GetMediaType() and implement it for
 video and music items

---
 xbmc/FileItem.cpp | 20 ++++++++++++++++++++
 xbmc/FileItem.h   |  2 ++
 2 files changed, 22 insertions(+)

diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index 3cc63ac959fa..e1b6eb59762f 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -3515,6 +3515,26 @@ void CFileItemList::ClearSortState()
   m_sortDescription.sortAttributes = SortAttributeNone;
 }
 
+MediaType CFileItem::GetMediaType() const
+{
+  if (HasVideoInfoTag())
+  {
+    if (GetVideoInfoTag()->m_type != MediaTypeNone)
+      return GetVideoInfoTag()->m_type;
+
+    return MediaTypeVideo;
+  }
+  if (HasMusicInfoTag())
+  {
+    if (GetMusicInfoTag()->GetType() != MediaTypeNone)
+      return GetMusicInfoTag()->GetType();
+
+    return MediaTypeMusic;
+  }
+  
+  return MediaTypeNone;
+}
+
 bool CFileItem::HasVideoInfoTag() const
 {
   // Note: CPVRRecording is derived from CVideoInfoTag
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 00d5e6b3f06a..3a29d5c3d7cd 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -265,6 +265,8 @@ class CFileItem :
   bool SortsOnBottom() const { return m_specialSort == SortSpecialOnBottom; }
   void SetSpecialSort(SortSpecial sort) { m_specialSort = sort; }
 
+  MediaType GetMediaType() const;
+
   inline bool HasMusicInfoTag() const
   {
     return m_musicInfoTag != NULL;

From 97b9ff60d7dfb1eb524489f469dd4910edecfe6a Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Mon, 23 Dec 2013 00:37:06 +0100
Subject: [PATCH 08/88] [CFileItemList] add copy constructor

---
 xbmc/FileItem.cpp | 5 +++++
 xbmc/FileItem.h   | 1 +
 2 files changed, 6 insertions(+)

diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index e1b6eb59762f..489034c4cdea 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -1936,6 +1936,11 @@ CFileItemList::CFileItemList(const std::string& strPath)
 {
 }
 
+CFileItemList::CFileItemList(const CFileItemList &other)
+{
+  Copy(other, true);
+}
+
 CFileItemList::~CFileItemList()
 {
   Clear();
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 3a29d5c3d7cd..ba561539e5ca 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -641,6 +641,7 @@ class CFileItemList : public CFileItem
 
   CFileItemList();
   explicit CFileItemList(const std::string& strPath);
+  CFileItemList(const CFileItemList &other);
   ~CFileItemList() override;
   void Archive(CArchive& ar) override;
   CFileItemPtr operator[] (int iItem);

From a73d683f91daf0e54e85dbae5f42fa34d847cf57 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Fri, 13 Sep 2013 10:12:53 +0200
Subject: [PATCH 09/88] [videodb] allow to manually specify dateadded

---
 xbmc/video/VideoDatabase.cpp | 12 ++++++------
 xbmc/video/VideoDatabase.h   |  4 ++--
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 1ad2f601bd71..731d9d1ee401 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -1338,7 +1338,7 @@ int CVideoDatabase::GetMusicVideoId(const std::string& strFilenameAndPath)
 }
 
 //********************************************************************************************************************************
-int CVideoDatabase::AddMovie(const std::string& strFilenameAndPath)
+int CVideoDatabase::AddMovie(const std::string& strFilenameAndPath, const CDateTime& dateAdded /* = CDateTime() */)
 {
   try
   {
@@ -1353,7 +1353,7 @@ int CVideoDatabase::AddMovie(const std::string& strFilenameAndPath)
       int idFile = AddFile(strFilenameAndPath);
       if (idFile < 0)
         return -1;
-      UpdateFileDateAdded(idFile, strFilenameAndPath);
+      UpdateFileDateAdded(idFile, strFilenameAndPath, dateAdded);
       std::string strSQL=PrepareSQL("insert into movie (idMovie, idFile) values (NULL, %i)", idFile);
       m_pDS->exec(strSQL);
       idMovie = (int)m_pDS->lastinsertid();
@@ -1415,7 +1415,7 @@ int CVideoDatabase::AddTvShow()
 }
 
 //********************************************************************************************************************************
-int CVideoDatabase::AddEpisode(int idShow, const std::string& strFilenameAndPath)
+int CVideoDatabase::AddEpisode(int idShow, const std::string& strFilenameAndPath, const CDateTime& dateAdded /* = CDatetime() */)
 {
   try
   {
@@ -1427,7 +1427,7 @@ int CVideoDatabase::AddEpisode(int idShow, const std::string& strFilenameAndPath
     int idFile = AddFile(strFilenameAndPath);
     if (idFile < 0)
       return -1;
-    UpdateFileDateAdded(idFile, strFilenameAndPath);
+    UpdateFileDateAdded(idFile, strFilenameAndPath, dateAdded);
 
     std::string strSQL=PrepareSQL("insert into episode (idEpisode, idFile, idShow) values (NULL, %i, %i)", idFile, idShow);
     m_pDS->exec(strSQL);
@@ -2410,7 +2410,7 @@ int CVideoDatabase::SetDetailsForMovie(const std::string& strFilenameAndPath, CV
       // only add a new movie if we don't already have a valid idMovie
       // (DeleteMovie is called with bKeepId == true so the movie won't
       // be removed from the movie table)
-      idMovie = AddMovie(strFilenameAndPath);
+      idMovie = AddMovie(strFilenameAndPath, details.m_dateAdded);
       if (idMovie < 0)
       {
         RollbackTransaction();
@@ -2830,7 +2830,7 @@ int CVideoDatabase::SetDetailsForEpisode(const std::string& strFilenameAndPath,
       // only add a new episode if we don't already have a valid idEpisode
       // (DeleteEpisode is called with bKeepId == true so the episode won't
       // be removed from the episode table)
-      idEpisode = AddEpisode(idShow,strFilenameAndPath);
+      idEpisode = AddEpisode(idShow,strFilenameAndPath,details.m_dateAdded);
       if (idEpisode < 0)
       {
         RollbackTransaction();
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 1480e4f9a3f1..4bd95e9c04ae 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -422,8 +422,8 @@ class CVideoDatabase : public CDatabase
   bool Open() override;
   bool CommitTransaction() override;
 
-  int AddMovie(const std::string& strFilenameAndPath);
-  int AddEpisode(int idShow, const std::string& strFilenameAndPath);
+  int AddMovie(const std::string& strFilenameAndPath, const CDateTime& dateAdded = CDateTime());
+  int AddEpisode(int idShow, const std::string& strFilenameAndPath, const CDateTime& dateAdded = CDateTime());
 
   // editing functions
   /*! \brief Set the playcount of an item

From 5597c3ab6883bd8fd4c90b7578f04b4c3952f245 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sat, 18 Apr 2015 19:37:02 +0200
Subject: [PATCH 10/88] [videodb] add possibility to set the parent path
 through AddFile()

---
 xbmc/video/VideoDatabase.cpp | 4 ++--
 xbmc/video/VideoDatabase.h   | 3 ++-
 2 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 731d9d1ee401..fe2d110ce0f5 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -899,7 +899,7 @@ bool CVideoDatabase::GetSourcePath(const std::string &path, std::string &sourceP
 }
 
 //********************************************************************************************************************************
-int CVideoDatabase::AddFile(const std::string& strFileNameAndPath)
+int CVideoDatabase::AddFile(const std::string& strFileNameAndPath, const std::string &parentPath /* = "" */)
 {
   std::string strSQL = "";
   try
@@ -913,7 +913,7 @@ int CVideoDatabase::AddFile(const std::string& strFileNameAndPath)
     std::string strFileName, strPath;
     SplitPath(strFileNameAndPath,strPath,strFileName);
 
-    int idPath = AddPath(strPath);
+    int idPath = AddPath(strPath, parentPath);
     if (idPath < 0)
       return -1;
 
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 4bd95e9c04ae..ed6bbb385a7f 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -757,9 +757,10 @@ class CVideoDatabase : public CDatabase
   /*! \brief Add a file to the database, if necessary
    If the file is already in the database, we simply return its id.
    \param url - full path of the file to add.
+   \param parentPath the parent path of the path to add. If empty, URIUtils::GetParentPath() will determine the path.
    \return id of the file, -1 if it could not be added.
    */
-  int AddFile(const std::string& url);
+  int AddFile(const std::string& url, const std::string &parentPath = "");
 
   /*! \brief Add a file to the database, if necessary
    Works for both videodb:// items and normal fileitems

From 1e1aabb38a4332e5e10ff257a138e1f32d7d0cfe Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 14 Dec 2014 17:20:01 +0100
Subject: [PATCH 11/88] [videodb] add DeleteFile() and DeletePath()

---
 xbmc/video/VideoDatabase.cpp | 51 ++++++++++++++++++++++++++++++++++++
 xbmc/video/VideoDatabase.h   |  3 +++
 2 files changed, 54 insertions(+)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index fe2d110ce0f5..ade7e1d31633 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -3979,6 +3979,57 @@ bool CVideoDatabase::GetResumePoint(CVideoInfoTag& tag)
   return match;
 }
 
+void CVideoDatabase::DeleteFile(int idFile, const std::string &strFilenameAndPath /* = "" */)
+{
+  if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+    (idFile <= 0 && strFilenameAndPath.empty()))
+    return;
+
+  // if the file ID is invalid, try to get it from the path
+  if (idFile <= 0)
+    idFile = GetFileId(strFilenameAndPath);
+  // invalid file
+  if (idFile <= 0)
+    return;
+
+  std::string sql;
+  try
+  {
+    // finally delete the file itself
+    sql = PrepareSQL("DELETE FROM files WHERE idFile = %d", idFile);
+    m_pDS->exec(sql.c_str());
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s(%d, %s) failed: %s", __FUNCTION__, idFile, strFilenameAndPath.c_str(), sql.c_str());
+  }
+}
+
+void CVideoDatabase::DeletePath(int idPath, const std::string &strPath /* = "" */)
+{
+  if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+    (idPath <= 0 && strPath.empty()))
+    return;
+
+  // if the path ID is invalid, try to get it from the path
+  if (idPath <= 0)
+    idPath = GetPathId(strPath);
+  // invalid path
+  if (idPath <= 0)
+    return;
+
+  std::string sql;
+  try
+  {
+    sql = PrepareSQL("DELETE FROM path WHERE idPath = %d", idPath);
+    m_pDS->exec(sql.c_str());
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s(%d, %s) failed: %s", __FUNCTION__, idPath, strPath.c_str(), sql.c_str());
+  }
+}
+
 CVideoInfoTag CVideoDatabase::GetDetailsForMovie(std::unique_ptr<Dataset> &pDS, int getDetails /* = VideoDbDetailsNone */)
 {
   return GetDetailsForMovie(pDS->get_sql_record(), getDetails);
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index ed6bbb385a7f..9fe7b39ebc14 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -624,6 +624,9 @@ class CVideoDatabase : public CDatabase
   bool GetStreamDetails(CVideoInfoTag& tag) const;
   CVideoInfoTag GetDetailsByTypeAndId(VIDEODB_CONTENT_TYPE type, int id);
 
+  void DeleteFile(int idFile, const std::string &strFilenameAndPath = "");
+  void DeletePath(int idPath, const std::string &strPath = "");
+
   // scraper settings
   void SetScraperForPath(const std::string& filePath, const ADDON::ScraperPtr& info, const VIDEO::SScanSettings& settings);
   ADDON::ScraperPtr GetScraperForPath(const std::string& strPath);

From 9c18906cbaf28d7ceef6282f166a62575e1fdefd Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 14 Dec 2014 18:29:09 +0100
Subject: [PATCH 12/88] [videodb] change season_view to contain all seasons
 (including empty ones) but don't return them if not specifically asked for

---
 xbmc/video/VideoDatabase.cpp | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index ade7e1d31633..474ac92f946b 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -463,9 +463,9 @@ void CVideoDatabase::CreateViews()
                                      "FROM seasons"
                                      "  JOIN tvshow_view ON"
                                      "    tvshow_view.idShow = seasons.idShow"
-                                     "  JOIN episode ON"
+                                     "  LEFT JOIN episode ON"
                                      "    episode.idShow = seasons.idShow AND episode.c%02d = seasons.season"
-                                     "  JOIN files ON"
+                                     "  LEFT JOIN files ON"
                                      "    files.idFile = episode.idFile "
                                      "GROUP BY seasons.idSeason,"
                                      "         seasons.idShow,"
@@ -10604,6 +10604,11 @@ bool CVideoDatabase::GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription
         filter.AppendWhere(PrepareSQL("season_view.premiered like '%%%i%%'", (int)option->second.asInteger()));
 
       AppendIdLinkFilter("actor", "actor", "tvshow", "season", "idShow", options, filter);
+
+      // don't show empty seasons if not explicitly asked for
+      option = options.find("showempty");
+      if (option == options.end() || !option->second.asBoolean())
+        filter.AppendWhere(PrepareSQL("season_view.episodes > 0"));
     }
     else if (itemType == "episodes")
     {

From a4a1233aba4c9c79633405be7620a68c7914dd8d Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Mon, 14 Sep 2015 23:40:35 +0200
Subject: [PATCH 13/88] [videodb] extend GetSeasonsByWhere() to be able to
 handle incomplete base paths

---
 xbmc/video/VideoDatabase.cpp | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 474ac92f946b..67fdd6f445ef 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -7033,6 +7033,20 @@ bool CVideoDatabase::GetSeasonsByWhere(const std::string& strBaseDir, const Filt
       total = iRowsFound;
     items.SetProperty("total", total);
 
+    // sanitize the video url by removing the trailing "-1/" if present
+    if (appendFullShowPath)
+    {
+      CURL baseUrl(videoUrl.ToString());
+      baseUrl.SetOptions("");
+      std::string tmpBaseDir = baseUrl.Get();
+      URIUtils::RemoveSlashAtEnd(tmpBaseDir);
+      if (StringUtils::EndsWith(tmpBaseDir, "/-1"))
+      {
+        if (!videoUrl.FromString(tmpBaseDir.substr(0, tmpBaseDir.size() - 2)))
+          return false;
+      }
+    }
+
     std::set<std::pair<int, int>> mapSeasons;
     while (!m_pDS->eof())
     {

From a811628342ec4bf374471c18980288bd43efca4e Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 14 Dec 2014 23:48:04 +0100
Subject: [PATCH 14/88] [videodb] support not deleting seasons/episodes in
 DeleteTvShow()

---
 xbmc/video/VideoDatabase.cpp | 26 +++++++++++++++++---------
 xbmc/video/VideoDatabase.h   |  4 ++--
 2 files changed, 19 insertions(+), 11 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 67fdd6f445ef..4a366024a2b0 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -3499,14 +3499,14 @@ void CVideoDatabase::DeleteMovie(int idMovie, bool bKeepId /* = false */)
   }
 }
 
-void CVideoDatabase::DeleteTvShow(const std::string& strPath)
+void CVideoDatabase::DeleteTvShow(const std::string& strPath, bool deleteChildren /* = true */)
 {
   int idTvShow = GetTvShowId(strPath);
   if (idTvShow >= 0)
     DeleteTvShow(idTvShow);
 }
 
-void CVideoDatabase::DeleteTvShow(int idTvShow, bool bKeepId /* = false */)
+void CVideoDatabase::DeleteTvShow(int idTvShow, bool bKeepId /* = false */, bool deleteChildren /* = true */)
 {
   if (idTvShow < 0)
     return;
@@ -3523,18 +3523,26 @@ void CVideoDatabase::DeleteTvShow(int idTvShow, bool bKeepId /* = false */)
     std::set<int> paths;
     GetPathsForTvShow(idTvShow, paths);
 
-    std::string strSQL=PrepareSQL("SELECT episode.idEpisode FROM episode WHERE episode.idShow=%i",idTvShow);
-    m_pDS2->query(strSQL);
-    while (!m_pDS2->eof())
+    std::string strSQL;
+    if (deleteChildren)
     {
-      DeleteEpisode(m_pDS2->fv(0).get_asInt(), bKeepId);
-      m_pDS2->next();
+      strSQL = PrepareSQL("SELECT episode.idEpisode FROM episode WHERE episode.idShow=%i", idTvShow);
+      m_pDS2->query(strSQL);
+      while (!m_pDS2->eof())
+      {
+        DeleteEpisode(m_pDS2->fv(0).get_asInt(), bKeepId);
+        m_pDS2->next();
+      }
+      m_pDS2->close();
     }
 
     DeleteDetailsForTvShow(idTvShow);
 
-    strSQL=PrepareSQL("delete from seasons where idShow=%i", idTvShow);
-    m_pDS->exec(strSQL);
+    if (deleteChildren)
+    {
+      strSQL=PrepareSQL("delete from seasons where idShow=%i", idTvShow);
+      m_pDS->exec(strSQL);
+    }
 
     // keep tvshow table and movielink table so we can update data in place
     if (!bKeepId)
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 9fe7b39ebc14..6d864612c966 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -541,8 +541,8 @@ class CVideoDatabase : public CDatabase
 
   void DeleteMovie(int idMovie, bool bKeepId = false);
   void DeleteMovie(const std::string& strFilenameAndPath, bool bKeepId = false);
-  void DeleteTvShow(int idTvShow, bool bKeepId = false);
-  void DeleteTvShow(const std::string& strPath);
+  void DeleteTvShow(int idTvShow, bool bKeepId = false, bool deleteChildren = true);
+  void DeleteTvShow(const std::string& strPath, bool deleteChildren = true);
   void DeleteSeason(int idSeason, bool bKeepId = false);
   void DeleteEpisode(int idEpisode, bool bKeepId = false);
   void DeleteEpisode(const std::string& strFilenameAndPath, bool bKeepId = false);

From 2e2d1e7e5ac1d3180a3bd0769983899265d5b958 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 14 Dec 2014 17:09:20 +0100
Subject: [PATCH 15/88] [videodb] add methods to better handle multi-path
 tvshows

---
 xbmc/video/VideoDatabase.cpp    | 73 +++++++++++++++++++++++++++++++--
 xbmc/video/VideoDatabase.h      | 17 +++++++-
 xbmc/video/VideoInfoScanner.cpp |  2 +-
 3 files changed, 87 insertions(+), 5 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 4a366024a2b0..d68586092fd7 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -667,7 +667,7 @@ bool CVideoDatabase::GetPathsLinkedToTvShow(int idShow, std::vector<std::string>
   return false;
 }
 
-bool CVideoDatabase::GetPathsForTvShow(int idShow, std::set<int>& paths)
+bool CVideoDatabase::GetPathsForTvShowFromEpisodes(int idShow, std::set<int>& paths)
 {
   std::string strSQL;
   try
@@ -700,6 +700,41 @@ bool CVideoDatabase::GetPathsForTvShow(int idShow, std::set<int>& paths)
   return false;
 }
 
+bool CVideoDatabase::GetPathsForTvShow(int idShow, std::map<int, std::string>& paths)
+{
+  if (idShow <= 0)
+    return false;
+
+  std::string sql;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL)
+      return false;
+
+    sql = PrepareSQL("SELECT DISTINCT path.idPath, path.strPath FROM path "
+                     "JOIN tvshowlinkpath ON tvshowlinkpath.idPath = path.idPath "
+                     "WHERE tvshowlinkpath.idShow = %d",
+                     idShow);
+    int rows = RunQuery(sql);
+    if (rows <= 0)
+      return rows == 0;
+
+    while (!m_pDS->eof())
+    {
+      paths.insert(std::make_pair(m_pDS->fv(0).get_asInt(), m_pDS->fv(1).get_asString()));
+      m_pDS->next();
+    }
+
+    m_pDS->close();
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%d) error during query: %s", __FUNCTION__, idShow, sql.c_str());
+  }
+  return false;
+}
+
 int CVideoDatabase::RunQuery(const std::string &sql)
 {
   unsigned int time = XbmcThreads::SystemClockMillis();
@@ -1407,6 +1442,38 @@ bool CVideoDatabase::AddPathToTvShow(int idShow, const std::string &path, const
   return ExecuteQuery(PrepareSQL("REPLACE INTO tvshowlinkpath(idShow, idPath) VALUES (%i,%i)", idShow, idPath));
 }
 
+bool CVideoDatabase::RemovePathFromTvShow(int idShow, const std::string &path)
+{
+  if (idShow <= 0 || path.empty())
+    return false;
+
+  int idPath = GetPathId(path);
+  return RemovePathFromTvShow(idShow, idPath);
+}
+
+bool CVideoDatabase::RemovePathFromTvShow(int idShow, int idPath)
+{
+  if (idShow <= 0 || idPath <= 0)
+    return false;
+
+  std::string sql;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL)
+      return false;
+
+    sql = PrepareSQL("DELETE FROM tvshowlinkpath WHERE idShow = %d AND idPath = %d", idShow, idPath);
+    m_pDS->exec(sql);
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%d, %d) error during query: %s", __FUNCTION__, idShow, idPath, sql.c_str());
+  }
+  return false;
+}
+
 int CVideoDatabase::AddTvShow()
 {
   if (ExecuteQuery("INSERT INTO tvshow(idShow) VALUES(NULL)"))
@@ -3520,7 +3587,7 @@ void CVideoDatabase::DeleteTvShow(int idTvShow, bool bKeepId /* = false */, bool
 
     BeginTransaction();
 
-    std::set<int> paths;
+    std::map<int, std::string> paths;
     GetPathsForTvShow(idTvShow, paths);
 
     std::string strSQL;
@@ -3552,7 +3619,7 @@ void CVideoDatabase::DeleteTvShow(int idTvShow, bool bKeepId /* = false */, bool
 
       for (const auto &i : paths)
       {
-        std::string path = GetSingleValue(PrepareSQL("SELECT strPath FROM path WHERE idPath=%i", i));
+        std::string path = GetSingleValue(PrepareSQL("SELECT strPath FROM path WHERE idPath=%i", i.first));
         if (!path.empty())
           InvalidatePathHash(path);
       }
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 6d864612c966..a4c5068febc6 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -670,7 +670,8 @@ class CVideoDatabase : public CDatabase
   bool SetPathHash(const std::string &path, const std::string &hash);
   bool GetPathHash(const std::string &path, std::string &hash);
   bool GetPaths(std::set<std::string> &paths);
-  bool GetPathsForTvShow(int idShow, std::set<int>& paths);
+  bool GetPathsForTvShowFromEpisodes(int idShow, std::set<int>& paths);
+  bool GetPathsForTvShow(int idShow, std::map<int, std::string>& paths);
 
   /*! \brief return the paths linked to a tvshow.
    \param idShow the id of the tvshow.
@@ -879,6 +880,20 @@ class CVideoDatabase : public CDatabase
   void SetMovieSet(int idMovie, int idSet);
   bool SetVideoUserRating(int dbId, int rating, const MediaType& mediaType);
 
+  /*! \brief Removes the path from the tvshow link table.
+  \param idShow the id of the show.
+  \param path the path to remove.
+  \return true if successfully removed, false otherwise.
+  */
+  bool RemovePathFromTvShow(int idShow, const std::string &path);
+
+  /*! \brief Removes the path from the tvshow link table.
+  \param idShow the id of the show.
+  \param idPath the id of the path to remove.
+  \return true if successfully removed, false otherwise.
+  */
+  bool RemovePathFromTvShow(int idShow, int idPath);
+
 protected:
   int GetMovieId(const std::string& strFilenameAndPath);
   int GetMusicVideoId(const std::string& strFilenameAndPath);
diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index 6d1f7dbed559..96281ea4a315 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -909,7 +909,7 @@ namespace VIDEO
       if (m_bClean)
       {
         m_pathsToClean.insert(m_database.GetPathId(item->GetPath()));
-        m_database.GetPathsForTvShow(m_database.GetTvShowId(item->GetPath()), m_pathsToClean);
+        m_database.GetPathsForTvShowFromEpisodes(m_database.GetTvShowId(item->GetPath()), m_pathsToClean);
       }
       item->SetProperty("hash", hash);
     }

From 23fda1f7f582d0968411c9c7b52b34a6fe48039f Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 14 Dec 2014 17:17:24 +0100
Subject: [PATCH 16/88] [videodb] support not deleteing episodes in
 DeleteSeason()

---
 xbmc/video/VideoDatabase.cpp | 19 +++++++++++--------
 xbmc/video/VideoDatabase.h   |  2 +-
 2 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index d68586092fd7..cab4d2359931 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -3639,7 +3639,7 @@ void CVideoDatabase::DeleteTvShow(int idTvShow, bool bKeepId /* = false */, bool
   }
 }
 
-void CVideoDatabase::DeleteSeason(int idSeason, bool bKeepId /* = false */)
+void CVideoDatabase::DeleteSeason(int idSeason, bool bKeepId /* = false */, bool deleteChildren /* = true */)
 {
   if (idSeason < 0)
     return;
@@ -3651,14 +3651,17 @@ void CVideoDatabase::DeleteSeason(int idSeason, bool bKeepId /* = false */)
 
     BeginTransaction();
 
-    std::string strSQL = PrepareSQL("SELECT episode.idEpisode FROM episode "
-                                    "JOIN seasons ON seasons.idSeason = %d AND episode.idShow = seasons.idShow AND episode.c%02d = seasons.season ",
-                                   idSeason, VIDEODB_ID_EPISODE_SEASON);
-    m_pDS2->query(strSQL);
-    while (!m_pDS2->eof())
+    if (deleteChildren)
     {
-      DeleteEpisode(m_pDS2->fv(0).get_asInt(), bKeepId);
-      m_pDS2->next();
+      std::string strSQL = PrepareSQL("SELECT episode.idEpisode FROM episode "
+                                      "JOIN seasons ON seasons.idSeason = %d AND episode.idShow = seasons.idShow AND episode.c%02d = seasons.season ",
+                                      idSeason, VIDEODB_ID_EPISODE_SEASON);
+      m_pDS2->query(strSQL);
+      while (!m_pDS2->eof())
+      {
+        DeleteEpisode(m_pDS2->fv(0).get_asInt(), bKeepId);
+        m_pDS2->next();
+      }
     }
 
     ExecuteQuery(PrepareSQL("DELETE FROM seasons WHERE idSeason = %i", idSeason));
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index a4c5068febc6..764de5b2b8ab 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -543,7 +543,7 @@ class CVideoDatabase : public CDatabase
   void DeleteMovie(const std::string& strFilenameAndPath, bool bKeepId = false);
   void DeleteTvShow(int idTvShow, bool bKeepId = false, bool deleteChildren = true);
   void DeleteTvShow(const std::string& strPath, bool deleteChildren = true);
-  void DeleteSeason(int idSeason, bool bKeepId = false);
+  void DeleteSeason(int idSeason, bool bKeepId = false, bool deleteChildren = true);
   void DeleteEpisode(int idEpisode, bool bKeepId = false);
   void DeleteEpisode(const std::string& strFilenameAndPath, bool bKeepId = false);
   void DeleteMusicVideo(int idMusicVideo, bool bKeepId = false);

From 1ff09c9f5313123281b2b5e769638f1dc23cfaff Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 30 Nov 2019 00:35:58 +0100
Subject: [PATCH 17/88] [videodb] support avoiding VideoLibrary.OnUpdate
 announcements in SetPlayCount()

---
 xbmc/video/VideoDatabase.cpp | 6 ++++--
 xbmc/video/VideoDatabase.h   | 3 ++-
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index cab4d2359931..dc96054f1607 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -5982,7 +5982,7 @@ void CVideoDatabase::UpdateFanart(const CFileItem &item, VIDEODB_CONTENT_TYPE ty
   }
 }
 
-void CVideoDatabase::SetPlayCount(const CFileItem &item, int count, const CDateTime &date)
+void CVideoDatabase::SetPlayCount(const CFileItem &item, int count, const CDateTime &date, bool announceUpdate /* = true */)
 {
   int id;
   if (item.HasProperty("original_listitem_url") &&
@@ -6032,7 +6032,9 @@ void CVideoDatabase::SetPlayCount(const CFileItem &item, int count, const CDateT
       // Only provide the "playcount" value if it has actually changed
       if (item.GetVideoInfoTag()->GetPlayCount() != count)
         data["playcount"] = count;
-      CServiceBroker::GetAnnouncementManager()->Announce(ANNOUNCEMENT::VideoLibrary, "xbmc", "OnUpdate", CFileItemPtr(new CFileItem(item)), data);
+
+      if (announceUpdate)
+        CServiceBroker::GetAnnouncementManager()->Announce(ANNOUNCEMENT::VideoLibrary, "xbmc", "OnUpdate", CFileItemPtr(new CFileItem(item)), data);
     }
   }
   catch (...)
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 764de5b2b8ab..0e0e499efda7 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -431,9 +431,10 @@ class CVideoDatabase : public CDatabase
    \param item CFileItem to set the playcount for
    \param count The playcount to set.
    \param date The date the file was last viewed (does not denote the video was watched to completion).  If empty we current datetime (if count > 0) or never viewed (if count = 0).
+   \param announceUpdate Whether or not to announce the changes.
    \sa GetPlayCount, IncrementPlayCount, UpdateLastPlayed
    */
-  void SetPlayCount(const CFileItem &item, int count, const CDateTime &date = CDateTime());
+  void SetPlayCount(const CFileItem &item, int count, const CDateTime &date = CDateTime(), bool announceUpdate = true);
 
   /*! \brief Increment the playcount of an item
    Increments the playcount and updates the last played date

From 8171dd775b7d4804d07fb26224d7b57e3bf0a590 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 14 Jan 2020 22:14:56 +0100
Subject: [PATCH 18/88] [videodb] support avoiding VideoLibrary.OnUpdate
 announcements in DeleteResumeBookMark()

---
 xbmc/video/VideoDatabase.cpp | 4 ++--
 xbmc/video/VideoDatabase.h   | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index dc96054f1607..f53aff0d7890 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -3260,7 +3260,7 @@ bool CVideoDatabase::GetResumeBookMark(const std::string& strFilenameAndPath, CB
   return false;
 }
 
-void CVideoDatabase::DeleteResumeBookMark(const CFileItem& item)
+void CVideoDatabase::DeleteResumeBookMark(const CFileItem& item, bool announceUpdate /* = true */)
 {
   if (!m_pDB || !m_pDS)
     return;
@@ -3298,7 +3298,7 @@ void CVideoDatabase::DeleteResumeBookMark(const CFileItem& item)
         break;
     }
 
-    if (!content.empty())
+    if (announceUpdate && !content.empty())
     {
       AnnounceUpdate(content, item.GetVideoInfoTag()->m_iDbId);
     }
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 0e0e499efda7..ee970c91f3c9 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -613,7 +613,7 @@ class CVideoDatabase : public CDatabase
   void GetBookMarksForFile(const std::string& strFilenameAndPath, VECBOOKMARKS& bookmarks, CBookmark::EType type = CBookmark::STANDARD, bool bAppend=false, long partNumber=0);
   void AddBookMarkToFile(const std::string& strFilenameAndPath, const CBookmark &bookmark, CBookmark::EType type = CBookmark::STANDARD);
   bool GetResumeBookMark(const std::string& strFilenameAndPath, CBookmark &bookmark);
-  void DeleteResumeBookMark(const CFileItem& item);
+  void DeleteResumeBookMark(const CFileItem& item, bool announceUpdate = true);
   void ClearBookMarkOfFile(const std::string& strFilenameAndPath, CBookmark& bookmark, CBookmark::EType type = CBookmark::STANDARD);
   void ClearBookMarksOfFile(const std::string& strFilenameAndPath, CBookmark::EType type = CBookmark::STANDARD);
   void ClearBookMarksOfFile(int idFile, CBookmark::EType type = CBookmark::STANDARD);

From a33adfcf60c5b35680366780545656088158b8f2 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Tue, 21 Jan 2014 15:19:18 +0100
Subject: [PATCH 19/88] [media import] add CMediaImportSource and CMediaImport

---
 .../resources/strings.po                      |  45 ++-
 cmake/treedata/common/media.txt               |   1 +
 xbmc/media/import/CMakeLists.txt              |   9 +
 xbmc/media/import/MediaImport.cpp             | 262 ++++++++++++++++++
 xbmc/media/import/MediaImport.h               | 151 ++++++++++
 xbmc/media/import/MediaImportSettingsBase.cpp | 234 ++++++++++++++++
 xbmc/media/import/MediaImportSettingsBase.h   |  83 ++++++
 xbmc/media/import/MediaImportSource.cpp       |  75 +++++
 xbmc/media/import/MediaImportSource.h         |  98 +++++++
 9 files changed, 957 insertions(+), 1 deletion(-)
 create mode 100644 xbmc/media/import/CMakeLists.txt
 create mode 100644 xbmc/media/import/MediaImport.cpp
 create mode 100644 xbmc/media/import/MediaImport.h
 create mode 100644 xbmc/media/import/MediaImportSettingsBase.cpp
 create mode 100644 xbmc/media/import/MediaImportSettingsBase.h
 create mode 100644 xbmc/media/import/MediaImportSource.cpp
 create mode 100644 xbmc/media/import/MediaImportSource.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 4334be50cf27..31bc3ea01a29 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -8605,7 +8605,10 @@ msgctxt "#16000"
 msgid "General"
 msgstr ""
 
-#empty string with id 16001
+#: xbmc/media/import/MediaImport.cpp
+msgctxt "#16001"
+msgid "Media Import"
+msgstr ""
 
 msgctxt "#16002"
 msgid "Internet lookup"
@@ -22132,3 +22135,43 @@ msgctxt "#39119"
 msgid "Last modified"
 msgstr ""
 
+# empty strings from id 39120 to 39500
+
+# empty strings from id 39500 to 39529 are reserved for media import
+
+#: xbmc/media/import/MediaImport.cpp
+msgctxt "#39530"
+msgid "Synchronisation"
+msgstr ""
+
+#: xbmc/media/import/MediaImport.cpp
+msgctxt "#39531"
+msgid "Update imported media items"
+msgstr ""
+
+#: xbmc/media/import/MediaImport.cpp
+msgctxt "#39532"
+msgid "Update playback-related metadata"
+msgstr ""
+
+#: xbmc/media/import/MediaImport.cpp
+msgctxt "#39533"
+msgid "Update playback-related metadata on the media provider"
+msgstr ""
+
+#: xbmc/media/import/MediaImport.cpp
+msgctxt "#39534"
+msgid "Start synchronisation"
+msgstr ""
+
+#: xbmc/media/import/MediaImport.cpp
+msgctxt "#39535"
+msgid "Automatically"
+msgstr ""
+
+#: xbmc/media/import/MediaImport.cpp
+msgctxt "#39536"
+msgid "Manually"
+msgstr ""
+
+# empty strings from id 39537 to 39549 are reserved for media import settings
diff --git a/cmake/treedata/common/media.txt b/cmake/treedata/common/media.txt
index 519fece95513..7ae01aa061db 100644
--- a/cmake/treedata/common/media.txt
+++ b/cmake/treedata/common/media.txt
@@ -1,2 +1,3 @@
 xbmc/media                                      media
 xbmc/media/drm                                  drm
+xbmc/media/import                               media/import
diff --git a/xbmc/media/import/CMakeLists.txt b/xbmc/media/import/CMakeLists.txt
new file mode 100644
index 000000000000..7e0de5a6b4ed
--- /dev/null
+++ b/xbmc/media/import/CMakeLists.txt
@@ -0,0 +1,9 @@
+set(SOURCES MediaImport.cpp
+            MediaImportSettingsBase.cpp
+            MediaImportSource.cpp)
+
+set(HEADERS MediaImport.h
+            MediaImportSettingsBase.h
+            MediaImportSource.h)
+
+core_add_library(media_import)
diff --git a/xbmc/media/import/MediaImport.cpp b/xbmc/media/import/MediaImport.cpp
new file mode 100644
index 000000000000..e5fd78edf20d
--- /dev/null
+++ b/xbmc/media/import/MediaImport.cpp
@@ -0,0 +1,262 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImport.h"
+
+#include "utils/StringUtils.h"
+
+#include <algorithm>
+
+const std::string CMediaImportSettings::SettingTrigger = "sync.importtrigger";
+const std::string CMediaImportSettings::SettingTriggerValueAuto = "auto";
+const std::string CMediaImportSettings::SettingTriggerValueManual = "manual";
+const std::string CMediaImportSettings::SettingUpdateItems = "sync.updateimporteditems";
+const std::string CMediaImportSettings::SettingUpdatePlaybackMetadataFromSource =
+    "sync.updateplaybackmetadatafromsource";
+const std::string CMediaImportSettings::SettingUpdatePlaybackMetadataOnSource =
+    "sync.updateplaybackmetadataonsource";
+
+const std::string CMediaImportSettings::SettingsDefinition = R"(
+<?xml version="1.0" encoding="utf-8" ?>
+<settings version="1">
+  <section id="import" label="16001">
+    <category id="sync" label="39530">
+      <group id="1">
+        <setting id=")" + SettingTrigger + R"(" type="string" label="39534">
+          <level>0</level>
+          <default>)" + SettingTriggerValueAuto + R"(</default>
+          <constraints>
+            <allowempty>false</allowempty>
+            <options>
+              <option label="39535">)" + SettingTriggerValueAuto +
+                                                             R"(</option>
+              <option label="39536">)" + SettingTriggerValueManual +
+                                                             R"(</option>
+            </options>
+          </constraints>
+          <control type="spinner" format="string" />
+        </setting>
+      </group>
+      <group id="2">
+        <setting id=")" + SettingUpdateItems + R"(" type="boolean" label="39531">
+          <level>0</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+        <setting id=")" + SettingUpdatePlaybackMetadataFromSource +
+                                                             R"(" type="boolean" parent=")" +
+                                                             SettingUpdateItems +
+                                                             R"(" label="39532">
+          <level>0</level>
+          <default>true</default>
+          <dependencies>
+            <dependency type="enable" setting=")" + SettingUpdateItems +
+                                                             R"(">true</dependency>
+          </dependencies>
+          <control type="toggle" />
+        </setting>
+        <setting id=")" + SettingUpdatePlaybackMetadataOnSource +
+                                                             R"(" type="boolean" label="39533">
+          <level>0</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+      </group>
+    </category>
+  </section>
+</settings>
+)";
+
+const std::string CMediaImportSettings::SettingConditionHasMediaType = "hasmediatype";
+
+CMediaImportSettings::CMediaImportSettings(const GroupedMediaTypes& mediaTypes,
+                                           const std::string& settingValues /* = "" */)
+  : CMediaImportSettingsBase(settingValues), m_mediaTypes(mediaTypes)
+{
+  Setup();
+}
+
+CMediaImportSettings::CMediaImportSettings(const CMediaImportSettings& other)
+  : CMediaImportSettingsBase(other), m_mediaTypes(other.m_mediaTypes)
+{
+  Setup();
+}
+
+MediaImportTrigger CMediaImportSettings::GetImportTrigger() const
+{
+  if (!IsLoaded())
+    return MediaImportTrigger::Auto;
+
+  const auto trigger = GetString(SettingTrigger);
+  if (trigger == SettingTriggerValueManual)
+    return MediaImportTrigger::Manual;
+
+  return MediaImportTrigger::Auto;
+}
+
+bool CMediaImportSettings::SetImportTrigger(MediaImportTrigger importTrigger)
+{
+  if (!IsLoaded())
+    return false;
+
+  std::string trigger = SettingTriggerValueAuto;
+  switch (importTrigger)
+  {
+    case MediaImportTrigger::Manual:
+      trigger = SettingTriggerValueManual;
+      break;
+
+    case MediaImportTrigger::Auto:
+    default:
+      trigger = SettingTriggerValueAuto;
+      break;
+  }
+
+  return SetString(SettingTrigger, trigger);
+}
+
+bool CMediaImportSettings::UpdateImportedMediaItems() const
+{
+  if (!IsLoaded())
+    return true;
+
+  return GetBool(SettingUpdateItems);
+}
+
+bool CMediaImportSettings::SetUpdateImportedMediaItems(bool updateImportedMediaItems)
+{
+  if (!IsLoaded())
+    return false;
+
+  return SetBool(SettingUpdateItems, updateImportedMediaItems);
+}
+
+bool CMediaImportSettings::UpdatePlaybackMetadataFromSource() const
+{
+  if (!IsLoaded())
+    return true;
+
+  return GetBool(SettingUpdatePlaybackMetadataFromSource);
+}
+
+bool CMediaImportSettings::SetUpdatePlaybackMetadataFromSource(
+    bool updatePlaybackMetadataFromSource)
+{
+  if (!IsLoaded())
+    return false;
+
+  return SetBool(SettingUpdatePlaybackMetadataFromSource, updatePlaybackMetadataFromSource);
+}
+
+bool CMediaImportSettings::UpdatePlaybackMetadataOnSource() const
+{
+  if (!IsLoaded())
+    return true;
+
+  return GetBool(SettingUpdatePlaybackMetadataOnSource);
+}
+
+bool CMediaImportSettings::SetUpdatePlaybackMetadataOnSource(bool updatePlaybackMetadataOnSource)
+{
+  if (!IsLoaded())
+    return false;
+
+  return SetBool(SettingUpdatePlaybackMetadataOnSource, updatePlaybackMetadataOnSource);
+}
+
+void CMediaImportSettings::Setup()
+{
+  AddDefinition(SettingsDefinition);
+
+  AddComplexCondition(SettingConditionHasMediaType, HasMediaType, this);
+}
+
+bool CMediaImportSettings::HasMediaType(const std::string& condition,
+                                        const std::string& value,
+                                        std::shared_ptr<const CSetting> setting,
+                                        void* data)
+{
+  if (data == nullptr)
+    return false;
+
+  auto mediaType = value;
+  StringUtils::ToLower(mediaType);
+
+  auto mediaImportSettings = reinterpret_cast<CMediaImportSettings*>(data);
+  const auto& mediaTypes = mediaImportSettings->m_mediaTypes;
+  if (std::find(mediaTypes.begin(), mediaTypes.end(), mediaType) == mediaTypes.end())
+    return false;
+
+  return true;
+}
+
+CMediaImport::CMediaImport(const std::string& importPath /* = "" */)
+  : CMediaImport(importPath, CMediaImportSource(importPath))
+{
+}
+
+CMediaImport::CMediaImport(const std::string& importPath, const CMediaImportSource& source)
+  : CMediaImport(importPath, source, {}, true, CDateTime(), "")
+{
+}
+
+CMediaImport::CMediaImport(const std::string& importPath,
+                           const CMediaImportSource& source,
+                           const GroupedMediaTypes& importedMediaTypes,
+                           bool recursive,
+                           const CDateTime& lastSynced,
+                           const std::string& settingValues)
+  : m_importPath(importPath),
+    m_mediaTypes(importedMediaTypes),
+    m_source(source),
+    m_recursive(recursive),
+    m_lastSynced(lastSynced),
+    m_settings(std::make_shared<CMediaImportSettings>(m_mediaTypes, settingValues))
+{
+}
+
+CMediaImport::CMediaImport(const CMediaImport& other)
+  : m_importPath(other.m_importPath),
+    m_mediaTypes(other.m_mediaTypes),
+    m_source(other.m_source),
+    m_recursive(other.m_recursive),
+    m_lastSynced(other.m_lastSynced),
+    m_settings(other.m_settings)
+{
+}
+
+bool CMediaImport::operator==(const CMediaImport& other) const
+{
+  if (m_importPath.compare(other.m_importPath) != 0 || m_source != other.m_source ||
+      m_mediaTypes != other.m_mediaTypes || m_recursive != other.m_recursive ||
+      m_lastSynced != other.m_lastSynced || *m_settings != *other.m_settings)
+    return false;
+
+  return true;
+}
+
+CMediaImport CMediaImport::Clone() const
+{
+  CMediaImport clone(*this);
+
+  // deep-copy the source and the settings
+  clone.m_source = m_source.Clone();
+  clone.m_settings = std::make_shared<CMediaImportSettings>(*m_settings);
+
+  return clone;
+}
+
+bool CMediaImport::ContainsMediaType(const GroupedMediaTypes::value_type mediaType) const
+{
+  return std::find(m_mediaTypes.cbegin(), m_mediaTypes.cend(), mediaType) != m_mediaTypes.cend();
+}
+
+std::ostream& operator<<(std::ostream& os, const CMediaImport& import)
+{
+  return os << import.GetPath() << " (" << StringUtils::Join(import.GetMediaTypes(), ", ") << ")";
+}
diff --git a/xbmc/media/import/MediaImport.h b/xbmc/media/import/MediaImport.h
new file mode 100644
index 000000000000..695cdf00c2eb
--- /dev/null
+++ b/xbmc/media/import/MediaImport.h
@@ -0,0 +1,151 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "XBDateTime.h"
+#include "media/MediaType.h"
+#include "media/import/MediaImportSource.h"
+
+#include <memory>
+#include <set>
+#include <string>
+
+enum class MediaImportTrigger
+{
+  Auto = 0,
+  Manual = 1
+};
+
+class CMediaImportSettings : public CMediaImportSettingsBase
+{
+public:
+  explicit CMediaImportSettings(const GroupedMediaTypes& mediaTypes,
+                                const std::string& settingValues = "");
+  CMediaImportSettings(const CMediaImportSettings& other);
+  virtual ~CMediaImportSettings() = default;
+
+  MediaImportTrigger GetImportTrigger() const;
+  bool SetImportTrigger(MediaImportTrigger importTrigger);
+  bool UpdateImportedMediaItems() const;
+  bool SetUpdateImportedMediaItems(bool updateImportedMediaItems);
+  bool UpdatePlaybackMetadataFromSource() const;
+  bool SetUpdatePlaybackMetadataFromSource(bool updatePlaybackMetadataFromSource);
+  bool UpdatePlaybackMetadataOnSource() const;
+  bool SetUpdatePlaybackMetadataOnSource(bool updatePlaybackMetadataOnSource);
+
+  static const std::string SettingTrigger;
+  static const std::string SettingTriggerValueAuto;
+  static const std::string SettingTriggerValueManual;
+  static const std::string SettingUpdateItems;
+  static const std::string SettingUpdatePlaybackMetadataFromSource;
+  static const std::string SettingUpdatePlaybackMetadataOnSource;
+
+private:
+  static const std::string SettingsDefinition;
+
+  static const std::string SettingConditionHasMediaType;
+
+  void Setup();
+
+  static bool HasMediaType(const std::string& condition,
+                           const std::string& value,
+                           std::shared_ptr<const CSetting> setting,
+                           void* data);
+
+  const GroupedMediaTypes m_mediaTypes;
+};
+
+using MediaImportSettingsPtr = std::shared_ptr<CMediaImportSettings>;
+using MediaImportSettingsConstPtr = std::shared_ptr<const CMediaImportSettings>;
+
+class CMediaImport
+{
+public:
+  explicit CMediaImport(const std::string& importPath = "");
+  CMediaImport(const std::string& importPath, const CMediaImportSource& source);
+  CMediaImport(const CMediaImport& other);
+
+  ~CMediaImport() = default;
+
+  static CMediaImport CreateRecursive(const std::string& importPath,
+                                      const GroupedMediaTypes& importedMediaTypes,
+                                      const CMediaImportSource& source,
+                                      const CDateTime& lastSynced = CDateTime(),
+                                      const std::string& settingValues = "")
+  {
+    return CMediaImport(importPath, source, importedMediaTypes, true, lastSynced, settingValues);
+  }
+  static CMediaImport CreateSelective(const std::string& importPath,
+                                      const GroupedMediaTypes& importedMediaTypes,
+                                      const CMediaImportSource& source,
+                                      const CDateTime& lastSynced = CDateTime(),
+                                      const std::string& settingValues = "")
+  {
+    return CMediaImport(importPath, source, importedMediaTypes, false, lastSynced, settingValues);
+  }
+
+  bool operator==(const CMediaImport& other) const;
+  bool operator!=(const CMediaImport& other) const { return !(*this == other); }
+
+  CMediaImport Clone() const;
+
+  const std::string& GetPath() const { return m_importPath; }
+
+  CMediaImportSource& GetSource() { return m_source; }
+  const CMediaImportSource& GetSource() const { return m_source; }
+  void SetSource(const CMediaImportSource& source)
+  {
+    if (source.GetIdentifier().empty())
+      return;
+
+    m_source = source;
+  }
+
+  const GroupedMediaTypes& GetMediaTypes() const { return m_mediaTypes; }
+  void SetMediaTypes(const GroupedMediaTypes& mediaTypes) { m_mediaTypes = mediaTypes; }
+  bool ContainsMediaType(const GroupedMediaTypes::value_type mediaType) const;
+
+  bool IsRecursive() const { return m_recursive; }
+  void SetRecursive(bool recursive) { m_recursive = recursive; }
+
+  const CDateTime& GetLastSynced() const { return m_lastSynced; }
+  void SetLastSynced(const CDateTime& lastSynced)
+  {
+    m_lastSynced = lastSynced;
+    m_source.SetLastSynced(lastSynced);
+  }
+
+  MediaImportSettingsConstPtr Settings() const { return m_settings; }
+  MediaImportSettingsPtr Settings() { return m_settings; }
+
+  bool IsActive() const { return m_source.IsActive(); }
+  void SetActive(bool active) { m_source.SetActive(active); }
+
+  bool IsReady() const { return m_source.IsReady(); }
+  void SetReady(bool ready) { m_source.SetReady(ready); }
+
+  friend std::ostream& operator<<(std::ostream& os, const CMediaImport& import);
+
+private:
+  CMediaImport(const std::string& importPath,
+               const CMediaImportSource& source,
+               const GroupedMediaTypes& importedMediaTypes,
+               bool recursive,
+               const CDateTime& lastSynced,
+               const std::string& settingValues);
+
+  std::string m_importPath;
+  GroupedMediaTypes m_mediaTypes;
+  CMediaImportSource m_source;
+  bool m_recursive;
+  CDateTime m_lastSynced;
+  MediaImportSettingsPtr m_settings;
+};
+
+using MediaImportPtr = std::shared_ptr<CMediaImport>;
diff --git a/xbmc/media/import/MediaImportSettingsBase.cpp b/xbmc/media/import/MediaImportSettingsBase.cpp
new file mode 100644
index 000000000000..6c87921f6c9f
--- /dev/null
+++ b/xbmc/media/import/MediaImportSettingsBase.cpp
@@ -0,0 +1,234 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportSettingsBase.h"
+
+#include "settings/lib/SettingsManager.h"
+#include "utils/XBMCTinyXML.h"
+#include "utils/log.h"
+
+CMediaImportSettingsBase::CMediaImportSettingsBase(const std::string& settingValues /* = "" */)
+  : CSettingsBase(), CStaticLoggerBase("CMediaImportSettingsBase"), m_settingValues(settingValues)
+{
+}
+
+CMediaImportSettingsBase::CMediaImportSettingsBase(const CMediaImportSettingsBase& other)
+  : CMediaImportSettingsBase(other.m_settingValues)
+{
+  m_settingDefinitions = other.m_settingDefinitions;
+  m_simpleConditions = other.m_simpleConditions;
+  // ATTENTION: don't copy complex conditions because they may contain instance specific userdata
+
+  if (other.IsLoaded())
+    Load();
+}
+
+bool CMediaImportSettingsBase::operator==(const CMediaImportSettingsBase& other) const
+{
+  if (ToXml() != other.ToXml())
+    return false;
+
+  if (IsLoaded() != other.IsLoaded())
+    return true;
+
+  return m_settingDefinitions == other.m_settingDefinitions;
+}
+
+CMediaImportSettingsBase& CMediaImportSettingsBase::operator=(const CMediaImportSettingsBase& other)
+{
+  if (this == &other)
+    return *this;
+
+  if (IsLoaded())
+    Unload();
+
+  m_settingValues = other.m_settingValues;
+  m_settingDefinitions = other.m_settingDefinitions;
+
+  if (other.IsLoaded())
+    Load();
+
+  return *this;
+}
+
+bool CMediaImportSettingsBase::Load()
+{
+  // try to initialize the settings by loading its definitions
+  if (!Initialize())
+  {
+    s_logger->error("failed to initialize settings");
+    return false;
+  }
+
+  // if available try to load the setting's values
+  if (!m_settingValues.empty())
+  {
+    CXBMCTinyXML xmlValues;
+    if (!xmlValues.Parse(m_settingValues, TIXML_ENCODING_UTF8))
+    {
+      s_logger->error("error loading setting values, Line {}\n{}", xmlValues.ErrorRow(),
+                      xmlValues.ErrorDesc());
+      Uninitialize();
+      return false;
+    }
+
+    bool updated;
+    if (!LoadValuesFromXml(xmlValues, updated))
+    {
+      s_logger->error("failed to load setting values");
+      Uninitialize();
+      return false;
+    }
+  }
+
+  // we are done with loading
+  SetLoaded();
+
+  return true;
+}
+
+bool CMediaImportSettingsBase::Save()
+{
+  if (!IsLoaded())
+    return false;
+
+  m_settingValues = ToXml();
+  return true;
+}
+
+void CMediaImportSettingsBase::Unload()
+{
+  CSettingsBase::Unload();
+  CSettingsBase::Uninitialize();
+}
+
+bool CMediaImportSettingsBase::HasDefinition(const std::string& settingDefinition) const
+{
+  return m_settingDefinitions.find(settingDefinition) != m_settingDefinitions.end();
+}
+
+void CMediaImportSettingsBase::AddDefinition(const std::string& settingDefinition)
+{
+  m_settingDefinitions.insert(settingDefinition);
+}
+
+void CMediaImportSettingsBase::AddSimpleCondition(const std::string& condition)
+{
+  m_simpleConditions.insert(condition);
+}
+
+void CMediaImportSettingsBase::AddComplexCondition(const std::string& name,
+                                                   const SettingConditionCheck& condition,
+                                                   void* data /* = nullptr */)
+{
+  m_complexConditions.emplace(name, std::make_tuple(condition, data));
+}
+
+void CMediaImportSettingsBase::SetOptionsFiller(const std::string& settingId,
+                                                IntegerSettingOptionsFiller optionsFiller,
+                                                void* data /* = nullptr */)
+{
+  if (!IsLoaded() || settingId.empty())
+    return;
+
+  auto setting = GetSetting(settingId);
+  if (setting == nullptr)
+    return;
+
+  if (setting->GetType() == SettingType::List)
+    setting = std::static_pointer_cast<CSettingList>(setting)->GetDefinition();
+
+  if (setting->GetType() != SettingType::Integer)
+    return;
+
+  std::static_pointer_cast<CSettingInt>(setting)->SetOptionsFiller(optionsFiller, data);
+}
+
+void CMediaImportSettingsBase::SetOptionsFiller(const std::string& settingId,
+                                                StringSettingOptionsFiller optionsFiller,
+                                                void* data /* = nullptr */)
+{
+  if (!IsLoaded() || settingId.empty())
+    return;
+
+  auto setting = GetSetting(settingId);
+  if (setting == nullptr)
+    return;
+
+  if (setting->GetType() == SettingType::List)
+    setting = std::static_pointer_cast<CSettingList>(setting)->GetDefinition();
+
+  if (setting->GetType() != SettingType::String)
+    return;
+
+  std::static_pointer_cast<CSettingString>(setting)->SetOptionsFiller(optionsFiller, data);
+}
+
+std::string CMediaImportSettingsBase::ToXml() const
+{
+  if (!IsLoaded())
+    return m_settingValues;
+
+  CXBMCTinyXML xmlValues;
+  if (!SaveValuesToXml(xmlValues))
+    return m_settingValues;
+
+  TiXmlPrinter printer;
+  xmlValues.Accept(&printer);
+
+  return printer.Str();
+}
+
+bool CMediaImportSettingsBase::InitializeDefinitions()
+{
+  if (m_settingDefinitions.empty())
+    return true;
+
+  for (const auto& settingDefinition : m_settingDefinitions)
+  {
+    CXBMCTinyXML xmlDefinition;
+    if (!xmlDefinition.Parse(settingDefinition, TIXML_ENCODING_UTF8))
+    {
+      s_logger->error("error loading settings definition, Line {}\n{}", xmlDefinition.ErrorRow(),
+                      xmlDefinition.ErrorDesc());
+      return false;
+    }
+
+    if (xmlDefinition.RootElement() == nullptr)
+      return false;
+
+    if (!InitializeDefinitionsFromXml(xmlDefinition))
+      return false;
+  }
+
+  return true;
+}
+
+void CMediaImportSettingsBase::InitializeControls()
+{
+  GetSettingsManager()->RegisterSettingControl("toggle", this);
+  GetSettingsManager()->RegisterSettingControl("spinner", this);
+  GetSettingsManager()->RegisterSettingControl("edit", this);
+  GetSettingsManager()->RegisterSettingControl("button", this);
+  GetSettingsManager()->RegisterSettingControl("list", this);
+  GetSettingsManager()->RegisterSettingControl("slider", this);
+  GetSettingsManager()->RegisterSettingControl("range", this);
+  GetSettingsManager()->RegisterSettingControl("title", this);
+}
+
+void CMediaImportSettingsBase::InitializeConditions()
+{
+  // add simple conditions
+  for (const auto condition : m_simpleConditions)
+    GetSettingsManager()->AddCondition(condition);
+
+  // add more complex conditions
+  for (const auto condition : m_complexConditions)
+    GetSettingsManager()->AddDynamicCondition(condition.first, std::get<0>(condition.second),
+                                              std::get<1>(condition.second));
+}
diff --git a/xbmc/media/import/MediaImportSettingsBase.h b/xbmc/media/import/MediaImportSettingsBase.h
new file mode 100644
index 000000000000..57945be36512
--- /dev/null
+++ b/xbmc/media/import/MediaImportSettingsBase.h
@@ -0,0 +1,83 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "settings/SettingControl.h"
+#include "settings/SettingsBase.h"
+#include "settings/lib/SettingConditions.h"
+#include "settings/lib/SettingDefinitions.h"
+#include "utils/StaticLoggerBase.h"
+
+#include <set>
+#include <string>
+#include <tuple>
+
+class CSettingSection;
+class CSettingsManager;
+
+class CMediaImportSettingsBase : public CSettingsBase,
+                                 public CSettingControlCreator,
+                                 protected CStaticLoggerBase
+{
+public:
+  explicit CMediaImportSettingsBase(const std::string& settingValues = "");
+  CMediaImportSettingsBase(const CMediaImportSettingsBase& other);
+  virtual ~CMediaImportSettingsBase() = default;
+
+  CMediaImportSettingsBase& operator=(const CMediaImportSettingsBase& other);
+
+  bool operator==(const CMediaImportSettingsBase& other) const;
+  bool operator!=(const CMediaImportSettingsBase& other) const { return !(*this == other); }
+
+  // implementations of CSettingsBase
+  bool Load() override;
+  bool Save() override;
+
+  // specialization of CSettingsBase
+  void Unload() override;
+
+  bool HasDefinition(const std::string& settingDefinition) const;
+  void AddDefinition(const std::string& settingDefinition);
+
+  void AddSimpleCondition(const std::string& condition);
+  void AddComplexCondition(const std::string& name,
+                           const SettingConditionCheck& condition,
+                           void* data = nullptr);
+
+  void SetOptionsFiller(const std::string& settingId,
+                        IntegerSettingOptionsFiller optionsFiller,
+                        void* data = nullptr);
+  void SetOptionsFiller(const std::string& settingId,
+                        StringSettingOptionsFiller optionsFiller,
+                        void* data = nullptr);
+
+  std::string ToXml() const;
+
+protected:
+  // implementation of CSettingsBase
+  bool InitializeDefinitions() override;
+
+  // specializations of CSettingsBase
+  void InitializeControls() override;
+  void InitializeConditions() override;
+
+  // hide methods of CSettingsBase
+  using CSettingsBase::Initialize;
+  using CSettingsBase::SetLoaded;
+  using CSettingsBase::Uninitialize;
+
+private:
+  mutable std::string m_settingValues;
+  std::set<std::string> m_settingDefinitions;
+
+  std::set<std::string> m_simpleConditions;
+  std::map<std::string, std::tuple<SettingConditionCheck, void*>> m_complexConditions;
+};
+
+using MediaImportSettingsBasePtr = std::shared_ptr<CMediaImportSettingsBase>;
diff --git a/xbmc/media/import/MediaImportSource.cpp b/xbmc/media/import/MediaImportSource.cpp
new file mode 100644
index 000000000000..2ca290afc429
--- /dev/null
+++ b/xbmc/media/import/MediaImportSource.cpp
@@ -0,0 +1,75 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportSource.h"
+
+CMediaImportSource::CMediaImportSource(const std::string& identifier /* = "" */,
+                                       const std::string& basePath /* = "" */,
+                                       const std::string& friendlyName /* = "" */,
+                                       const std::string& iconUrl /* = "" */,
+                                       const MediaTypes& availableMediaTypes /* = MediaTypes() */,
+                                       const CDateTime& lastSynced /* = CDateTime() */,
+                                       const std::string& settingValues /* = "" */,
+                                       bool manuallyAdded /* = false */,
+                                       const std::string& importerId /* = "" */)
+  : m_identifier(identifier),
+    m_basePath(basePath),
+    m_friendlyName(friendlyName),
+    m_iconUrl(iconUrl),
+    m_availableMediaTypes(availableMediaTypes),
+    m_lastSynced(lastSynced),
+    m_manuallyAdded(manuallyAdded),
+    m_settings(std::make_shared<CMediaImportSettingsBase>(settingValues)),
+    m_importerId(importerId),
+    m_active(false),
+    m_ready(false)
+{
+}
+
+CMediaImportSource::CMediaImportSource(const CMediaImportSource& other)
+  : m_identifier(other.m_identifier),
+    m_basePath(other.m_basePath),
+    m_friendlyName(other.m_friendlyName),
+    m_iconUrl(other.m_iconUrl),
+    m_availableMediaTypes(other.m_availableMediaTypes),
+    m_lastSynced(other.m_lastSynced),
+    m_manuallyAdded(other.m_manuallyAdded),
+    m_settings(other.m_settings),
+    m_importerId(other.m_importerId),
+    m_active(other.m_active),
+    m_ready(other.m_ready)
+{
+}
+
+bool CMediaImportSource::operator==(const CMediaImportSource& other) const
+{
+  if (m_identifier.compare(other.m_identifier) != 0 || m_basePath.compare(other.m_basePath) != 0 ||
+      m_friendlyName.compare(other.m_friendlyName) != 0 ||
+      m_iconUrl.compare(other.m_iconUrl) != 0 ||
+      m_availableMediaTypes != other.m_availableMediaTypes ||
+      m_manuallyAdded != other.m_manuallyAdded || *m_settings != *other.m_settings)
+    return false;
+
+  return true;
+}
+
+CMediaImportSource CMediaImportSource::Clone() const
+{
+  CMediaImportSource clone(*this);
+
+  // deep-copy the settings
+  clone.m_settings = std::make_shared<CMediaImportSettingsBase>(*m_settings);
+
+  return clone;
+}
+
+std::ostream& operator<<(std::ostream& os, const CMediaImportSource& source)
+{
+  return os << "\"" << source.GetFriendlyName() << "\""
+            << " (" << source.GetIdentifier() << ")";
+}
diff --git a/xbmc/media/import/MediaImportSource.h b/xbmc/media/import/MediaImportSource.h
new file mode 100644
index 000000000000..43953dc8809f
--- /dev/null
+++ b/xbmc/media/import/MediaImportSource.h
@@ -0,0 +1,98 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "XBDateTime.h"
+#include "media/MediaType.h"
+#include "media/import/MediaImportSettingsBase.h"
+
+#include <memory>
+#include <ostream>
+#include <set>
+#include <string>
+
+using MediaImportSourceSettingsPtr = MediaImportSettingsBasePtr;
+using MediaImportSourceSettingsConstPtr = std::shared_ptr<const CMediaImportSettingsBase>;
+
+class CMediaImportSource
+{
+public:
+  explicit CMediaImportSource(const std::string& identifier = "",
+                              const std::string& basePath = "",
+                              const std::string& friendlyName = "",
+                              const std::string& iconUrl = "",
+                              const MediaTypes& availableMediaTypes = MediaTypes(),
+                              const CDateTime& lastSynced = CDateTime(),
+                              const std::string& settingValues = "",
+                              bool manuallyAdded = false,
+                              const std::string& importerId = "");
+  CMediaImportSource(const CMediaImportSource& other);
+
+  ~CMediaImportSource() = default;
+
+  bool operator==(const CMediaImportSource& other) const;
+  bool operator!=(const CMediaImportSource& other) const { return !(*this == other); }
+
+  CMediaImportSource Clone() const;
+
+  const std::string& GetIdentifier() const { return m_identifier; }
+  void SetIdentifier(const std::string& identifier) { m_identifier = identifier; }
+
+  const std::string& GetBasePath() const { return m_basePath; }
+  void SetBasePath(const std::string& basePath) { m_basePath = basePath; }
+
+  const std::string& GetFriendlyName() const { return m_friendlyName; }
+  void SetFriendlyName(const std::string& friendlyName) { m_friendlyName = friendlyName; }
+
+  const std::string& GetIconUrl() const { return m_iconUrl; }
+  void SetIconUrl(const std::string& iconUrl) { m_iconUrl = iconUrl; }
+
+  const MediaTypes& GetAvailableMediaTypes() const { return m_availableMediaTypes; }
+  void SetAvailableMediaTypes(const MediaTypes& mediaTypes) { m_availableMediaTypes = mediaTypes; }
+  bool IsMediaTypeAvailable(const MediaTypes::value_type& mediaType) const
+  {
+    return m_availableMediaTypes.find(mediaType) != m_availableMediaTypes.cend();
+  }
+
+  const CDateTime& GetLastSynced() const { return m_lastSynced; }
+  void SetLastSynced(const CDateTime& lastSynced) { m_lastSynced = lastSynced; }
+
+  bool IsManuallyAdded() const { return m_manuallyAdded; }
+  void SetManuallyAdded(bool manuallyAdded) { m_manuallyAdded = manuallyAdded; }
+
+  MediaImportSourceSettingsConstPtr Settings() const { return m_settings; }
+  MediaImportSourceSettingsPtr Settings() { return m_settings; }
+
+  const std::string& GetImporterId() const { return m_importerId; }
+  void SetImporterId(const std::string& importerId) { m_importerId = importerId; }
+
+  bool IsActive() const { return m_active; }
+  void SetActive(bool active) { m_active = active; }
+
+  bool IsReady() const { return m_ready; }
+  void SetReady(bool ready) { m_ready = ready; }
+
+  friend std::ostream& operator<<(std::ostream& os, const CMediaImportSource& source);
+
+private:
+  std::string m_identifier;
+  std::string m_basePath;
+  std::string m_friendlyName;
+  std::string m_iconUrl;
+  MediaTypes m_availableMediaTypes;
+  CDateTime m_lastSynced;
+  bool m_manuallyAdded;
+  MediaImportSourceSettingsPtr m_settings;
+  std::string m_importerId;
+
+  bool m_active;
+  bool m_ready;
+};
+
+using MediaImportSourcePtr = std::shared_ptr<CMediaImportSource>;

From 2cfe23f55e4f61a5e514177d917be49db7c08956 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 6 Apr 2014 16:14:34 +0200
Subject: [PATCH 20/88] [CFileItem] add Get/SetSource(), Get/SetImportPath()
 and IsImported()

---
 xbmc/FileItem.cpp | 13 +++++++++++++
 xbmc/FileItem.h   |  9 +++++++++
 2 files changed, 22 insertions(+)

diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index 489034c4cdea..053aa16a97e8 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -473,6 +473,8 @@ CFileItem& CFileItem::operator=(const CFileItem& item)
   m_specialSort = item.m_specialSort;
   m_bIsAlbum = item.m_bIsAlbum;
   m_doContentLookup = item.m_doContentLookup;
+  m_source = item.m_source;
+  m_importPath = item.m_importPath;
   return *this;
 }
 
@@ -512,6 +514,8 @@ void CFileItem::Reset()
   m_bSelected = false;
   m_bIsFolder = false;
 
+  m_source.clear();
+  m_importPath.clear();
   m_strDVDLabel.clear();
   m_strTitle.clear();
   m_strPath.clear();
@@ -600,6 +604,8 @@ void CFileItem::Archive(CArchive& ar)
       ar << 0;
 
     ar << m_enabled;
+    ar << m_source;
+    ar << m_importPath;
   }
   else
   {
@@ -645,6 +651,8 @@ void CFileItem::Archive(CArchive& ar)
       ar >> *GetGameInfoTag();
 
     ar >> m_enabled;
+    ar >> m_source;
+    ar >> m_importPath;
 
     SetInvalid();
   }
@@ -1316,6 +1324,11 @@ bool CFileItem::IsReadOnly() const
   return !CUtil::SupportsWriteFileOperations(m_strPath);
 }
 
+bool CFileItem::IsImported() const
+{
+  return !m_source.empty() && !m_importPath.empty();
+}
+
 void CFileItem::FillInDefaultIcon()
 {
   if (URIUtils::IsPVRGuideItem(m_strPath))
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index ba561539e5ca..dce970b55f14 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -252,6 +252,7 @@ class CFileItem :
   bool IsLiveTV() const;
   bool IsRSS() const;
   bool IsAndroidApp() const;
+  bool IsImported() const;
 
   void RemoveExtension();
   void CleanString();
@@ -527,6 +528,11 @@ class CFileItem :
    */
   void SetFromSong(const CSong &song);
 
+  const std::string& GetSource() const { return m_source; }
+  void SetSource(const std::string &source) { m_source = source; }
+  const std::string& GetImportPath() const { return m_importPath; }
+  void SetImportPath(const std::string &importPath) { m_importPath = importPath; }
+
   bool m_bIsShareOrDrive;    ///< is this a root share/drive
   int m_iDriveType;     ///< If \e m_bIsShareOrDrive is \e true, use to get the share type. Types see: CMediaSource::m_iDriveType
   CDateTime m_dateTime;             ///< file creation date & time
@@ -589,6 +595,9 @@ class CFileItem :
   bool m_bIsAlbum;
 
   CCueDocumentPtr m_cueDocument;
+
+  std::string m_source;
+  std::string m_importPath;
 };
 
 /*!

From 7d75d4bb6c6a64f7a6196ade919fe7a418ae409a Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sat, 18 Apr 2015 00:40:22 +0200
Subject: [PATCH 21/88] [videodb] extend CreateLinkIndex to support
 indices/tables without a name

---
 xbmc/video/VideoDatabase.cpp | 5 +++--
 xbmc/video/VideoDatabase.h   | 2 +-
 2 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index f53aff0d7890..b20c7eb6f821 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -195,9 +195,10 @@ void CVideoDatabase::CreateTables()
   m_pDS->exec("CREATE TABLE uniqueid (uniqueid_id INTEGER PRIMARY KEY, media_id INTEGER, media_type TEXT, value TEXT, type TEXT)");
 }
 
-void CVideoDatabase::CreateLinkIndex(const char *table)
+void CVideoDatabase::CreateLinkIndex(const char *table, bool createNameIndex /* = true */)
 {
-  m_pDS->exec(PrepareSQL("CREATE UNIQUE INDEX ix_%s_1 ON %s (name(255))", table, table));
+  if (createNameIndex)
+    m_pDS->exec(PrepareSQL("CREATE UNIQUE INDEX ix_%s_1 ON %s (name(255))", table, table));
   m_pDS->exec(PrepareSQL("CREATE UNIQUE INDEX ix_%s_link_1 ON %s_link (%s_id, media_type(20), media_id)", table, table, table));
   m_pDS->exec(PrepareSQL("CREATE UNIQUE INDEX ix_%s_link_2 ON %s_link (media_id, media_type(20), %s_id)", table, table, table));
   m_pDS->exec(PrepareSQL("CREATE INDEX ix_%s_link_3 ON %s_link (media_type(20))", table, table));
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index ee970c91f3c9..e6ceeb774500 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -975,7 +975,7 @@ class CVideoDatabase : public CDatabase
   void CreateTables() override;
   void CreateAnalytics() override;
   void UpdateTables(int version) override;
-  void CreateLinkIndex(const char *table);
+  void CreateLinkIndex(const char *table, bool createNameIndex = true);
   void CreateForeignLinkIndex(const char *table, const char *foreignkey);
 
   /*! \brief (Re)Create the generic database views for movies, tvshows,

From 29e10fcb3d432d59655ffaf10e148b228087f8f3 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 14 Dec 2014 23:51:24 +0100
Subject: [PATCH 22/88] [videodb] add source / import support

---
 xbmc/video/VideoDatabase.cpp | 856 ++++++++++++++++++++++++++++++++++-
 xbmc/video/VideoDatabase.h   | 118 ++++-
 2 files changed, 952 insertions(+), 22 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index b20c7eb6f821..79b52f0882f0 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -34,6 +34,8 @@
 #include "guilib/LocalizeStrings.h"
 #include "guilib/guiinfo/GUIInfoLabels.h"
 #include "interfaces/AnnouncementManager.h"
+#include "media/import/MediaImport.h"
+#include "media/import/MediaImportSource.h"
 #include "messaging/helpers/DialogOKHelper.h"
 #include "playlists/SmartPlayList.h"
 #include "profiles/ProfileManager.h"
@@ -60,6 +62,7 @@
 #include <map>
 #include <memory>
 #include <string>
+#include <utility>
 #include <vector>
 
 using namespace dbiplus;
@@ -127,6 +130,13 @@ void CVideoDatabase::CreateTables()
   CLog::Log(LOGINFO, "create files table");
   m_pDS->exec("CREATE TABLE files ( idFile integer primary key, idPath integer, strFilename text, playCount integer, lastPlayed text, dateAdded text)");
 
+  CLog::Log(LOGINFO, "create source table");
+  m_pDS->exec("CREATE TABLE source ( source_id integer primary key, identifier text NOT NULL, idPath integer NOT NULL, name text NOT NULL, media_types text NOT NULL, settings text, manually_added bool, importer_id text NOT NULL)");
+
+  CLog::Log(LOGINFO, "create import table");
+  m_pDS->exec("CREATE TABLE import ( import_id integer primary key, idPath integer NOT NULL, source_id integer NOT NULL, media_type text NOT NULL, recursive bool, last_sync text, settings text)");
+  m_pDS->exec("CREATE TABLE import_link ( import_id integer NOT NULL, media_id integer NOT NULL, media_type text NOT NULL, enabled bool NOT NULL DEFAULT 1)");
+
   CLog::Log(LOGINFO, "create tvshow table");
   columns = "CREATE TABLE tvshow ( idShow integer primary key";
 
@@ -232,6 +242,10 @@ void CVideoDatabase::CreateAnalytics()
   m_pDS->exec("CREATE INDEX ix_path2 ON path ( idParentPath )");
   m_pDS->exec("CREATE INDEX ix_files ON files ( idPath, strFilename(255) )");
 
+  m_pDS->exec("CREATE INDEX ix_source ON source ( identifier(255) )");
+  m_pDS->exec("CREATE INDEX ix_import_path ON import ( idPath )");
+  m_pDS->exec("CREATE INDEX ix_import_mediatype ON import ( media_type(255) )");
+
   m_pDS->exec("CREATE UNIQUE INDEX ix_movie_file_1 ON movie (idFile, idMovie)");
   m_pDS->exec("CREATE UNIQUE INDEX ix_movie_file_2 ON movie (idMovie, idFile)");
 
@@ -278,6 +292,7 @@ void CVideoDatabase::CreateAnalytics()
   CreateLinkIndex("studio");
   CreateLinkIndex("genre");
   CreateLinkIndex("country");
+  CreateLinkIndex("import", false);
 
   CLog::Log(LOGINFO, "%s - creating triggers", __FUNCTION__);
   m_pDS->exec("CREATE TRIGGER delete_movie AFTER DELETE ON movie FOR EACH ROW BEGIN "
@@ -292,6 +307,7 @@ void CVideoDatabase::CreateAnalytics()
               "DELETE FROM tag_link WHERE media_id=old.idMovie AND media_type='movie'; "
               "DELETE FROM rating WHERE media_id=old.idMovie AND media_type='movie'; "
               "DELETE FROM uniqueid WHERE media_id=old.idMovie AND media_type='movie'; "
+              "DELETE FROM import_link WHERE media_id=old.idMovie AND media_type='movie'; "
               "END");
   m_pDS->exec("CREATE TRIGGER delete_tvshow AFTER DELETE ON tvshow FOR EACH ROW BEGIN "
               "DELETE FROM actor_link WHERE media_id=old.idShow AND media_type='tvshow'; "
@@ -305,6 +321,7 @@ void CVideoDatabase::CreateAnalytics()
               "DELETE FROM tag_link WHERE media_id=old.idShow AND media_type='tvshow'; "
               "DELETE FROM rating WHERE media_id=old.idShow AND media_type='tvshow'; "
               "DELETE FROM uniqueid WHERE media_id=old.idShow AND media_type='tvshow'; "
+              "DELETE FROM import_link WHERE media_id=old.idShow AND media_type='tvshow'; "
               "END");
   m_pDS->exec("CREATE TRIGGER delete_musicvideo AFTER DELETE ON musicvideo FOR EACH ROW BEGIN "
               "DELETE FROM actor_link WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
@@ -313,6 +330,7 @@ void CVideoDatabase::CreateAnalytics()
               "DELETE FROM studio_link WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
               "DELETE FROM art WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
               "DELETE FROM tag_link WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
+              "DELETE FROM import_link WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
               "END");
   m_pDS->exec("CREATE TRIGGER delete_episode AFTER DELETE ON episode FOR EACH ROW BEGIN "
               "DELETE FROM actor_link WHERE media_id=old.idEpisode AND media_type='episode'; "
@@ -321,9 +339,11 @@ void CVideoDatabase::CreateAnalytics()
               "DELETE FROM art WHERE media_id=old.idEpisode AND media_type='episode'; "
               "DELETE FROM rating WHERE media_id=old.idEpisode AND media_type='episode'; "
               "DELETE FROM uniqueid WHERE media_id=old.idEpisode AND media_type='episode'; "
+              "DELETE FROM import_link WHERE media_id=old.idEpisode AND media_type='episode'; "
               "END");
   m_pDS->exec("CREATE TRIGGER delete_season AFTER DELETE ON seasons FOR EACH ROW BEGIN "
               "DELETE FROM art WHERE media_id=old.idSeason AND media_type='season'; "
+              "DELETE FROM import_link WHERE media_id=old.idSeason AND media_type='season'; "
               "END");
   m_pDS->exec("CREATE TRIGGER delete_set AFTER DELETE ON sets FOR EACH ROW BEGIN "
               "DELETE FROM art WHERE media_id=old.idSet AND media_type='set'; "
@@ -366,7 +386,12 @@ void CVideoDatabase::CreateViews()
                                       "  rating.votes AS votes, "
                                       "  rating.rating_type AS rating_type, "
                                       "  uniqueid.value AS uniqueid_value, "
-                                      "  uniqueid.type AS uniqueid_type "
+                                      "  uniqueid.type AS uniqueid_type,"
+                                      "  source.identifier AS strSource,"
+                                      "  import_link.enabled AS enabled,"
+                                      "  importsPath.strPath AS importPath,"
+                                      "  1 - LEAST(IFNULL(import_link.import_id, 0), 1) AS local," // 1 if the item is local, otherwise 0
+                                      "  LEAST(IFNULL(import_link.import_id, 0), 1) AS imported " // 1 if the item is imported, otherwise 0
                                       "FROM episode"
                                       "  JOIN files ON"
                                       "    files.idFile=episode.idFile"
@@ -381,7 +406,15 @@ void CVideoDatabase::CreateViews()
                                       "  LEFT JOIN rating ON"
                                       "    rating.rating_id=episode.c%02d"
                                       "  LEFT JOIN uniqueid ON"
-                                      "    uniqueid.uniqueid_id=episode.c%02d",
+                                      "    uniqueid.uniqueid_id=episode.c%02d"
+                                      "  LEFT JOIN import_link ON"
+                                      "    import_link.media_id = episode.idEpisode AND import_link.media_type = 'episode'"
+                                      "  LEFT JOIN import ON"
+                                      "    import.import_id = import_link.import_id"
+                                      "  LEFT JOIN source ON"
+                                      "    source.source_id = import.source_id"
+                                      "  LEFT JOIN path AS importsPath ON"
+                                      "    importsPath.idPath = import.idPath",
                                       VIDEODB_ID_TV_TITLE, VIDEODB_ID_TV_GENRE,
                                       VIDEODB_ID_TV_STUDIOS, VIDEODB_ID_TV_PREMIERED,
                                       VIDEODB_ID_TV_MPAA, VIDEODB_ID_EPISODE_RATING_ID,
@@ -429,18 +462,32 @@ void CVideoDatabase::CreateViews()
                                      "  rating.votes AS votes, "
                                      "  rating.rating_type AS rating_type, "
                                      "  uniqueid.value AS uniqueid_value, "
-                                     "  uniqueid.type AS uniqueid_type "
+                                     "  uniqueid.type AS uniqueid_type,"
+                                     "  source.identifier AS strSource,"
+                                     "  import_link.enabled AS enabled,"
+                                     "  importsPath.strPath AS importPath,"
+                                     "  LEAST(COUNT(DISTINCT(tvshowlinkpath_minview.idPath)) - COUNT(DISTINCT(import_link.import_id)), 1) as local," // 1 if the item is local, otherwise 0
+                                     "  LEAST(COUNT(DISTINCT(import_link.import_id)), 1) as imported " // 1 if the item is imported, otherwise 0
                                      "FROM tvshow"
                                      "  LEFT JOIN tvshowlinkpath_minview ON "
                                      "    tvshowlinkpath_minview.idShow=tvshow.idShow"
                                      "  LEFT JOIN path ON"
                                      "    path.idPath=tvshowlinkpath_minview.idPath"
                                      "  INNER JOIN tvshowcounts ON"
-                                     "    tvshow.idShow = tvshowcounts.idShow "
+                                     "    tvshow.idShow = tvshowcounts.idShow"
                                      "  LEFT JOIN rating ON"
                                      "    rating.rating_id=tvshow.c%02d "
                                      "  LEFT JOIN uniqueid ON"
-                                     "    uniqueid.uniqueid_id=tvshow.c%02d ",
+                                     "    uniqueid.uniqueid_id=tvshow.c%02d "
+                                     "  LEFT JOIN import_link ON"
+                                     "    import_link.media_id = tvshow.idShow AND import_link.media_type = 'tvshow'"
+                                     "  LEFT JOIN import ON"
+                                     "    import.import_id = import_link.import_id"
+                                     "  LEFT JOIN source ON"
+                                     "    source.source_id = import.source_id "
+                                     "  LEFT JOIN path AS importsPath ON"
+                                     "    importsPath.idPath = import.idPath "
+                                     "GROUP BY tvshow.idShow",
                                      VIDEODB_ID_TV_RATING_ID, VIDEODB_ID_TV_IDENT_ID);
   m_pDS->exec(tvshowview);
   
@@ -460,7 +507,12 @@ void CVideoDatabase::CreateViews()
                                      "  tvshow_view.c%02d AS mpaa,"
                                      "  count(DISTINCT episode.idEpisode) AS episodes,"
                                      "  count(files.playCount) AS playCount,"
-                                     "  min(episode.c%02d) AS aired "
+                                     "  min(episode.c%02d) AS aired, "
+                                     "  source.identifier AS strSource,"
+                                     "  import_link.enabled AS enabled,"
+                                     "  importsPath.strPath AS importPath,"
+                                     "  1 - LEAST(IFNULL(import_link.import_id, 0), 1) AS local," // 1 if the item is local, otherwise 0
+                                     "  LEAST(IFNULL(import_link.import_id, 0), 1) AS imported " // 1 if the item is imported, otherwise 0
                                      "FROM seasons"
                                      "  JOIN tvshow_view ON"
                                      "    tvshow_view.idShow = seasons.idShow"
@@ -468,6 +520,18 @@ void CVideoDatabase::CreateViews()
                                      "    episode.idShow = seasons.idShow AND episode.c%02d = seasons.season"
                                      "  LEFT JOIN files ON"
                                      "    files.idFile = episode.idFile "
+                                     "  JOIN tvshowlinkpath ON"
+                                     "    tvshowlinkpath.idShow = tvshow_view.idShow"
+                                     "  JOIN path ON"
+                                     "    path.idPath = tvshowlinkpath.idPath"
+                                     "  LEFT JOIN import_link ON"
+                                     "    import_link.media_id = seasons.idSeason AND import_link.media_type = 'season'"
+                                     "  LEFT JOIN import ON"
+                                     "    import.import_id = import_link.import_id"
+                                     "  LEFT JOIN source ON"
+                                     "    source.source_id = import.source_id"
+                                     "  LEFT JOIN path AS importsPath ON"
+                                     "    importsPath.idPath = import.idPath "
                                      "GROUP BY seasons.idSeason,"
                                      "         seasons.idShow,"
                                      "         seasons.season,"
@@ -497,17 +561,29 @@ void CVideoDatabase::CreateViews()
               "  files.dateAdded as dateAdded, "
               "  bookmark.timeInSeconds AS resumeTimeInSeconds, "
               "  bookmark.totalTimeInSeconds AS totalTimeInSeconds, "
-              "  bookmark.playerState AS playerState "
+              "  bookmark.playerState AS playerState, "
+              "  source.identifier AS strSource,"
+              "  import_link.enabled AS enabled,"
+              "  importsPath.strPath AS importPath,"
+              "  1 - LEAST(IFNULL(import_link.import_id, 0), 1) AS local," // 1 if the item is local, otherwise 0
+              "  LEAST(IFNULL(import_link.import_id, 0), 1) AS imported " // 1 if the item is imported, otherwise 0
               "FROM musicvideo"
               "  JOIN files ON"
               "    files.idFile=musicvideo.idFile"
               "  JOIN path ON"
               "    path.idPath=files.idPath"
               "  LEFT JOIN bookmark ON"
-              "    bookmark.idFile=musicvideo.idFile AND bookmark.type=1");
+              "    bookmark.idFile=musicvideo.idFile AND bookmark.type=1"
+              "  LEFT JOIN import_link ON"
+              "    import_link.media_id = musicvideo.idMVideo AND import_link.media_type = 'musicvideo'"
+              "  LEFT JOIN import ON"
+              "    import.import_id = import_link.import_id"
+              "  LEFT JOIN source ON"
+              "    source.source_id = import.source_id"
+              "  LEFT JOIN path AS importsPath ON"
+              "    importsPath.idPath = import.idPath");
 
   CLog::Log(LOGINFO, "create movie_view");
-
   std::string movieview = PrepareSQL("CREATE VIEW movie_view AS SELECT"
                                       "  movie.*,"
                                       "  sets.strSet AS strSet,"
@@ -524,7 +600,12 @@ void CVideoDatabase::CreateViews()
                                       "  rating.votes AS votes, "
                                       "  rating.rating_type AS rating_type, "
                                       "  uniqueid.value AS uniqueid_value, "
-                                      "  uniqueid.type AS uniqueid_type "
+                                      "  uniqueid.type AS uniqueid_type,"
+                                      "  source.identifier AS strSource,"
+                                      "  import_link.enabled AS enabled,"
+                                      "  importsPath.strPath AS importPath,"
+                                      "  1 - LEAST(IFNULL(import_link.import_id, 0), 1) AS local," // 1 if the item is local, otherwise 0
+                                      "  LEAST(IFNULL(import_link.import_id, 0), 1) AS imported " // 1 if the item is imported, otherwise 0
                                       "FROM movie"
                                       "  LEFT JOIN sets ON"
                                       "    sets.idSet = movie.idSet"
@@ -537,7 +618,15 @@ void CVideoDatabase::CreateViews()
                                       "  LEFT JOIN rating ON"
                                       "    rating.rating_id=movie.c%02d"
                                       "  LEFT JOIN uniqueid ON"
-                                      "    uniqueid.uniqueid_id=movie.c%02d",
+                                      "    uniqueid.uniqueid_id=movie.c%02d"
+                                      "  LEFT JOIN import_link ON"
+                                      "    import_link.media_id = movie.idMovie AND import_link.media_type = 'movie'"
+                                      "  LEFT JOIN import ON"
+                                      "    import.import_id = import_link.import_id"
+                                      "  LEFT JOIN source ON"
+                                      "    source.source_id = import.source_id"
+                                      "  LEFT JOIN path AS importsPath ON"
+                                      "    importsPath.idPath = import.idPath",
                                       VIDEODB_ID_RATING_ID, VIDEODB_ID_IDENT_ID);
   m_pDS->exec(movieview);
 }
@@ -663,7 +752,7 @@ bool CVideoDatabase::GetPathsLinkedToTvShow(int idShow, std::vector<std::string>
   }
   catch (...)
   {
-    CLog::Log(LOGERROR, "%s error during query: %s",__FUNCTION__, sql.c_str());
+    CLog::Log(LOGERROR, "%s error during query: %s", __FUNCTION__, sql.c_str());
   }
   return false;
 }
@@ -797,7 +886,7 @@ int CVideoDatabase::AddPath(const std::string& strPath, const std::string &paren
 
     std::string strPath1(strPath);
     if (URIUtils::IsStack(strPath) || StringUtils::StartsWithNoCase(strPath, "rar://") || StringUtils::StartsWithNoCase(strPath, "zip://"))
-      URIUtils::GetParentPath(strPath,strPath1);
+      URIUtils::GetParentPath(strPath, strPath1);
 
     URIUtils::AddSlashAtEnd(strPath1);
 
@@ -807,16 +896,16 @@ int CVideoDatabase::AddPath(const std::string& strPath, const std::string &paren
     if (idParentPath < 0)
     {
       if (dateAdded.IsValid())
-        strSQL=PrepareSQL("insert into path (idPath, strPath, dateAdded) values (NULL, '%s', '%s')", strPath1.c_str(), dateAdded.GetAsDBDateTime().c_str());
+        strSQL = PrepareSQL("insert into path (idPath, strPath, dateAdded) values (NULL, '%s', '%s')", strPath1.c_str(), dateAdded.GetAsDBDateTime().c_str());
       else
-        strSQL=PrepareSQL("insert into path (idPath, strPath) values (NULL, '%s')", strPath1.c_str());
+        strSQL = PrepareSQL("insert into path (idPath, strPath) values (NULL, '%s')", strPath1.c_str());
     }
     else
     {
       if (dateAdded.IsValid())
         strSQL = PrepareSQL("insert into path (idPath, strPath, dateAdded, idParentPath) values (NULL, '%s', '%s', %i)", strPath1.c_str(), dateAdded.GetAsDBDateTime().c_str(), idParentPath);
       else
-        strSQL=PrepareSQL("insert into path (idPath, strPath, idParentPath) values (NULL, '%s', %i)", strPath1.c_str(), idParentPath);
+        strSQL = PrepareSQL("insert into path (idPath, strPath, idParentPath) values (NULL, '%s', %i)", strPath1.c_str(), idParentPath);
     }
     m_pDS->exec(strSQL);
     idPath = (int)m_pDS->lastinsertid();
@@ -1182,6 +1271,87 @@ int CVideoDatabase::GetFileId(const CFileItem &item)
   return GetFileId(item.GetPath());
 }
 
+int CVideoDatabase::GetSourceId(const std::string& sourceIdentifier)
+{
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+        sourceIdentifier.empty())
+      return -1;
+
+
+    std::string strSQL = PrepareSQL("SELECT source_id FROM source WHERE identifier='%s'", sourceIdentifier.c_str());
+    m_pDS->query(strSQL.c_str());
+    if (m_pDS->num_rows() > 0)
+    {
+      int idSource = m_pDS->fv(0).get_asInt();
+      m_pDS->close();
+      return idSource;
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, sourceIdentifier.c_str());
+  }
+  return -1;
+}
+
+int CVideoDatabase::GetImportId(const std::string& path, const GroupedMediaTypes& mediaTypes, const std::string &sourceIdentifier /* = "" */)
+{
+  if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+      path.empty() || mediaTypes.empty())
+    return -1;
+    
+  int idPath = GetPathId(path);
+  if (idPath <= 0)
+    return -1;
+
+  int idSource = -1;
+  if (!sourceIdentifier.empty())
+  {
+    idSource = GetSourceId(sourceIdentifier);
+    if (idSource <= 0)
+      return -1;
+  }
+
+  return GetImportId(idPath, mediaTypes, idSource);
+}
+
+int CVideoDatabase::GetImportId(const CMediaImport& import)
+{
+  return GetImportId(import.GetPath(), import.GetMediaTypes(), import.GetSource().GetIdentifier());
+}
+
+int CVideoDatabase::GetImportId(int idPath, const GroupedMediaTypes& mediaTypes, int idSource /* = -1 */)
+{
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+        idPath <= 0)
+      return -1;
+
+    std::string strSQL = PrepareSQL("SELECT import_id FROM import WHERE idPath = %d AND media_type = '%s'", idPath, CMediaTypes::Join(mediaTypes).c_str());
+    if (idSource > 0)
+      strSQL += PrepareSQL(" AND source_id = %d", idSource);
+
+    m_pDS->query(strSQL.c_str());
+    if (m_pDS->num_rows() != 1)
+    {
+      m_pDS->close();
+      return -1;
+    }
+
+    int idImport = m_pDS->fv(0).get_asInt();
+    m_pDS->close();
+    return idImport;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%d, %s, %d) failed", __FUNCTION__, idPath, CMediaTypes::Join(mediaTypes).c_str(), idSource);
+  }
+  return -1;
+}
+
 //********************************************************************************************************************************
 int CVideoDatabase::GetMovieId(const std::string& strFilenameAndPath)
 {
@@ -2898,7 +3068,7 @@ int CVideoDatabase::SetDetailsForEpisode(const std::string& strFilenameAndPath,
       // only add a new episode if we don't already have a valid idEpisode
       // (DeleteEpisode is called with bKeepId == true so the episode won't
       // be removed from the episode table)
-      idEpisode = AddEpisode(idShow,strFilenameAndPath,details.m_dateAdded);
+      idEpisode = AddEpisode(idShow,strFilenameAndPath, details.m_dateAdded);
       if (idEpisode < 0)
       {
         RollbackTransaction();
@@ -4254,6 +4424,7 @@ CVideoInfoTag CVideoDatabase::GetDetailsForTvShow(const dbiplus::sql_record* con
 
   if (item != NULL)
   {
+    item->SetEnabled(record->at(VIDEODB_DETAILS_TVSHOW_ENABLED).get_asBool());
     item->m_dateTime = details.GetPremiered();
     item->SetProperty("totalseasons", details.m_iSeason);
     item->SetProperty("totalepisodes", details.m_iEpisode);
@@ -5563,7 +5734,6 @@ void CVideoDatabase::UpdateTables(int iVersion)
       }
     }
   }
-
   if (iVersion < 96)
   {
     m_pDS->exec("ALTER TABLE movie ADD userrating integer");
@@ -5798,11 +5968,18 @@ void CVideoDatabase::UpdateTables(int iVersion)
     }
     m_pDS->close();
   }
+
+  if (iVersion < 119)
+  {
+    m_pDS->exec("CREATE TABLE source (source_id integer primary key, identifier text NOT NULL, idPath integer NOT NULL, name text NOT NULL, media_types text NOT NULL, settings text, manually_added bool, importer_id text NOT NULL)");
+    m_pDS->exec("CREATE TABLE import (import_id integer primary key, idPath integer NOT NULL, source_id integer NOT NULL, media_type text NOT NULL, recursive bool, last_sync text, settings text)");
+    m_pDS->exec("CREATE TABLE import_link (import_id integer NOT NULL, media_id integer NOT NULL, media_type text NOT NULL, enabled bool NOT NULL DEFAULT 1)");
+  }
 }
 
 int CVideoDatabase::GetSchemaVersion() const
 {
-  return 118;
+  return 119;
 }
 
 bool CVideoDatabase::LookupByFolders(const std::string &path, bool shows)
@@ -7200,6 +7377,10 @@ bool CVideoDatabase::GetSeasonsByWhere(const std::string& strBaseDir, const Filt
         pItem->GetVideoInfoTag()->SetPlayCount((totalEpisodes == watchedEpisodes) ? 1 : 0);
         pItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, (pItem->GetVideoInfoTag()->GetPlayCount() > 0) && (pItem->GetVideoInfoTag()->m_iEpisode > 0));
 
+        pItem->SetSource(m_pDS->fv(VIDEODB_DETAILS_SEASON_SOURCE).get_asString());
+        pItem->SetImportPath(m_pDS->fv(VIDEODB_DETAILS_SEASON_IMPORTPATH).get_asString());
+        pItem->SetEnabled(m_pDS->fv(VIDEODB_DETAILS_SEASON_ENABLED).get_asBool());
+
         items.Add(pItem);
       }
 
@@ -7453,6 +7634,10 @@ bool CVideoDatabase::GetMoviesByWhere(const std::string& strBaseDir, const Filte
         pItem->SetPath(itemUrl.ToString());
         pItem->SetDynPath(movie.m_strFileNameAndPath);
 
+        pItem->SetSource(record->at(VIDEODB_DETAILS_MOVIE_SOURCE).get_asString());
+        pItem->SetImportPath(record->at(VIDEODB_DETAILS_MOVIE_IMPORTPATH).get_asString());
+
+        pItem->SetEnabled(record->at(VIDEODB_DETAILS_MOVIE_ENABLED).get_asBool());
         pItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED,movie.GetPlayCount() > 0);
         items.Add(pItem);
       }
@@ -7563,6 +7748,9 @@ bool CVideoDatabase::GetTvShowsByWhere(const std::string& strBaseDir, const Filt
         itemUrl.AppendPath(path);
         pItem->SetPath(itemUrl.ToString());
 
+        pItem->SetSource(record->at(VIDEODB_DETAILS_TVSHOW_SOURCE).get_asString());
+        pItem->SetImportPath(record->at(VIDEODB_DETAILS_TVSHOW_IMPORTPATH).get_asString());
+
         pItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, (pItem->GetVideoInfoTag()->GetPlayCount() > 0) && (pItem->GetVideoInfoTag()->m_iEpisode > 0));
         items.Add(pItem);
       }
@@ -7700,6 +7888,10 @@ bool CVideoDatabase::GetEpisodesByWhere(const std::string& strBaseDir, const Fil
         pItem->SetPath(itemUrl.ToString());
         pItem->SetDynPath(episode.m_strFileNameAndPath);
 
+        pItem->SetSource(record->at(VIDEODB_DETAILS_EPISODE_SOURCE).get_asString());
+        pItem->SetImportPath(record->at(VIDEODB_DETAILS_EPISODE_IMPORTPATH).get_asString());
+
+        pItem->SetEnabled(record->at(VIDEODB_DETAILS_EPISODE_ENABLED).get_asBool());
         pItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, episode.GetPlayCount() > 0);
         pItem->m_dateTime = episode.m_firstAired;
         items.Add(pItem);
@@ -8559,6 +8751,10 @@ bool CVideoDatabase::GetMusicVideosByWhere(const std::string &baseDir, const Fil
         itemUrl.AppendPath(path);
         item->SetPath(itemUrl.ToString());
 
+        item->SetSource(record->at(VIDEODB_DETAILS_MUSICVIDEO_SOURCE).get_asString());
+        item->SetImportPath(record->at(VIDEODB_DETAILS_MUSICVIDEO_IMPORTPATH).get_asString());
+
+        item->SetEnabled(record->at(VIDEODB_DETAILS_MUSICVIDEO_ENABLED).get_asBool());
         item->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, musicvideo.GetPlayCount() > 0);
         items.Add(item);
       }
@@ -9076,7 +9272,9 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const st
     BeginTransaction();
 
     // find all the files
-    std::string sql = "SELECT files.idFile, files.strFileName, path.strPath FROM files INNER JOIN path ON path.idPath=files.idPath";
+    std::string sql = "SELECT files.idFile, files.strFileName, path.strPath FROM files "
+                      "INNER JOIN path ON path.idPath = files.idPath "
+                      "WHERE NOT EXISTS (SELECT 1 FROM import WHERE import.idPath = path.idPath OR import.idPath = path.idParentPath)"; // ignore imported files/items
     if (!paths.empty())
     {
       std::string strPaths;
@@ -9468,6 +9666,8 @@ std::vector<int> CVideoDatabase::CleanMediaType(const std::string &mediaType, co
     sql += "JOIN tvshowlinkpath ON tvshowlinkpath.idShow = episode.idShow JOIN path AS showPath ON showPath.idPath=tvshowlinkpath.idPath ";
 
   sql += PrepareSQL("LEFT JOIN path as parentPath ON parentPath.idPath = %s "
+                    "LEFT JOIN import ON import.idPath = parentPath.idPath "
+                    "LEFT JOIN source ON source.source_id = import.source_id "
                     "WHERE %s.idFile IN (%s)",
                     parentPathIdField.c_str(),
                     table.c_str(), cleanableFileIDs.c_str());
@@ -10393,6 +10593,572 @@ bool CVideoDatabase::ImportArtFromXML(const TiXmlNode *node, std::map<std::strin
   return !artwork.empty();
 }
 
+std::vector<CMediaImportSource> CVideoDatabase::GetSources()
+{
+  std::vector<CMediaImportSource> sources;
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL)
+      return sources;
+
+    strSQL = PrepareSQL("SELECT source.*, path.strPath, art.url, MAX(import.last_sync) AS last_sync FROM source "
+      "LEFT JOIN path ON path.idPath = source.idPath "
+      "LEFT JOIN art ON art.media_type = 'source' AND art.media_id = source.source_id "
+      "LEFT JOIN import ON import.source_id = source.source_id "
+      "GROUP BY source.source_id");
+    m_pDS->query(strSQL.c_str());
+    while (!m_pDS->eof())
+    {
+      std::vector<MediaType> vecMediaTypes;
+      std::string strMediaTypes = m_pDS->fv(4).get_asString();
+      if (!strMediaTypes.empty())
+        vecMediaTypes = StringUtils::Split(strMediaTypes, ",");
+      MediaTypes media_types(vecMediaTypes.begin(), vecMediaTypes.end());
+      CDateTime lastSynced; lastSynced.SetFromDBDateTime(m_pDS->fv(10).get_asString());
+      sources.emplace_back(
+        m_pDS->fv(1).get_asString(), m_pDS->fv(8).get_asString(), m_pDS->fv(3).get_asString(),
+        m_pDS->fv(9).get_asString(), media_types, lastSynced, m_pDS->fv(5).get_asString(),
+        m_pDS->fv(6).get_asBool(), m_pDS->fv(7).get_asString());
+
+      m_pDS->next();
+    }
+    m_pDS->close();
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to GetSources (%s)", __FUNCTION__, strSQL.c_str());
+  }
+  return sources;
+}
+
+int CVideoDatabase::AddSource(const CMediaImportSource &source)
+{
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+      source.GetIdentifier().empty() || source.GetFriendlyName().empty())
+      return -1;
+
+    strSQL = PrepareSQL("SELECT source_id FROM source WHERE identifier='%s'", source.GetIdentifier().c_str());
+
+    m_pDS->query(strSQL.c_str());
+    if (m_pDS->num_rows() > 0)
+    {
+      int idSource = m_pDS->fv(0).get_asInt();
+      m_pDS->close();
+
+      return idSource;
+    }
+    m_pDS->close();
+
+    // make sure the necessary path exists
+    int idPath = GetPathId(source.GetBasePath());
+    if (idPath <= 0)
+    {
+      idPath = AddPath(source.GetBasePath());
+      if (idPath <= 0)
+        return -1;
+    }
+    
+    std::vector<MediaType> vecmedia_types(source.GetAvailableMediaTypes().begin(), source.GetAvailableMediaTypes().end());
+    strSQL = PrepareSQL(
+      "INSERT INTO source (source_id, identifier, idPath, name, media_types, settings, manually_added, importer_id) "
+      "values(NULL, '%s', %d, '%s', '%s', '%s', %d, '%s')",
+      source.GetIdentifier().c_str(), idPath, source.GetFriendlyName().c_str(),
+      StringUtils::Join(vecmedia_types, ",").c_str(), source.Settings()->ToXml().c_str(),
+      source.IsManuallyAdded() ? 1 : 0, source.GetImporterId().c_str());
+    m_pDS->exec(strSQL.c_str());
+
+    int idSource = (int)m_pDS->lastinsertid();
+    if (idSource > 0 && !source.GetIconUrl().empty())
+      SetArtForItem(idSource, "source", "thumb", source.GetIconUrl());
+
+    return idSource;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to AddSource (%s)", __FUNCTION__, strSQL.c_str());
+  }
+  return -1;
+}
+
+bool CVideoDatabase::SetDetailsForSource(const CMediaImportSource &source)
+{
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+        source.GetIdentifier().empty() || source.GetFriendlyName().empty())
+      return false;
+
+    strSQL = PrepareSQL("SELECT source_id FROM source WHERE identifier='%s'", source.GetIdentifier().c_str());
+
+    m_pDS->query(strSQL.c_str());
+    if (m_pDS->num_rows() != 1)
+    {
+      m_pDS->close();
+      return false;
+    }
+
+    int idSource = m_pDS->fv(0).get_asInt();
+    m_pDS->close();
+
+    // make sure the necessary path exists
+    int idPath = GetPathId(source.GetBasePath());
+    if (idPath <= 0)
+    {
+      idPath = AddPath(source.GetBasePath());
+      if (idPath <= 0)
+        return false;
+    }
+    
+    std::vector<MediaType> vecmedia_types(source.GetAvailableMediaTypes().begin(), source.GetAvailableMediaTypes().end());
+    strSQL = PrepareSQL(
+      "UPDATE source SET idPath=%d, name='%s', media_types='%s', settings='%s', manually_added=%d, importer_id='%s' WHERE source_id=%d",
+      idPath, source.GetFriendlyName().c_str(), StringUtils::Join(vecmedia_types, ",").c_str(),
+      source.Settings()->ToXml().c_str(), source.IsManuallyAdded() ? 1 : 0, source.GetImporterId().c_str(), idSource);
+    m_pDS->exec(strSQL.c_str());
+
+    std::string oldIcon = GetArtForItem(idSource, "source", "thumb");
+    if (source.GetIconUrl().compare(oldIcon) != 0)
+      SetArtForItem(idSource, "source", "thumb", source.GetIconUrl());
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to SetDetailsForSource (%s)", __FUNCTION__, strSQL.c_str());
+  }
+  return false;
+}
+
+void CVideoDatabase::RemoveSource(const std::string& sourceIdentifier)
+{
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+        sourceIdentifier.empty())
+      return;
+
+    BeginTransaction();
+
+    int idSource = GetSourceId(sourceIdentifier);
+    if (idSource <= 0)
+    {
+      RollbackTransaction();
+      return;
+    }
+
+    bool success = true;
+    std::vector<CMediaImport> imports = GetImports();
+    for (std::vector<CMediaImport>::const_iterator itImport = imports.begin(); itImport != imports.end(); ++itImport)
+    {
+      if (itImport->GetSource().GetIdentifier() == sourceIdentifier)
+      {
+        if (!RemoveImport(*itImport, false))
+        {
+          success = false;
+          break;
+        }
+      }
+    }
+
+    if (success)
+    {
+      // delete source, import and media item paths
+      strSQL = PrepareSQL("DELETE FROM path WHERE EXISTS "
+        "(SELECT 1 FROM path AS sourcePath "
+        "JOIN source ON sourcePath.idPath = source.idPath "
+        "WHERE sourcePath.idPath = path.idPath AND source.source_id = %d)",
+        idSource);
+      m_pDS->exec(strSQL);
+
+      // delete source
+      strSQL = PrepareSQL("DELETE FROM source WHERE source_id = %d", idSource);
+      m_pDS->exec(strSQL);
+
+      CommitTransaction();
+
+      Compress(false);
+      CUtil::DeleteVideoDatabaseDirectoryCache();
+    }
+    else
+      RollbackTransaction();
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, strSQL.c_str());
+    RollbackTransaction();
+  }
+}
+
+std::vector<CMediaImport> CVideoDatabase::GetImports()
+{
+  std::vector<CMediaImport> imports;
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL)
+      return imports;
+
+    strSQL = PrepareSQL("SELECT path.strPath, source.identifier, import.media_type, import.recursive, import.last_sync, import.settings, sourcePath.strPath FROM import "
+                        "JOIN path ON path.idPath = import.idPath "
+                        "JOIN source ON source.source_id = import.source_id "
+                        "LEFT JOIN path AS sourcePath ON source.idPath = sourcePath.idPath");
+    m_pDS->query(strSQL.c_str());
+    while (!m_pDS->eof())
+    {
+      const auto importPath = m_pDS->fv(0).get_asString();
+      const auto sourceId = m_pDS->fv(1).get_asString();
+      const auto mediaTypes = CMediaTypes::Split(m_pDS->fv(2).get_asString());
+      CDateTime lastSynced = CDateTime::FromDBDateTime(m_pDS->fv(4).get_asString());
+      const auto settings = m_pDS->fv(5).get_asString();
+      const auto sourceBasePath = m_pDS->fv(6).get_asString();
+      CMediaImport import;
+      if (m_pDS->fv(3).get_asBool())
+        import = CMediaImport::CreateRecursive(importPath, mediaTypes, CMediaImportSource(sourceId, sourceBasePath), lastSynced, settings);
+      else
+        import = CMediaImport::CreateSelective(importPath, mediaTypes, CMediaImportSource(sourceId, sourceBasePath), lastSynced, settings);
+      imports.push_back(import);
+
+      m_pDS->next();
+    }
+    m_pDS->close();
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to GetImports (%s)", __FUNCTION__, strSQL.c_str());
+  }
+  return imports;
+}
+
+int CVideoDatabase::AddImport(const CMediaImport &import)
+{
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+        import.GetPath().empty() || import.GetSource().GetIdentifier().empty() ||
+        import.GetMediaTypes().empty())
+      return -1;
+
+    // check if the necessary source exists
+    int idSource = GetSourceId(import.GetSource().GetIdentifier());
+    if (idSource <= 0)
+      return -1;
+
+    // make sure the necessary path exists
+    int idPath = GetPathId(import.GetPath());
+    if (idPath <= 0)
+    {
+      idPath = AddPath(import.GetPath(), import.GetSource().GetBasePath());
+      if (idPath <= 0)
+        return -1;
+    }
+
+    int idImport = GetImportId(idPath, import.GetMediaTypes(), idSource);
+    if (idImport > 0)
+      return idImport;
+    
+    strSQL = PrepareSQL("INSERT INTO import (import_id, idPath, source_id, media_type, recursive, settings) values(NULL, %d, %d, '%s', %d, '%s')",
+      idPath, idSource, CMediaTypes::Join(import.GetMediaTypes()).c_str(), import.IsRecursive() ? 1 : 0, import.Settings()->ToXml().c_str());
+    m_pDS->exec(strSQL.c_str());
+
+    return (int)m_pDS->lastinsertid();
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to AddImport (%s)", __FUNCTION__, strSQL.c_str());
+  }
+  return -1;
+}
+
+bool CVideoDatabase::SetDetailsForImport(const CMediaImport &import)
+{
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+        import.GetPath().empty() || import.GetSource().GetIdentifier().empty() ||
+        import.GetMediaTypes().empty())
+      return false;
+
+    int idImport = GetImportId(import);
+    if (idImport <= 0)
+      return false;
+    
+    strSQL = PrepareSQL("UPDATE import SET media_type = '%s', recursive = %d, last_sync = '%s', settings='%s' WHERE import_id = %d",
+      CMediaTypes::Join(import.GetMediaTypes()).c_str(), import.IsRecursive() ? 1 : 0,
+      import.GetLastSynced().GetAsDBDateTime().c_str(), import.Settings()->ToXml().c_str(), idImport);
+    m_pDS->exec(strSQL.c_str());
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to SetDetailsForImport (%s)", __FUNCTION__, strSQL.c_str());
+  }
+  return false;
+}
+
+void CVideoDatabase::UpdateImportLastSynced(const CMediaImport &import, const CDateTime &lastSynced /* = CDateTime() */)
+{
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL ||
+        import.GetPath().empty() ||
+        import.GetMediaTypes().empty())
+      return;
+
+    int idImport = GetImportId(import);
+    if (idImport <= 0)
+      return;
+
+    CDateTime syncDate = lastSynced;
+    if (!syncDate.IsValid())
+      syncDate = CDateTime::GetCurrentDateTime();
+
+    strSQL = PrepareSQL("UPDATE import SET last_sync = '%s' WHERE import_id = %d", syncDate.GetAsDBDateTime().c_str(), idImport);
+    m_pDS->exec(strSQL);
+    m_pDS->close();
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to UpdateImportLastSynced (%s)", __FUNCTION__, strSQL.c_str());
+  }
+}
+
+bool CVideoDatabase::RemoveImport(const CMediaImport &import, bool standalone /* = true */)
+{
+  if (import.GetPath().empty() ||
+      import.GetMediaTypes().empty())
+    return false;
+
+  bool result = false;
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL || m_pDS2.get() == NULL)
+      return false;
+
+    if (standalone)
+      BeginTransaction();
+
+    int idImport = GetImportId(import);
+    if (idImport <= 0)
+    {
+      if (standalone)
+        RollbackTransaction();
+      return false;
+    }
+    
+    // delete source, import and media item paths
+    strSQL = PrepareSQL("DELETE FROM path WHERE EXISTS "
+                        "(SELECT 1 FROM path AS importPath "
+                         "JOIN import ON importPath.idPath = import.idPath "
+                         "WHERE importPath.idPath = path.idPath AND import.import_id = %d AND "
+                         "NOT EXISTS(SELECT 1 FROM import WHERE import.import_id != %d AND import.idPath = importPath.idPath))",
+                        idImport, idImport);
+    m_pDS->exec(strSQL);
+
+    // delete import
+    strSQL = PrepareSQL("DELETE FROM import WHERE import_id = %d", idImport);
+    m_pDS->exec(strSQL);
+
+    if (standalone)
+    {
+      CommitTransaction();
+
+      Compress(false);
+      CUtil::DeleteVideoDatabaseDirectoryCache();
+    }
+    result = true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, strSQL.c_str());
+    if (standalone)
+      RollbackTransaction();
+    result = false;
+  }
+
+  return result;
+}
+
+bool CVideoDatabase::SetImportForItem(int idMedia, const MediaType& mediaType, const CMediaImport &import)
+{
+  if (idMedia <= 0 ||
+      mediaType.empty())
+    return false;
+
+  std::string sql = "";
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL)
+      return false;
+
+    int idImport = GetImportId(import);
+    if (idImport <= 0)
+      return false;
+
+    sql = PrepareSQL("SELECT 1 FROM import_link WHERE import_id = %d AND media_id = %d AND media_type = '%s'",
+      idImport, idMedia, mediaType.c_str());
+    m_pDS->query(sql.c_str());
+    if (m_pDS->num_rows() > 0)
+      return true;
+
+    sql = PrepareSQL("INSERT INTO import_link (import_id, media_id, media_type) VALUES (%d, %d, '%s')",
+      idImport, idMedia, mediaType.c_str());
+    m_pDS->exec(sql.c_str());
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, sql.c_str());
+  }
+  return false;
+}
+
+bool CVideoDatabase::RemoveImportFromItem(int idMedia, const MediaType& mediaType, const CMediaImport& import)
+{
+  if (idMedia <= 0 ||
+      mediaType.empty())
+    return false;
+
+  std::string sql = "";
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL)
+      return false;
+
+    int idImport = GetImportId(import);
+    if (idImport <= 0)
+      return false;
+
+    sql = PrepareSQL("DELETE FROM import_link WHERE import_id = %d AND media_id = %d AND media_type = '%s'",
+      idImport, idMedia, mediaType.c_str());
+    m_pDS->exec(sql.c_str());
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, sql.c_str());
+  }
+  return false;
+}
+
+bool CVideoDatabase::DeleteItemsFromImport(const CMediaImport& import)
+{
+  if (import.GetPath().empty() ||
+      import.GetMediaTypes().empty())
+    return false;
+
+  std::string sql = "";
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL)
+      return false;
+
+    // get the import's ID
+    int idImport = GetImportId(import);
+    if (idImport <= 0)
+      return false;
+
+    for (const auto& mediaType : import.GetMediaTypes())
+    {
+      std::string table = mediaType;
+      std::string idColumn;
+      if (CMediaTypes::IsMediaType(mediaType, MediaTypeMovie))
+        idColumn = "idMovie";
+      else if (CMediaTypes::IsMediaType(mediaType, MediaTypeEpisode))
+        idColumn = "idEpisode";
+      else if (CMediaTypes::IsMediaType(mediaType, MediaTypeMusicVideo))
+        idColumn = "idMVideo";
+      else
+        continue;
+
+      // remove all paths belonging to the imported items being deleted
+      sql = PrepareSQL("DELETE FROM path WHERE "
+                        "EXISTS (SELECT 1 FROM files "
+                                "JOIN %s ON %s.idFile = files.idFile "
+                                "JOIN import_link ON import_link.media_id = %s.%s AND import_link.media_type = '%s' "
+                                "WHERE files.idPath = path.idPath AND import_link.import_id = %d)",
+                      table.c_str(), table.c_str(), table.c_str(), idColumn.c_str(), mediaType.c_str(), idImport);
+      m_pDS->exec(sql.c_str());
+
+      // remove all files belonging to the imported items being deleted
+      sql = PrepareSQL("DELETE FROM files WHERE "
+                        "EXISTS (SELECT 1 FROM %s "
+                                "JOIN import_link ON import_link.media_id = %s.%s AND import_link.media_type = '%s' "
+                                "WHERE %s.idFile = files.idFile AND import_link.import_id = %d)",
+                                table.c_str(), table.c_str(), idColumn.c_str(), mediaType.c_str(), table.c_str(), idImport);
+      m_pDS->exec(sql.c_str());
+
+      // remove the actual items
+      sql = PrepareSQL("DELETE FROM %s WHERE "
+                        "EXISTS (SELECT 1 FROM import_link WHERE import_link.media_id = %s.%s AND import_link.media_type = '%s' AND import_link.import_id = %d)",
+                        table.c_str(), table.c_str(), idColumn.c_str(), mediaType.c_str(), idImport);
+      m_pDS->exec(sql.c_str());
+    }
+
+    // remove any remaining import links
+    sql = PrepareSQL("DELETE FROM import_link WHERE import_id = %d", idImport);
+    m_pDS->exec(sql.c_str());
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, sql.c_str());
+  }
+  return false;
+}
+
+void CVideoDatabase::SetImportItemsEnabled(bool enabled)
+{
+  std::string sql;
+  try
+  {
+    if (NULL == m_pDB.get() || NULL == m_pDS.get())
+      return;
+
+    sql = PrepareSQL("UPDATE import_link SET enabled = %d WHERE import_link.import_id IS NOT NULL", enabled ? 1 : 0);
+    m_pDS->exec(sql.c_str());
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, sql.c_str());
+  }
+}
+
+void CVideoDatabase::SetImportItemsEnabled(bool enabled, const MediaType& mediaType, const CMediaImport &import)
+{
+  std::string sql;
+  try
+  {
+    if (NULL == m_pDB.get() || NULL == m_pDS.get())
+      return;
+
+    int idImport = GetImportId(import);
+    if (idImport <= 0)
+      return;
+
+    sql = PrepareSQL("UPDATE import_link SET enabled = %d WHERE import_link.import_id = %d", enabled ? 1 : 0, idImport);
+    if (!mediaType.empty())
+      sql += PrepareSQL(" AND import_link.media_type = '%s'", mediaType.c_str());
+
+    m_pDS->exec(sql.c_str());
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, sql.c_str());
+  }
+}
+
 void CVideoDatabase::ConstructPath(std::string& strDest, const std::string& strPath, const std::string& strFileName)
 {
   if (URIUtils::IsStack(strFileName) ||
@@ -10661,6 +11427,14 @@ bool CVideoDatabase::GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription
 
     AppendIdLinkFilter("tag", "tag", "movie", "movie", "idMovie", options, filter);
     AppendLinkFilter("tag", "tag", "movie", "movie", "idMovie", options, filter);
+
+    option = options.find("source");
+    if (option != options.end())
+      filter.AppendWhere(PrepareSQL("movie_view.strSource = '%s'", option->second.asString().c_str()));
+
+    option = options.find("import");
+    if (option != options.end())
+      filter.AppendWhere(PrepareSQL("movie_view.importPath = '%s'", option->second.asString().c_str()));
   }
   else if (type == "tvshows")
   {
@@ -10683,6 +11457,14 @@ bool CVideoDatabase::GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription
 
       AppendIdLinkFilter("tag", "tag", "tvshow", "tvshow", "idShow", options, filter);
       AppendLinkFilter("tag", "tag", "tvshow", "tvshow", "idShow", options, filter);
+
+      option = options.find("source");
+      if (option != options.end())
+        filter.AppendWhere(PrepareSQL("tvshow_view.strSource = '%s'", option->second.asString().c_str()));
+
+      option = options.find("import");
+      if (option != options.end())
+        filter.AppendWhere(PrepareSQL("tvshow_view.importPath = '%s'", option->second.asString().c_str()));
     }
     else if (itemType == "seasons")
     {
@@ -10704,6 +11486,14 @@ bool CVideoDatabase::GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription
       option = options.find("showempty");
       if (option == options.end() || !option->second.asBoolean())
         filter.AppendWhere(PrepareSQL("season_view.episodes > 0"));
+
+      option = options.find("source");
+      if (option != options.end())
+        filter.AppendWhere(PrepareSQL("season_view.strSource = '%s'", option->second.asString().c_str()));
+
+      option = options.find("import");
+      if (option != options.end())
+        filter.AppendWhere(PrepareSQL("season_view.importPath = '%s'", option->second.asString().c_str()));
     }
     else if (itemType == "episodes")
     {
@@ -10758,6 +11548,14 @@ bool CVideoDatabase::GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription
         AppendIdLinkFilter("director", "actor", "episode", "episode", "idEpisode", options, filter);
         AppendLinkFilter("director", "actor", "episode", "episode", "idEpisode", options, filter);
       }
+
+      option = options.find("source");
+      if (option != options.end())
+        filter.AppendWhere(PrepareSQL("episode_view.strSource = '%s'", option->second.asString().c_str()));
+
+      option = options.find("import");
+      if (option != options.end())
+        filter.AppendWhere(PrepareSQL("episode_view.importPath = '%s'", option->second.asString().c_str()));
     }
   }
   else if (type == "musicvideos")
@@ -10800,11 +11598,27 @@ bool CVideoDatabase::GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription
 
     AppendIdLinkFilter("tag", "tag", "musicvideo", "musicvideo", "idMVideo", options, filter);
     AppendLinkFilter("tag", "tag", "musicvideo", "musicvideo", "idMVideo", options, filter);
+
+    option = options.find("source");
+    if (option != options.end())
+      filter.AppendWhere(PrepareSQL("musicvideo_view.strSource = '%s'", option->second.asString().c_str()));
+
+    option = options.find("import");
+    if (option != options.end())
+      filter.AppendWhere(PrepareSQL("musicvideo_view.importPath = '%s'", option->second.asString().c_str()));
   }
   else
     return false;
 
-  auto option = options.find("xsp");
+  auto option = options.find("local");
+  if (option != options.end())
+    filter.AppendWhere("local > 0");
+
+  option = options.find("imported");
+  if (option != options.end())
+    filter.AppendWhere("imported > 0");
+
+  option = options.find("xsp");
   if (option != options.end())
   {
     CSmartPlaylist xsp;
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index e6ceeb774500..37dec583edd6 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -25,6 +25,8 @@ class CFileItemList;
 class CVideoSettings;
 class CGUIDialogProgress;
 class CGUIDialogProgressBarHandle;
+class CMediaImport;
+class CMediaImportSource;
 
 namespace dbiplus
 {
@@ -73,7 +75,7 @@ enum VideoDbDetails
 // these defines are based on how many columns we have and which column certain data is going to be in
 // when we do GetDetailsForMovie()
 #define VIDEODB_MAX_COLUMNS 24
-#define VIDEODB_DETAILS_FILEID      1
+#define VIDEODB_DETAILS_FILEID			1
 
 #define VIDEODB_DETAILS_MOVIE_SET_ID            VIDEODB_MAX_COLUMNS + 2
 #define VIDEODB_DETAILS_MOVIE_USER_RATING       VIDEODB_MAX_COLUMNS + 3
@@ -93,6 +95,9 @@ enum VideoDbDetails
 #define VIDEODB_DETAILS_MOVIE_RATING_TYPE       VIDEODB_MAX_COLUMNS + 17
 #define VIDEODB_DETAILS_MOVIE_UNIQUEID_VALUE    VIDEODB_MAX_COLUMNS + 18
 #define VIDEODB_DETAILS_MOVIE_UNIQUEID_TYPE     VIDEODB_MAX_COLUMNS + 19
+#define VIDEODB_DETAILS_MOVIE_SOURCE            VIDEODB_MAX_COLUMNS + 20
+#define VIDEODB_DETAILS_MOVIE_ENABLED           VIDEODB_MAX_COLUMNS + 21
+#define VIDEODB_DETAILS_MOVIE_IMPORTPATH        VIDEODB_MAX_COLUMNS + 22
 
 #define VIDEODB_DETAILS_EPISODE_TVSHOW_ID       VIDEODB_MAX_COLUMNS + 2
 #define VIDEODB_DETAILS_EPISODE_USER_RATING     VIDEODB_MAX_COLUMNS + 3
@@ -115,6 +120,9 @@ enum VideoDbDetails
 #define VIDEODB_DETAILS_EPISODE_RATING_TYPE     VIDEODB_MAX_COLUMNS + 20
 #define VIDEODB_DETAILS_EPISODE_UNIQUEID_VALUE  VIDEODB_MAX_COLUMNS + 21
 #define VIDEODB_DETAILS_EPISODE_UNIQUEID_TYPE   VIDEODB_MAX_COLUMNS + 22
+#define VIDEODB_DETAILS_EPISODE_SOURCE          VIDEODB_MAX_COLUMNS + 23
+#define VIDEODB_DETAILS_EPISODE_ENABLED         VIDEODB_MAX_COLUMNS + 24
+#define VIDEODB_DETAILS_EPISODE_IMPORTPATH      VIDEODB_MAX_COLUMNS + 25
 
 #define VIDEODB_DETAILS_TVSHOW_USER_RATING      VIDEODB_MAX_COLUMNS + 1
 #define VIDEODB_DETAILS_TVSHOW_DURATION         VIDEODB_MAX_COLUMNS + 2
@@ -130,6 +138,9 @@ enum VideoDbDetails
 #define VIDEODB_DETAILS_TVSHOW_RATING_TYPE      VIDEODB_MAX_COLUMNS + 12
 #define VIDEODB_DETAILS_TVSHOW_UNIQUEID_VALUE   VIDEODB_MAX_COLUMNS + 13
 #define VIDEODB_DETAILS_TVSHOW_UNIQUEID_TYPE    VIDEODB_MAX_COLUMNS + 14
+#define VIDEODB_DETAILS_TVSHOW_SOURCE           VIDEODB_MAX_COLUMNS + 15
+#define VIDEODB_DETAILS_TVSHOW_ENABLED          VIDEODB_MAX_COLUMNS + 16
+#define VIDEODB_DETAILS_TVSHOW_IMPORTPATH       VIDEODB_MAX_COLUMNS + 17
 
 #define VIDEODB_DETAILS_MUSICVIDEO_USER_RATING  VIDEODB_MAX_COLUMNS + 2
 #define VIDEODB_DETAILS_MUSICVIDEO_PREMIERED    VIDEODB_MAX_COLUMNS + 3
@@ -141,6 +152,9 @@ enum VideoDbDetails
 #define VIDEODB_DETAILS_MUSICVIDEO_RESUME_TIME  VIDEODB_MAX_COLUMNS + 9
 #define VIDEODB_DETAILS_MUSICVIDEO_TOTAL_TIME   VIDEODB_MAX_COLUMNS + 10
 #define VIDEODB_DETAILS_MUSICVIDEO_PLAYER_STATE VIDEODB_MAX_COLUMNS + 11
+#define VIDEODB_DETAILS_MUSICVIDEO_SOURCE       VIDEODB_MAX_COLUMNS + 12
+#define VIDEODB_DETAILS_MUSICVIDEO_ENABLED      VIDEODB_MAX_COLUMNS + 13
+#define VIDEODB_DETAILS_MUSICVIDEO_IMPORTPATH   VIDEODB_MAX_COLUMNS + 14
 
 #define VIDEODB_TYPE_UNUSED 0
 #define VIDEODB_TYPE_STRING 1
@@ -290,6 +304,10 @@ typedef enum // this enum MUST match the offset struct further down!! and make s
   VIDEODB_ID_SEASON_MAX
 } VIDEODB_SEASON_IDS;
 
+#define VIDEODB_DETAILS_SEASON_SOURCE           VIDEODB_ID_SEASON_MAX + 0
+#define VIDEODB_DETAILS_SEASON_ENABLED          VIDEODB_ID_SEASON_MAX + 1
+#define VIDEODB_DETAILS_SEASON_IMPORTPATH       VIDEODB_ID_SEASON_MAX + 2
+
 typedef enum // this enum MUST match the offset struct further down!! and make sure to keep min and max at -1 and sizeof(offsets)
 {
   VIDEODB_ID_EPISODE_MIN = -1,
@@ -783,6 +801,88 @@ class CVideoDatabase : public CDatabase
    */
   int AddPath(const std::string& strPath, const std::string &parentPath = "", const CDateTime& dateAdded = CDateTime());
 
+  std::vector<CMediaImportSource> GetSources();
+
+  /*! \brief Add a source to the database, if necessary
+   If the identifier is already in the database, we simply return its id.
+   \param source Source to be added
+   \return id of the source, -1 if it could not be added.
+   */
+  int AddSource(const CMediaImportSource &source);
+
+  /*! \brief Updates the values of the given source.
+   \param source Source with updated values
+   \return True if the update was successful, false otherwise
+   */
+  bool SetDetailsForSource(const CMediaImportSource &source);
+
+  /*! \brief sets the given media types for the source with the given identifier
+   \param sourceIDentifier identifier of the source
+   \param mediaTypes Media types to be set
+   */
+  void SetMediaTypesForSource(const std::string& sourceIdentifier, const MediaTypes &mediaTypes);
+
+  /*! \brief Remove source with the given identifier from the database
+   \param sourceIdentifier identifier of the source
+   */
+  void RemoveSource(const std::string& sourceIdentifier);
+
+  std::vector<CMediaImport> GetImports();
+
+  /*! \brief Add an import to the database, if necessary
+   If the import is already in the database, we simply return its id.
+   \param import Import to be added
+   \return id of the import, -1 if it could not be added.
+   */
+  int AddImport(const CMediaImport &import);
+
+  /*! \brief Updates the values of the given import.
+   \param import Import with updated values
+   \return True if the update was successful, false otherwise
+   */
+  bool SetDetailsForImport(const CMediaImport &import);
+
+  /*! \brief Update last synced date of the import with the given path
+   \param sourceIDentifier identifier of the source
+   */
+  void UpdateImportLastSynced(const CMediaImport& import, const CDateTime &lastSynced = CDateTime());
+
+  /*! \brief Remove the import with the given path from the database
+   \param path Path of the import
+   */
+  bool RemoveImport(const CMediaImport& import, bool standalone = true);
+
+  /*! \brief Set the import of an item
+   \param idMedia Database ID of the item belonging to the given import
+   \param mediaType Media type of the item
+   \param import Import the given item belongs to
+   */
+  bool SetImportForItem(int idMedia, const MediaType& mediaType, const CMediaImport& import);
+
+  /*! \brief Remove the import from an item
+   \param idMedia Database ID of the item belonging to the given import
+   \param mediaType Media type of the item
+   \param import Import the given item belonged to
+  */
+  bool RemoveImportFromItem(int idMedia, const MediaType& mediaType, const CMediaImport& import);
+
+  /*! \brief Deletes all items from the given import
+   \param import Import from which all items are deleted
+   */
+  bool DeleteItemsFromImport(const CMediaImport& import);
+  
+  /*! \brief Enable/Disable all import items from the given import path
+   \param enabled Whether to enable or disable the items
+   */
+  void SetImportItemsEnabled(bool enabled);
+  
+  /*! \brief Enable/Disable all import items from the given import path
+   \param enabled Whether to enable or disable the items
+   \param mediaType Media type of the items to enable/disable
+   \param import Import from which all items are to be enabled/disabled
+   */
+  void SetImportItemsEnabled(bool enabled, const MediaType& mediaType, const CMediaImport& import);
+
   /*! \brief Updates the dateAdded field in the files table for the file
    with the given idFile and the given path based on the files modification date
    \param idFile id of the file in the files table
@@ -912,6 +1012,22 @@ class CVideoDatabase : public CDatabase
    */
   int GetFileId(const std::string& url);
 
+  /*! \brief Get the id of a source from its identifier
+   \param sourceIdentifier identifier of the source
+   \return id of the source, -1 if it is not in the db.
+   */
+  int GetSourceId(const std::string& sourceIdentifier);
+
+  /*! \brief Get the id of an import from its path
+   \param path path of the import
+   \param mediaTypes media types of the import
+   \param sourceIdentifier optional source identifier
+   \return id of the import, -1 if it is not in the db.
+   */
+  int GetImportId(const std::string& path, const GroupedMediaTypes& mediaTypes, const std::string &sourceIdentifier = "");
+  int GetImportId(const CMediaImport& import);
+  int GetImportId(int idPath, const GroupedMediaTypes& mediaTypes, int idSource = -1);
+
   int AddToTable(const std::string& table, const std::string& firstField, const std::string& secondField, const std::string& value);
   int UpdateRatings(int mediaId, const char *mediaType, const RatingMap& values, const std::string& defaultRating);
   int AddRatings(int mediaId, const char *mediaType, const RatingMap& values, const std::string& defaultRating);

From b97f4748c43d519f35dddcbc15ff562875ff4594 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 5 May 2015 23:19:17 +0200
Subject: [PATCH 23/88] [videodb] fix GetFileId() and AddFile() for imported
 items

---
 xbmc/video/VideoDatabase.cpp | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 79b52f0882f0..0507a6ffb9cb 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -1067,7 +1067,7 @@ int CVideoDatabase::AddFile(const std::string& strFileNameAndPath, const std::st
 
 int CVideoDatabase::AddFile(const CFileItem& item)
 {
-  if (item.IsVideoDb() && item.HasVideoInfoTag())
+  if (item.HasVideoInfoTag())
   {
     if (item.GetVideoInfoTag()->m_iFileId != -1)
       return item.GetVideoInfoTag()->m_iFileId;
@@ -1261,14 +1261,19 @@ int CVideoDatabase::GetFileId(const std::string& strFilenameAndPath)
 
 int CVideoDatabase::GetFileId(const CFileItem &item)
 {
-  if (item.IsVideoDb() && item.HasVideoInfoTag())
+  int fileId = -1;
+  if (item.HasVideoInfoTag())
   {
     if (item.GetVideoInfoTag()->m_iFileId != -1)
-      return item.GetVideoInfoTag()->m_iFileId;
-    else
-      return GetFileId(item.GetVideoInfoTag()->m_strFileNameAndPath);
+      fileId = item.GetVideoInfoTag()->m_iFileId;
+    else if (!item.GetVideoInfoTag()->m_strFileNameAndPath.empty())
+      fileId = GetFileId(item.GetVideoInfoTag()->m_strFileNameAndPath);
   }
-  return GetFileId(item.GetPath());
+
+  if (fileId == -1)
+    fileId = GetFileId(item.GetPath());
+
+  return fileId;
 }
 
 int CVideoDatabase::GetSourceId(const std::string& sourceIdentifier)

From 0695c463929dece14e400b67c368cb5621a8dc84 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 18 Jun 2017 21:10:39 +0200
Subject: [PATCH 24/88] [videodb] support setting playcount and lastplayed in
 AddFile()

---
 xbmc/video/VideoDatabase.cpp | 9 +++++++--
 xbmc/video/VideoDatabase.h   | 4 +++-
 2 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 0507a6ffb9cb..e7c48abeca96 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -1024,7 +1024,7 @@ bool CVideoDatabase::GetSourcePath(const std::string &path, std::string &sourceP
 }
 
 //********************************************************************************************************************************
-int CVideoDatabase::AddFile(const std::string& strFileNameAndPath, const std::string &parentPath /* = "" */)
+int CVideoDatabase::AddFile(const std::string& strFileNameAndPath, const std::string &parentPath /* = "" */, int playcount /* = 0 */, const CDateTime &lastPlayed /* = CDateTime() */)
 {
   std::string strSQL = "";
   try
@@ -1053,7 +1053,12 @@ int CVideoDatabase::AddFile(const std::string& strFileNameAndPath, const std::st
     }
     m_pDS->close();
 
-    strSQL=PrepareSQL("insert into files (idFile, idPath, strFileName) values(NULL, %i, '%s')", idPath, strFileName.c_str());
+    std::string strLastPlayed = "NULL";
+    if (lastPlayed.IsValid())
+      strLastPlayed = "'" + lastPlayed.GetAsDBDateTime() + "'";
+
+    strSQL=PrepareSQL("insert into files (idFile, idPath, strFileName, playCount, lastPlayed) values(NULL, %i, '%s', %d, " + strLastPlayed + ")",
+      idPath, strFileName.c_str(), playcount);
     m_pDS->exec(strSQL);
     idFile = (int)m_pDS->lastinsertid();
     return idFile;
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 37dec583edd6..b215e049cf12 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -781,9 +781,11 @@ class CVideoDatabase : public CDatabase
    If the file is already in the database, we simply return its id.
    \param url - full path of the file to add.
    \param parentPath the parent path of the path to add. If empty, URIUtils::GetParentPath() will determine the path.
+   \param playcount the playcount of the file to add.
+   \param lastPlayed the date and time when the file to add was last played.
    \return id of the file, -1 if it could not be added.
    */
-  int AddFile(const std::string& url, const std::string &parentPath = "");
+  int AddFile(const std::string& url, const std::string &parentPath = "", int playcount = 0, const CDateTime &lastPlayed = CDateTime());
 
   /*! \brief Add a file to the database, if necessary
    Works for both videodb:// items and normal fileitems

From 14792c97313c2b2bbab6b94b2c457751df0d488c Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 26 Dec 2019 09:33:36 +0100
Subject: [PATCH 25/88] [videodb] support unique IDs for musicvideos

---
 xbmc/interfaces/json-rpc/schema/methods.json |  3 +-
 xbmc/interfaces/json-rpc/schema/types.json   |  7 +-
 xbmc/interfaces/json-rpc/schema/version.txt  |  2 +-
 xbmc/video/VideoDatabase.cpp                 | 84 ++++++++++++--------
 xbmc/video/VideoDatabase.h                   | 17 ++--
 5 files changed, 71 insertions(+), 42 deletions(-)

diff --git a/xbmc/interfaces/json-rpc/schema/methods.json b/xbmc/interfaces/json-rpc/schema/methods.json
index 079eb7efeac2..dacba82625be 100644
--- a/xbmc/interfaces/json-rpc/schema/methods.json
+++ b/xbmc/interfaces/json-rpc/schema/methods.json
@@ -1686,7 +1686,8 @@
       { "name": "rating", "$ref": "Optional.Number" },
       { "name": "userrating", "$ref": "Optional.Integer" },
       { "name": "dateadded", "$ref": "Optional.String" },
-      { "name": "premiered", "$ref": "Optional.String", "description": "linked with year. Overrides year" }
+      { "name": "premiered", "$ref": "Optional.String", "description": "linked with year. Overrides year" },
+      { "name": "uniqueid", "type": [ "null", { "$ref": "Media.UniqueID.Set", "required": true } ], "default": null }
     ],
     "returns": "string"
   },
diff --git a/xbmc/interfaces/json-rpc/schema/types.json b/xbmc/interfaces/json-rpc/schema/types.json
index 21a2347ed1fc..4f5650440414 100644
--- a/xbmc/interfaces/json-rpc/schema/types.json
+++ b/xbmc/interfaces/json-rpc/schema/types.json
@@ -767,12 +767,12 @@
   "Video.Fields.MusicVideo": {
     "extends": "Item.Fields.Base",
     "items": { "type": "string",
-      "description": "Requesting the streamdetails and/or tag field will result in increased response times",
+      "description": "Requesting the streamdetails, uniqueid and/or tag field will result in increased response times",
       "enum": [ "title", "playcount", "runtime", "director",
                 "studio", "year", "plot", "album", "artist",
                 "genre", "track", "streamdetails", "lastplayed",
                 "fanart", "thumbnail", "file", "resume", "dateadded",
-                "tag", "art", "rating", "userrating", "premiered" ]
+                "tag", "art", "rating", "userrating", "premiered", "uniqueid" ]
     }
   },
   "Video.Cast": {
@@ -984,7 +984,8 @@
       "tag": { "$ref": "Array.String" },
       "rating": { "type": "number" },
       "userrating": { "type": "integer" },
-      "premiered": { "type": "string" }
+      "premiered": { "type": "string" },
+      "uniqueid": { "$ref": "Media.UniqueID" }
     }
   },
   "PVR.Property.Name": {
diff --git a/xbmc/interfaces/json-rpc/schema/version.txt b/xbmc/interfaces/json-rpc/schema/version.txt
index 2cb4594d6795..135e57f47c0c 100644
--- a/xbmc/interfaces/json-rpc/schema/version.txt
+++ b/xbmc/interfaces/json-rpc/schema/version.txt
@@ -1 +1 @@
-JSONRPC_VERSION 11.12.1
+JSONRPC_VERSION 11.13.0
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index e7c48abeca96..0f0954eedebb 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -330,6 +330,7 @@ void CVideoDatabase::CreateAnalytics()
               "DELETE FROM studio_link WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
               "DELETE FROM art WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
               "DELETE FROM tag_link WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
+              "DELETE FROM uniqueid WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
               "DELETE FROM import_link WHERE media_id=old.idMVideo AND media_type='musicvideo'; "
               "END");
   m_pDS->exec("CREATE TRIGGER delete_episode AFTER DELETE ON episode FOR EACH ROW BEGIN "
@@ -552,36 +553,45 @@ void CVideoDatabase::CreateViews()
   m_pDS->exec(seasonview);
 
   CLog::Log(LOGINFO, "create musicvideo_view");
-  m_pDS->exec("CREATE VIEW musicvideo_view AS SELECT"
-              "  musicvideo.*,"
-              "  files.strFileName as strFileName,"
-              "  path.strPath as strPath,"
-              "  files.playCount as playCount,"
-              "  files.lastPlayed as lastPlayed,"
-              "  files.dateAdded as dateAdded, "
-              "  bookmark.timeInSeconds AS resumeTimeInSeconds, "
-              "  bookmark.totalTimeInSeconds AS totalTimeInSeconds, "
-              "  bookmark.playerState AS playerState, "
-              "  source.identifier AS strSource,"
-              "  import_link.enabled AS enabled,"
-              "  importsPath.strPath AS importPath,"
-              "  1 - LEAST(IFNULL(import_link.import_id, 0), 1) AS local," // 1 if the item is local, otherwise 0
-              "  LEAST(IFNULL(import_link.import_id, 0), 1) AS imported " // 1 if the item is imported, otherwise 0
-              "FROM musicvideo"
-              "  JOIN files ON"
-              "    files.idFile=musicvideo.idFile"
-              "  JOIN path ON"
-              "    path.idPath=files.idPath"
-              "  LEFT JOIN bookmark ON"
-              "    bookmark.idFile=musicvideo.idFile AND bookmark.type=1"
-              "  LEFT JOIN import_link ON"
-              "    import_link.media_id = musicvideo.idMVideo AND import_link.media_type = 'musicvideo'"
-              "  LEFT JOIN import ON"
-              "    import.import_id = import_link.import_id"
-              "  LEFT JOIN source ON"
-              "    source.source_id = import.source_id"
-              "  LEFT JOIN path AS importsPath ON"
-              "    importsPath.idPath = import.idPath");
+  std::string musicvideoview = PrepareSQL(
+      "CREATE VIEW musicvideo_view AS SELECT"
+      "  musicvideo.*,"
+      "  files.strFileName as strFileName,"
+      "  path.strPath as strPath,"
+      "  files.playCount as playCount,"
+      "  files.lastPlayed as lastPlayed,"
+      "  files.dateAdded as dateAdded, "
+      "  bookmark.timeInSeconds AS resumeTimeInSeconds, "
+      "  bookmark.totalTimeInSeconds AS totalTimeInSeconds, "
+      "  bookmark.playerState AS playerState, "
+      "  uniqueid.value AS uniqueid_value,"
+      "  uniqueid.type AS uniqueid_type,"
+      "  source.identifier AS strSource,"
+      "  import_link.enabled AS enabled,"
+      "  importsPath.strPath AS importPath,"
+      "  1 - LEAST(IFNULL(import_link.import_id, 0), 1) AS local," // 1 if the item is local,
+                                                                   // otherwise 0
+      "  LEAST(IFNULL(import_link.import_id, 0), 1) AS imported " // 1 if the item is imported,
+                                                                  // otherwise 0
+      "FROM musicvideo"
+      "  JOIN files ON"
+      "    files.idFile=musicvideo.idFile"
+      "  JOIN path ON"
+      "    path.idPath=files.idPath"
+      "  LEFT JOIN bookmark ON"
+      "    bookmark.idFile=musicvideo.idFile AND bookmark.type=1"
+      "  LEFT JOIN uniqueid ON"
+      "    uniqueid.uniqueid_id=musicvideo.c%02d"
+      "  LEFT JOIN import_link ON"
+      "    import_link.media_id = musicvideo.idMVideo AND import_link.media_type = 'musicvideo'"
+      "  LEFT JOIN import ON"
+      "    import.import_id = import_link.import_id"
+      "  LEFT JOIN source ON"
+      "    source.source_id = import.source_id"
+      "  LEFT JOIN path AS importsPath ON"
+      "    importsPath.idPath = import.idPath",
+      VIDEODB_ID_MUSICVIDEO_IDENT_ID);
+  m_pDS->exec(musicvideoview);
 
   CLog::Log(LOGINFO, "create movie_view");
   std::string movieview = PrepareSQL("CREATE VIEW movie_view AS SELECT"
@@ -3185,8 +3195,10 @@ int CVideoDatabase::AddSeason(int showID, int season, const std::string& name /*
   return seasonId;
 }
 
-int CVideoDatabase::SetDetailsForMusicVideo(const std::string& strFilenameAndPath, const CVideoInfoTag& details,
-    const std::map<std::string, std::string> &artwork, int idMVideo /* = -1 */)
+int CVideoDatabase::SetDetailsForMusicVideo(const std::string& strFilenameAndPath,
+                                            CVideoInfoTag& details,
+                                            const std::map<std::string, std::string>& artwork,
+                                            int idMVideo /* = -1 */)
 {
   try
   {
@@ -3226,6 +3238,9 @@ int CVideoDatabase::SetDetailsForMusicVideo(const std::string& strFilenameAndPat
     AddLinksToItem(idMVideo, MediaTypeMusicVideo, "studio", details.m_studio);
     AddLinksToItem(idMVideo, MediaTypeMusicVideo, "tag", details.m_tags);
 
+    // add unique ids
+    details.m_iIdUniqueID = UpdateUniqueIDs(idMVideo, MediaTypeMusicVideo, details);
+
     if (details.HasStreamDetails())
       SetStreamDetailsForFileId(details.m_streamDetails, GetFileId(strFilenameAndPath));
 
@@ -4568,6 +4583,8 @@ CVideoInfoTag CVideoDatabase::GetDetailsForMusicVideo(const dbiplus::sql_record*
                          record->at(VIDEODB_DETAILS_MUSICVIDEO_TOTAL_TIME).get_asInt(),
                          record->at(VIDEODB_DETAILS_MUSICVIDEO_PLAYER_STATE).get_asString());
   details.m_iUserRating = record->at(VIDEODB_DETAILS_MUSICVIDEO_USER_RATING).get_asInt();
+  details.SetUniqueID(record->at(VIDEODB_DETAILS_MUSICVIDEO_UNIQUEID_VALUE).get_asString(),
+                      record->at(VIDEODB_DETAILS_MUSICVIDEO_UNIQUEID_TYPE).get_asString(), true);
   std::string premieredString = record->at(VIDEODB_DETAILS_MUSICVIDEO_PREMIERED).get_asString();
   if (premieredString.size() == 4)
     details.SetYear(record->at(VIDEODB_DETAILS_MUSICVIDEO_PREMIERED).get_asInt());
@@ -4581,6 +4598,9 @@ CVideoInfoTag CVideoDatabase::GetDetailsForMusicVideo(const dbiplus::sql_record*
     if (getDetails & VideoDbDetailsTag)
       GetTags(details.m_iDbId, MediaTypeMusicVideo, details.m_tags);
 
+    if (getDetails & VideoDbDetailsUniqueID)
+      GetUniqueIDs(details.m_iDbId, MediaTypeMusicVideo, details);
+
     if (getDetails & VideoDbDetailsStream)
       GetStreamDetails(details);
 
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index b215e049cf12..b62a1fcaa65e 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -152,9 +152,11 @@ enum VideoDbDetails
 #define VIDEODB_DETAILS_MUSICVIDEO_RESUME_TIME  VIDEODB_MAX_COLUMNS + 9
 #define VIDEODB_DETAILS_MUSICVIDEO_TOTAL_TIME   VIDEODB_MAX_COLUMNS + 10
 #define VIDEODB_DETAILS_MUSICVIDEO_PLAYER_STATE VIDEODB_MAX_COLUMNS + 11
-#define VIDEODB_DETAILS_MUSICVIDEO_SOURCE       VIDEODB_MAX_COLUMNS + 12
-#define VIDEODB_DETAILS_MUSICVIDEO_ENABLED      VIDEODB_MAX_COLUMNS + 13
-#define VIDEODB_DETAILS_MUSICVIDEO_IMPORTPATH   VIDEODB_MAX_COLUMNS + 14
+#define VIDEODB_DETAILS_MUSICVIDEO_UNIQUEID_VALUE VIDEODB_MAX_COLUMNS + 12
+#define VIDEODB_DETAILS_MUSICVIDEO_UNIQUEID_TYPE VIDEODB_MAX_COLUMNS + 13
+#define VIDEODB_DETAILS_MUSICVIDEO_SOURCE       VIDEODB_MAX_COLUMNS + 14
+#define VIDEODB_DETAILS_MUSICVIDEO_ENABLED      VIDEODB_MAX_COLUMNS + 15
+#define VIDEODB_DETAILS_MUSICVIDEO_IMPORTPATH   VIDEODB_MAX_COLUMNS + 16
 
 #define VIDEODB_TYPE_UNUSED 0
 #define VIDEODB_TYPE_STRING 1
@@ -378,6 +380,7 @@ typedef enum // this enum MUST match the offset struct further down!! and make s
   VIDEODB_ID_MUSICVIDEO_TRACK = 12,
   VIDEODB_ID_MUSICVIDEO_BASEPATH = 13,
   VIDEODB_ID_MUSICVIDEO_PARENTPATHID = 14,
+  VIDEODB_ID_MUSICVIDEO_IDENT_ID = 15,
   VIDEODB_ID_MUSICVIDEO_MAX
 } VIDEODB_MUSICVIDEO_IDS;
 
@@ -397,7 +400,8 @@ const struct SDbTableOffsets DbMusicVideoOffsets[] =
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_genre) },
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_iTrack) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_basePath) },
-  { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_parentPathID) }
+  { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_parentPathID) },
+  { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_iIdUniqueID)}
 };
 
 #define COMPARE_PERCENTAGE     0.90f // 90%
@@ -547,7 +551,10 @@ class CVideoDatabase : public CDatabase
   bool UpdateDetailsForTvShow(int idTvShow, CVideoInfoTag &details, const std::map<std::string, std::string> &artwork, const std::map<int, std::map<std::string, std::string> > &seasonArt);
   int SetDetailsForSeason(const CVideoInfoTag& details, const std::map<std::string, std::string> &artwork, int idShow, int idSeason = -1);
   int SetDetailsForEpisode(const std::string& strFilenameAndPath, CVideoInfoTag& details, const std::map<std::string, std::string> &artwork, int idShow, int idEpisode=-1);
-  int SetDetailsForMusicVideo(const std::string& strFilenameAndPath, const CVideoInfoTag& details, const std::map<std::string, std::string> &artwork, int idMVideo = -1);
+  int SetDetailsForMusicVideo(const std::string& strFilenameAndPath,
+                              CVideoInfoTag& details,
+                              const std::map<std::string, std::string>& artwork,
+                              int idMVideo = -1);
   void SetStreamDetailsForFile(const CStreamDetails& details, const std::string &strFileNameAndPath);
   void SetStreamDetailsForFileId(const CStreamDetails& details, int idFile);
 

From 28937f381493081c8441ac64f2118c4ca8386983 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Fri, 13 Sep 2013 10:16:12 +0200
Subject: [PATCH 26/88] [CVideoInfoTag] implement == and != operators and
 Equals()

---
 xbmc/utils/ScraperUrl.cpp   |  38 +++++++++++
 xbmc/utils/ScraperUrl.h     |   5 ++
 xbmc/video/VideoInfoTag.cpp | 124 ++++++++++++++++++++++++++++++++++++
 xbmc/video/VideoInfoTag.h   |   7 ++
 4 files changed, 174 insertions(+)

diff --git a/xbmc/utils/ScraperUrl.cpp b/xbmc/utils/ScraperUrl.cpp
index f242a40f57ff..baab667ee81b 100644
--- a/xbmc/utils/ScraperUrl.cpp
+++ b/xbmc/utils/ScraperUrl.cpp
@@ -43,6 +43,44 @@ CScraperUrl::CScraperUrl(const TiXmlElement* element) : CScraperUrl()
 
 CScraperUrl::~CScraperUrl() = default;
 
+bool CScraperUrl::operator==(const CScraperUrl& rhs) const
+{
+  if (m_data != rhs.m_data)
+    return false;
+  if (m_title != rhs.m_title)
+    return false;
+  if (m_id != rhs.m_id)
+    return false;
+  if (m_relevance != rhs.m_relevance)
+    return false;
+  if (m_urls != rhs.m_urls)
+    return false;
+
+  return true;
+}
+
+bool CScraperUrl::SUrlEntry::operator==(const SUrlEntry& rhs) const
+{
+  if (m_spoof != rhs.m_spoof)
+    return false;
+  if (m_url != rhs.m_url)
+    return false;
+  if (m_cache != rhs.m_cache)
+    return false;
+  if (m_aspect != rhs.m_aspect)
+    return false;
+  if (m_type != rhs.m_type)
+    return false;
+  if (m_post != rhs.m_post)
+    return false;
+  if (m_isgz != rhs.m_isgz)
+    return false;
+  if (m_season != rhs.m_season)
+    return false;
+
+  return true;
+}
+
 void CScraperUrl::Clear()
 {
   m_urls.clear();
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index f6c13bacf723..ff76aaf25a78 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -34,6 +34,8 @@ class CScraperUrl
     {
     }
 
+    bool operator==(const SUrlEntry& rhs) const;
+
     std::string m_spoof;
     std::string m_url;
     std::string m_cache;
@@ -49,6 +51,9 @@ class CScraperUrl
   explicit CScraperUrl(const TiXmlElement* element);
   ~CScraperUrl();
 
+  bool operator==(const CScraperUrl& rhs) const;
+  bool operator!=(const CScraperUrl& rhs) const { return !(*this == rhs); }
+
   void Clear();
 
   bool HasData() const { return !m_data.empty(); }
diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index 9a715cac51b6..9ad721deea7d 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -24,6 +24,30 @@
 #include <string>
 #include <vector>
 
+bool operator==(const CRating& lhs, const CRating& rhs)
+{
+  return lhs.rating == rhs.rating && lhs.votes == rhs.votes;
+}
+
+bool operator!=(const CRating& lhs, const CRating& rhs)
+{
+  return !(lhs == rhs);
+}
+
+bool SActorInfo::operator==(const SActorInfo& rhs) const
+{
+  if (strName.compare(rhs.strName) != 0)
+    return false;
+  if (strRole.compare(rhs.strRole) != 0)
+    return false;
+  if (thumb.compare(rhs.thumb) != 0)
+    return false;
+  if (thumbUrl != rhs.thumbUrl)
+    return false;
+
+  return true;
+}
+
 void CVideoInfoTag::Reset()
 {
   m_director.clear();
@@ -1610,3 +1634,103 @@ bool CVideoInfoTag::SetResumePoint(double timeInSeconds, double totalTimeInSecon
   m_resumePoint = resumePoint;
   return true;
 }
+
+bool CVideoInfoTag::Equals(const CVideoInfoTag& rhs, bool metadataOnly /* = false */) const
+{
+  bool ret = true;
+
+  if (!metadataOnly)
+  {
+    // check paths
+    ret &= m_parentPathID == rhs.m_parentPathID;
+    ret &= StringUtils::EqualsNoCase(m_basePath, rhs.m_basePath);
+    ret &= StringUtils::EqualsNoCase(m_strFile, rhs.m_strFile);
+    ret &= StringUtils::EqualsNoCase(m_strPath, rhs.m_strPath);
+    ret &= StringUtils::EqualsNoCase(m_strFileNameAndPath, rhs.m_strFileNameAndPath);
+
+    // check IDs
+    ret &= m_set.id <= 0 || rhs.m_set.id <= 0 || m_set.id == rhs.m_set.id;
+    ret &= m_iBookmarkId == rhs.m_iBookmarkId;
+    ret &= m_iIdShow <= 0 || rhs.m_iIdShow <= 0 || m_iIdShow == rhs.m_iIdShow;
+    ret &= m_iIdSeason <= 0 || rhs.m_iIdSeason <= 0 || m_iIdSeason == rhs.m_iIdSeason;
+
+    ret &= m_parsedDetails == rhs.m_parsedDetails;
+  }
+
+  ret &= m_playCount == rhs.m_playCount;
+  ret &= m_lastPlayed == rhs.m_lastPlayed || !rhs.m_lastPlayed.IsValid();
+  ret &= m_iTop250 == rhs.m_iTop250;
+  ret &= GetYear() == rhs.GetYear();
+  ret &= m_ratings.size() == rhs.m_ratings.size() &&
+         std::equal(m_ratings.begin(), m_ratings.end(), rhs.m_ratings.begin());
+  ret &= m_iUserRating == rhs.m_iUserRating;
+  ret &= m_duration == rhs.m_duration;
+
+  ret &= m_strPlot == rhs.m_strPlot;
+  ret &= m_strTitle == rhs.m_strTitle;
+  ret &= m_strSortTitle == rhs.m_strSortTitle;
+  ret &= m_strOriginalTitle == rhs.m_strOriginalTitle;
+  ret &= m_strShowTitle == rhs.m_strShowTitle;
+  ret &= m_uniqueIDs.size() == rhs.m_uniqueIDs.size() &&
+         std::equal(m_uniqueIDs.begin(), m_uniqueIDs.end(), rhs.m_uniqueIDs.begin()) &&
+         m_strDefaultUniqueID == rhs.m_strDefaultUniqueID;
+  ret &= StringUtils::EqualsNoCase(m_type, rhs.m_type);
+
+  ret &= m_director == rhs.m_director;
+  ret &= m_writingCredits == rhs.m_writingCredits;
+  ret &= m_country == rhs.m_country;
+
+  if (m_type == "movie" || m_type == "tvshow" || m_type == "musicvideo")
+  {
+    ret &= m_genre == rhs.m_genre;
+    ret &= m_tags == rhs.m_tags;
+    ret &= m_studio == rhs.m_studio;
+
+    if (m_type == "movie" || m_type == "tvshow")
+    {
+      ret &= m_strMPAARating == rhs.m_strMPAARating;
+
+      if (m_type == "movie")
+      {
+        ret &= m_strTagLine == rhs.m_strTagLine;
+        ret &= m_strPlotOutline == rhs.m_strPlotOutline;
+        ret &= m_strTrailer == rhs.m_strTrailer;
+        ret &= m_set.title == rhs.m_set.title;
+      }
+      else if (m_type == "tvshow")
+      {
+        ret &= m_premiered == rhs.m_premiered;
+        ret &= m_strStatus == rhs.m_strStatus;
+      }
+    }
+    else if (m_type == "musicvideo")
+    {
+      ret &= m_iTrack == rhs.m_iTrack;
+      ret &= m_strAlbum == rhs.m_strAlbum;
+      ret &= m_artist == rhs.m_artist;
+    }
+  }
+
+  if (m_type == "movie" || m_type == "tvshow" || m_type == "episode")
+  {
+    ret &= m_cast == rhs.m_cast;
+  }
+
+  if (m_type == "season" || m_type == "episode")
+  {
+    ret &= m_iSeason == rhs.m_iSeason;
+    ret &= m_iSpecialSortSeason == rhs.m_iSpecialSortSeason;
+    ret &= m_iSpecialSortEpisode == rhs.m_iSpecialSortEpisode;
+
+    if (m_type == "episode")
+    {
+      // TODO: ret &= m_EpBookmark == rhs.m_EpBookmark;
+      ret &= m_iEpisode == rhs.m_iEpisode;
+      ret &= m_strEpisodeGuide == rhs.m_strEpisodeGuide;
+      ret &= m_strProductionCode == rhs.m_strProductionCode;
+      ret &= m_firstAired == rhs.m_firstAired;
+    }
+  }
+
+  return ret;
+}
diff --git a/xbmc/video/VideoInfoTag.h b/xbmc/video/VideoInfoTag.h
index 7dad34d551f3..5130ce9d3b7f 100644
--- a/xbmc/video/VideoInfoTag.h
+++ b/xbmc/video/VideoInfoTag.h
@@ -30,6 +30,7 @@ struct SActorInfo
   {
     return order < right.order;
   }
+  bool operator==(const SActorInfo& rhs) const;
   std::string strName;
   std::string strRole;
   CScraperUrl thumbUrl;
@@ -101,6 +102,12 @@ class CVideoInfoTag : public IArchivable, public ISerializable, public ISortable
    */
   void SetDuration(int duration);
 
+  bool Equals(const CVideoInfoTag& rhs, bool metadataOnly = false) const;
+
+  bool operator==(const CVideoInfoTag& rhs) const { return Equals(rhs, false); }
+
+  bool operator!=(const CVideoInfoTag& rhs) const { return !(*this == rhs); }
+
   /*! \brief retrieve the duration in seconds.
    Prefers the duration from stream details if available.
    */

From d2af1f9ed63928671747f1258252fca786a318fd Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Mon, 30 Dec 2013 10:38:17 +0100
Subject: [PATCH 27/88] [CVideoInfoTag] implement GetDifferences()

---
 xbmc/video/VideoInfoTag.cpp | 133 ++++++++++++++++++++++++++++++++++++
 xbmc/video/VideoInfoTag.h   |   2 +
 2 files changed, 135 insertions(+)

diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index 9ad721deea7d..cfe242c41e5e 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -695,6 +695,7 @@ void CVideoInfoTag::ToSortable(SortItem& sortable, Field field) const
       sortable[FieldSortTitle] = m_strSortTitle;
     break;
   }
+  case FieldOriginalTitle:            sortable[FieldOriginalTitle] = m_strOriginalTitle; break;
   case FieldTvShowStatus:             sortable[FieldTvShowStatus] = m_strStatus; break;
   case FieldProductionCode:           sortable[FieldProductionCode] = m_strProductionCode; break;
   case FieldAirDate:                  sortable[FieldAirDate] = m_firstAired.IsValid() ? m_firstAired.GetAsDBDate() : (m_premiered.IsValid() ? m_premiered.GetAsDBDate() : StringUtils::Empty); break;
@@ -711,6 +712,7 @@ void CVideoInfoTag::ToSortable(SortItem& sortable, Field field) const
   case FieldNumberOfWatchedEpisodes:  sortable[FieldNumberOfWatchedEpisodes] = m_iEpisode; break;
   case FieldEpisodeNumberSpecialSort: sortable[FieldEpisodeNumberSpecialSort] = m_iSpecialSortEpisode; break;
   case FieldSeasonSpecialSort:        sortable[FieldSeasonSpecialSort] = m_iSpecialSortSeason; break;
+  case FieldUniqueId:                 sortable[FieldUniqueId] = GetUniqueID(); break;
   case FieldRating:                   sortable[FieldRating] = GetRating().rating; break;
   case FieldUserRating:               sortable[FieldUserRating] = m_iUserRating; break;
   case FieldId:                       sortable[FieldId] = m_iDbId; break;
@@ -1734,3 +1736,134 @@ bool CVideoInfoTag::Equals(const CVideoInfoTag& rhs, bool metadataOnly /* = fals
 
   return ret;
 }
+
+bool CVideoInfoTag::GetDifferences(const CVideoInfoTag &rhs, std::set<Field> &fields, bool metadataOnly /* = false */) const
+{
+  fields.clear();
+
+  if (!metadataOnly)
+  {
+    // check IDs
+    if (m_iDbId > 0 && rhs.m_iDbId > 0 && m_iDbId != rhs.m_iDbId)
+      fields.insert(FieldId);
+
+    // check paths
+    if (!StringUtils::EqualsNoCase(m_strFile, rhs.m_strFile))
+      fields.insert(FieldFilename);
+    if (!StringUtils::EqualsNoCase(m_strPath, rhs.m_strPath))
+      fields.insert(FieldPath);
+  }
+
+  if (m_playCount != rhs.m_playCount)
+    fields.insert(FieldPlaycount);
+  if (m_lastPlayed != rhs.m_lastPlayed && !rhs.m_lastPlayed.IsValid())
+    fields.insert(FieldLastPlayed);
+  if (m_iTop250 != rhs.m_iTop250)
+    fields.insert(FieldTop250);
+  if (m_ratings.size() != rhs.m_ratings.size() ||
+      !std::equal(m_ratings.begin(), m_ratings.end(), rhs.m_ratings.begin()))
+    fields.insert(FieldRating);
+  if (m_iUserRating != rhs.m_iUserRating)
+    fields.insert(FieldUserRating);
+  if (m_duration != rhs.m_duration)
+    fields.insert(FieldTime);
+
+  if (m_strPlot != rhs.m_strPlot)
+    fields.insert(FieldPlot);
+  if (m_strTitle != rhs.m_strTitle)
+    fields.insert(FieldTitle);
+  if (m_strSortTitle != rhs.m_strSortTitle)
+    fields.insert(FieldSortTitle);
+  if (m_strOriginalTitle != rhs.m_strOriginalTitle)
+    fields.insert(FieldOriginalTitle);
+  if (m_strShowTitle != rhs.m_strShowTitle)
+    fields.insert(FieldTvShowTitle);
+
+ if (m_uniqueIDs.size() != rhs.m_uniqueIDs.size() || !std::equal(m_uniqueIDs.begin(), m_uniqueIDs.end(), rhs.m_uniqueIDs.begin()) || m_strDefaultUniqueID != rhs.m_strDefaultUniqueID)
+    fields.insert(FieldUniqueId);
+  if (!StringUtils::EqualsNoCase(m_type, rhs.m_type))
+    fields.insert(FieldMediaType);
+
+  if (m_director != rhs.m_director)
+    fields.insert(FieldDirector);
+  if (m_writingCredits != rhs.m_writingCredits)
+    fields.insert(FieldWriter);
+  if (m_country != rhs.m_country)
+    fields.insert(FieldCountry);
+
+  if (m_resumePoint.IsPartWay() != rhs.m_resumePoint.IsPartWay())
+    fields.insert(FieldInProgress);
+
+  if (m_type == "movie" || m_type == "tvshow" || m_type == "musicvideo")
+  {
+    if (m_genre != rhs.m_genre)
+      fields.insert(FieldGenre);
+    if (m_tags != rhs.m_tags)
+      fields.insert(FieldTag);
+    if (m_studio != rhs.m_studio)
+      fields.insert(FieldStudio);
+
+    if (m_type == "movie" || m_type == "tvshow")
+    {
+      if (m_strMPAARating != rhs.m_strMPAARating)
+        fields.insert(FieldMPAA);
+
+      if (m_type == "movie")
+      {
+        if (m_strTagLine != rhs.m_strTagLine)
+          fields.insert(FieldTagline);
+        if (m_strPlotOutline != rhs.m_strPlotOutline)
+          fields.insert(FieldPlotOutline);
+        if (m_strTrailer != rhs.m_strTrailer)
+          fields.insert(FieldTrailer);
+        if (m_set.title != rhs.m_set.title ||
+           (m_set.id > 0 && rhs.m_set.id > 0 && m_set.id != rhs.m_set.id))
+          fields.insert(FieldSet);
+      }
+      else if (m_type == "tvshow")
+      {
+        if (m_premiered.GetAsDBDate() != rhs.m_premiered.GetAsDBDate())
+          fields.insert(FieldAirDate);
+        if (m_strStatus != rhs.m_strStatus)
+          fields.insert(FieldTvShowStatus);
+      }
+    }
+    else if (m_type == "musicvideo")
+    {
+      if (m_iTrack != rhs.m_iTrack)
+        fields.insert(FieldTrackNumber);
+      if (m_strAlbum != rhs.m_strAlbum)
+        fields.insert(FieldAlbum);
+      if (m_artist != rhs.m_artist)
+        fields.insert(FieldArtist);
+    }
+  }
+
+  if (m_type == "movie" || m_type == "tvshow" || m_type == "episode")
+  {
+    if (m_cast != rhs.m_cast)
+      fields.insert(FieldActor);
+  }
+
+  if (m_type == "season" || m_type == "episode")
+  {
+    if (m_iSeason != rhs.m_iSeason)
+      fields.insert(FieldSeason);
+    if (m_iSpecialSortSeason != rhs.m_iSpecialSortSeason)
+      fields.insert(FieldSeasonSpecialSort);
+    if (m_iSpecialSortEpisode != rhs.m_iSpecialSortEpisode)
+      fields.insert(FieldEpisodeNumberSpecialSort);
+
+    if (m_type == "episode")
+    {
+      if (m_iEpisode != rhs.m_iEpisode)
+        fields.insert(FieldEpisodeNumber);
+      if (m_strProductionCode != rhs.m_strProductionCode)
+        fields.insert(FieldProductionCode);
+      if (m_firstAired.GetAsDBDate() != rhs.m_firstAired.GetAsDBDate())
+        fields.insert(FieldAirDate);
+    }
+  }
+
+  return !fields.empty();
+}
diff --git a/xbmc/video/VideoInfoTag.h b/xbmc/video/VideoInfoTag.h
index 5130ce9d3b7f..db885a74d33b 100644
--- a/xbmc/video/VideoInfoTag.h
+++ b/xbmc/video/VideoInfoTag.h
@@ -108,6 +108,8 @@ class CVideoInfoTag : public IArchivable, public ISerializable, public ISortable
 
   bool operator!=(const CVideoInfoTag& rhs) const { return !(*this == rhs); }
 
+  bool GetDifferences(const CVideoInfoTag &rhs, std::set<Field> &fields, bool metadataOnly = false) const;
+
   /*! \brief retrieve the duration in seconds.
    Prefers the duration from stream details if available.
    */

From aaae0452339747f9d4cdee36a304508de2834162 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Tue, 8 Apr 2014 23:44:05 +0200
Subject: [PATCH 28/88] [library] video library: get video details on demand if
 they weren't loaded

---
 xbmc/video/windows/GUIWindowVideoBase.cpp | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/xbmc/video/windows/GUIWindowVideoBase.cpp b/xbmc/video/windows/GUIWindowVideoBase.cpp
index a5afac7bcd77..b337d3e0ca8e 100644
--- a/xbmc/video/windows/GUIWindowVideoBase.cpp
+++ b/xbmc/video/windows/GUIWindowVideoBase.cpp
@@ -354,6 +354,26 @@ bool CGUIWindowVideoBase::ShowIMDB(CFileItemPtr item, const ScraperPtr &info2, b
   }
   else if(item->HasVideoInfoTag())
   {
+    if (item->GetVideoInfoTag()->m_parsedDetails != VideoDbDetailsAll)
+    {
+      std::string path = item->GetPath();
+      CVideoInfoTag &videoInfo = *item->GetVideoInfoTag();
+      int dbId = videoInfo.m_iDbId;
+
+      m_database.Open();
+
+      if (item->GetVideoInfoTag()->m_type == MediaTypeMovie)
+        m_database.GetMovieInfo(path, videoInfo, dbId);
+      else if (item->GetVideoInfoTag()->m_type == MediaTypeEpisode)
+        m_database.GetEpisodeInfo(path, videoInfo, dbId);
+      else if (item->GetVideoInfoTag()->m_type == MediaTypeTvShow)
+        m_database.GetTvShowInfo(path, videoInfo, dbId);
+      else if (item->GetVideoInfoTag()->m_type == MediaTypeMusicVideo)
+        m_database.GetMusicVideoInfo(path, videoInfo, dbId);
+
+      m_database.Close();
+    }
+
     bHasInfo = true;
     movieDetails = *item->GetVideoInfoTag();
   }

From 440b910477825814ca514c46db948fe62c988146 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Fri, 13 Mar 2015 10:43:45 +0100
Subject: [PATCH 29/88] [library] refactor CVideoLibraryQueue into
 CLibraryQueue

---
 xbmc/Application.cpp                          | 29 +++---
 xbmc/CMakeLists.txt                           |  2 +
 ...VideoLibraryQueue.cpp => LibraryQueue.cpp} | 76 +++++++++-------
 .../VideoLibraryQueue.h => LibraryQueue.h}    | 91 +++++++++++++------
 xbmc/interfaces/json-rpc/VideoLibrary.cpp     | 12 ++-
 xbmc/profiles/ProfileManager.cpp              |  6 +-
 xbmc/pvr/windows/GUIWindowPVRRecordings.cpp   |  4 +-
 xbmc/video/CMakeLists.txt                     |  2 -
 xbmc/video/ContextMenus.cpp                   |  7 +-
 xbmc/video/ContextMenus.h                     |  1 -
 xbmc/video/VideoInfoScanner.cpp               |  6 +-
 xbmc/video/jobs/VideoLibraryJob.h             | 16 +---
 xbmc/video/windows/GUIWindowVideoBase.cpp     |  4 +-
 xbmc/video/windows/GUIWindowVideoNav.cpp      |  5 +-
 14 files changed, 150 insertions(+), 111 deletions(-)
 rename xbmc/{video/VideoLibraryQueue.cpp => LibraryQueue.cpp} (63%)
 rename xbmc/{video/VideoLibraryQueue.h => LibraryQueue.h} (56%)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index ed44da24ed2d..df68ee687eb8 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -14,6 +14,7 @@
 #include "GUIInfoManager.h"
 #include "HDRStatus.h"
 #include "LangInfo.h"
+#include "LibraryQueue.h"
 #include "PlayListPlayer.h"
 #include "URL.h"
 #include "Util.h"
@@ -44,7 +45,6 @@
 #include "utils/Screenshot.h"
 #include "utils/Variant.h"
 #include "video/Bookmark.h"
-#include "video/VideoLibraryQueue.h"
 #ifdef HAS_PYTHON
 #include "interfaces/python/XBPython.h"
 #endif
@@ -2646,8 +2646,8 @@ void CApplication::Stop(int exitCode)
     if (CMusicLibraryQueue::GetInstance().IsRunning())
       CMusicLibraryQueue::GetInstance().CancelAllJobs();
 
-    if (CVideoLibraryQueue::GetInstance().IsRunning())
-      CVideoLibraryQueue::GetInstance().CancelAllJobs();
+    if (CLibraryQueue::GetInstance().IsRunning())
+      CLibraryQueue::GetInstance().CancelAllJobs();
 
     CApplicationMessenger::GetInstance().Cleanup();
 
@@ -3764,11 +3764,12 @@ bool CApplication::IsScreenSaverInhibited() const
 void CApplication::CheckShutdown()
 {
   // first check if we should reset the timer
-  if (m_bInhibitIdleShutdown
-      || m_appPlayer.IsPlaying() || m_appPlayer.IsPausedPlayback() // is something playing?
-      || CMusicLibraryQueue::GetInstance().IsRunning()
-      || CVideoLibraryQueue::GetInstance().IsRunning()
-      || CServiceBroker::GetGUI()->GetWindowManager().IsWindowActive(WINDOW_DIALOG_PROGRESS) // progress dialog is onscreen
+  if (m_bInhibitIdleShutdown || m_appPlayer.IsPlaying() ||
+      m_appPlayer.IsPausedPlayback() // is something playing?
+      || CMusicLibraryQueue::GetInstance().IsRunning() ||
+      CLibraryQueue::GetInstance().IsRunning() ||
+      CServiceBroker::GetGUI()->GetWindowManager().IsWindowActive(
+          WINDOW_DIALOG_PROGRESS) // progress dialog is onscreen
       || !CServiceBroker::GetPVRManager().GUIActions()->CanSystemPowerdown(false))
   {
     m_shutdownTimer.StartZero();
@@ -4736,7 +4737,7 @@ void CApplication::UpdateCurrentPlayArt()
 
 bool CApplication::IsVideoScanning() const
 {
-  return CVideoLibraryQueue::GetInstance().IsScanningLibrary();
+  return CLibraryQueue::GetInstance().IsScanningLibrary();
 }
 
 bool CApplication::IsMusicScanning() const
@@ -4746,7 +4747,7 @@ bool CApplication::IsMusicScanning() const
 
 void CApplication::StopVideoScan()
 {
-  CVideoLibraryQueue::GetInstance().StopLibraryScanning();
+  CLibraryQueue::GetInstance().StopLibraryScanning();
 }
 
 void CApplication::StopMusicScan()
@@ -4757,7 +4758,7 @@ void CApplication::StopMusicScan()
 void CApplication::StartVideoCleanup(bool userInitiated /* = true */,
                                      const std::string& content /* = "" */)
 {
-  if (userInitiated && CVideoLibraryQueue::GetInstance().IsRunning())
+  if (userInitiated && CLibraryQueue::GetInstance().IsRunning())
     return;
 
   std::set<int> paths;
@@ -4785,14 +4786,14 @@ void CApplication::StartVideoCleanup(bool userInitiated /* = true */,
       return;
   }
   if (userInitiated)
-    CVideoLibraryQueue::GetInstance().CleanLibraryModal(paths);
+    CLibraryQueue::GetInstance().CleanVideoLibraryModal(paths);
   else
-    CVideoLibraryQueue::GetInstance().CleanLibrary(paths, true);
+    CLibraryQueue::GetInstance().CleanVideoLibrary(paths, true);
 }
 
 void CApplication::StartVideoScan(const std::string &strDirectory, bool userInitiated /* = true */, bool scanAll /* = false */)
 {
-  CVideoLibraryQueue::GetInstance().ScanLibrary(strDirectory, scanAll, userInitiated);
+  CLibraryQueue::GetInstance().ScanVideoLibrary(strDirectory, scanAll, userInitiated);
 }
 
 void CApplication::StartMusicCleanup(bool userInitiated /* = true */)
diff --git a/xbmc/CMakeLists.txt b/xbmc/CMakeLists.txt
index a68d1a56a9f8..491c9bfb0c23 100644
--- a/xbmc/CMakeLists.txt
+++ b/xbmc/CMakeLists.txt
@@ -19,6 +19,7 @@ set(SOURCES Application.cpp
             GUIPassword.cpp
             InfoScanner.cpp
             LangInfo.cpp
+            LibraryQueue.cpp
             MediaSource.cpp
             NfoFile.cpp
             PasswordManager.cpp
@@ -66,6 +67,7 @@ set(HEADERS AppParamParser.h
             IProgressCallback.h
             InfoScanner.h
             LangInfo.h
+            LibraryQueue.h
             LockType.h
             MediaSource.h
             NfoFile.h
diff --git a/xbmc/video/VideoLibraryQueue.cpp b/xbmc/LibraryQueue.cpp
similarity index 63%
rename from xbmc/video/VideoLibraryQueue.cpp
rename to xbmc/LibraryQueue.cpp
index e2a488b658ef..07a460764d81 100644
--- a/xbmc/video/VideoLibraryQueue.cpp
+++ b/xbmc/LibraryQueue.cpp
@@ -6,7 +6,7 @@
  *  See LICENSES/README.md for more information.
  */
 
-#include "VideoLibraryQueue.h"
+#include "LibraryQueue.h"
 
 #include "GUIUserMessages.h"
 #include "ServiceBroker.h"
@@ -23,64 +23,68 @@
 
 #include <utility>
 
-CVideoLibraryQueue::CVideoLibraryQueue()
-  : CJobQueue(false, 1, CJob::PRIORITY_LOW),
-    m_jobs()
-{ }
+CLibraryQueue::CLibraryQueue() : CJobQueue(false, 1, CJob::PRIORITY_LOW), m_jobs()
+{
+}
 
-CVideoLibraryQueue::~CVideoLibraryQueue()
+CLibraryQueue::~CLibraryQueue()
 {
   CSingleLock lock(m_critical);
   m_jobs.clear();
 }
 
-CVideoLibraryQueue& CVideoLibraryQueue::GetInstance()
+CLibraryQueue& CLibraryQueue::GetInstance()
 {
-  static CVideoLibraryQueue s_instance;
+  static CLibraryQueue s_instance;
   return s_instance;
 }
 
-void CVideoLibraryQueue::ScanLibrary(const std::string& directory, bool scanAll /* = false */ , bool showProgress /* = true */)
+void CLibraryQueue::ScanVideoLibrary(const std::string& directory,
+                                     bool scanAll /* = false */,
+                                     bool showProgress /* = true */)
 {
   AddJob(new CVideoLibraryScanningJob(directory, scanAll, showProgress));
 }
 
-bool CVideoLibraryQueue::IsScanningLibrary() const
+bool CLibraryQueue::IsScanningLibrary() const
 {
   // check if the library is being cleaned synchronously
   if (m_cleaning)
     return true;
 
   // check if the library is being scanned asynchronously
-  VideoLibraryJobMap::const_iterator scanningJobs = m_jobs.find("VideoLibraryScanningJob");
+  LibraryJobMap::const_iterator scanningJobs = m_jobs.find("VideoLibraryScanningJob");
   if (scanningJobs != m_jobs.end() && !scanningJobs->second.empty())
     return true;
 
   // check if the library is being cleaned asynchronously
-  VideoLibraryJobMap::const_iterator cleaningJobs = m_jobs.find("VideoLibraryCleaningJob");
+  LibraryJobMap::const_iterator cleaningJobs = m_jobs.find("VideoLibraryCleaningJob");
   if (cleaningJobs != m_jobs.end() && !cleaningJobs->second.empty())
     return true;
 
   return false;
 }
 
-void CVideoLibraryQueue::StopLibraryScanning()
+void CLibraryQueue::StopLibraryScanning()
 {
   CSingleLock lock(m_critical);
-  VideoLibraryJobMap::const_iterator scanningJobs = m_jobs.find("VideoLibraryScanningJob");
+  LibraryJobMap::const_iterator scanningJobs = m_jobs.find("VideoLibraryScanningJob");
   if (scanningJobs == m_jobs.end())
     return;
 
   // get a copy of the scanning jobs because CancelJob() will modify m_scanningJobs
-  VideoLibraryJobs tmpScanningJobs(scanningJobs->second.begin(), scanningJobs->second.end());
+  LibraryJobs tmpScanningJobs(scanningJobs->second.begin(), scanningJobs->second.end());
 
   // cancel all scanning jobs
-  for (VideoLibraryJobs::const_iterator job = tmpScanningJobs.begin(); job != tmpScanningJobs.end(); ++job)
+  for (LibraryJobs::const_iterator job = tmpScanningJobs.begin(); job != tmpScanningJobs.end();
+       ++job)
     CancelJob(*job);
   Refresh();
 }
 
-void CVideoLibraryQueue::CleanLibrary(const std::set<int>& paths /* = std::set<int>() */, bool asynchronous /* = true */, CGUIDialogProgressBarHandle* progressBar /* = NULL */)
+void CLibraryQueue::CleanVideoLibrary(const std::set<int>& paths /* = std::set<int>() */,
+                                      bool asynchronous /* = true */,
+                                      CGUIDialogProgressBarHandle* progressBar /* = NULL */)
 {
   CVideoLibraryCleaningJob* cleaningJob = new CVideoLibraryCleaningJob(paths, progressBar);
 
@@ -99,7 +103,7 @@ void CVideoLibraryQueue::CleanLibrary(const std::set<int>& paths /* = std::set<i
   }
 }
 
-void CVideoLibraryQueue::CleanLibraryModal(const std::set<int>& paths /* = std::set<int>() */)
+void CLibraryQueue::CleanVideoLibraryModal(const std::set<int>& paths /* = std::set<int>() */)
 {
   // we can't perform a modal library cleaning if other jobs are running
   if (IsRunning())
@@ -114,12 +118,18 @@ void CVideoLibraryQueue::CleanLibraryModal(const std::set<int>& paths /* = std::
   Refresh();
 }
 
-void CVideoLibraryQueue::RefreshItem(CFileItemPtr item, bool ignoreNfo /* = false */, bool forceRefresh /* = true */, bool refreshAll /* = false */, const std::string& searchTitle /* = "" */)
+void CLibraryQueue::RefreshItem(CFileItemPtr item,
+                                bool ignoreNfo /* = false */,
+                                bool forceRefresh /* = true */,
+                                bool refreshAll /* = false */,
+                                const std::string& searchTitle /* = "" */)
 {
   AddJob(new CVideoLibraryRefreshingJob(item, forceRefresh, refreshAll, ignoreNfo, searchTitle));
 }
 
-bool CVideoLibraryQueue::RefreshItemModal(CFileItemPtr item, bool forceRefresh /* = true */, bool refreshAll /* = false */)
+bool CLibraryQueue::RefreshItemModal(CFileItemPtr item,
+                                     bool forceRefresh /* = true */,
+                                     bool refreshAll /* = false */)
 {
   // we can't perform a modal library cleaning if other jobs are running
   if (IsRunning())
@@ -134,7 +144,7 @@ bool CVideoLibraryQueue::RefreshItemModal(CFileItemPtr item, bool forceRefresh /
   return result;
 }
 
-void CVideoLibraryQueue::MarkAsWatched(const CFileItemPtr &item, bool watched)
+void CLibraryQueue::MarkAsWatched(const CFileItemPtr& item, bool watched)
 {
   if (item == NULL)
     return;
@@ -142,7 +152,7 @@ void CVideoLibraryQueue::MarkAsWatched(const CFileItemPtr &item, bool watched)
   AddJob(new CVideoLibraryMarkWatchedJob(item, watched));
 }
 
-void CVideoLibraryQueue::ResetResumePoint(const CFileItemPtr item)
+void CLibraryQueue::ResetResumePoint(const CFileItemPtr item)
 {
   if (item == nullptr)
     return;
@@ -150,7 +160,7 @@ void CVideoLibraryQueue::ResetResumePoint(const CFileItemPtr item)
   AddJob(new CVideoLibraryResetResumePointJob(item));
 }
 
-void CVideoLibraryQueue::AddJob(CVideoLibraryJob *job)
+void CLibraryQueue::AddJob(CLibraryJob* job)
 {
   if (job == NULL)
     return;
@@ -161,10 +171,10 @@ void CVideoLibraryQueue::AddJob(CVideoLibraryJob *job)
 
   // add the job to our list of queued/running jobs
   std::string jobType = job->GetType();
-  VideoLibraryJobMap::iterator jobsIt = m_jobs.find(jobType);
+  LibraryJobMap::iterator jobsIt = m_jobs.find(jobType);
   if (jobsIt == m_jobs.end())
   {
-    VideoLibraryJobs jobs;
+    LibraryJobs jobs;
     jobs.insert(job);
     m_jobs.insert(std::make_pair(jobType, jobs));
   }
@@ -172,7 +182,7 @@ void CVideoLibraryQueue::AddJob(CVideoLibraryJob *job)
     jobsIt->second.insert(job);
 }
 
-void CVideoLibraryQueue::CancelJob(CVideoLibraryJob *job)
+void CLibraryQueue::CancelJob(CLibraryJob* job)
 {
   if (job == NULL)
     return;
@@ -192,12 +202,12 @@ void CVideoLibraryQueue::CancelJob(CVideoLibraryJob *job)
   CJobQueue::CancelJob(job);
 
   // remove the job from our list of queued/running jobs
-  VideoLibraryJobMap::iterator jobsIt = m_jobs.find(jobType);
+  LibraryJobMap::iterator jobsIt = m_jobs.find(jobType);
   if (jobsIt != m_jobs.end())
     jobsIt->second.erase(job);
 }
 
-void CVideoLibraryQueue::CancelAllJobs()
+void CLibraryQueue::CancelAllJobs()
 {
   CSingleLock lock(m_critical);
   CJobQueue::CancelJobs();
@@ -206,19 +216,19 @@ void CVideoLibraryQueue::CancelAllJobs()
   m_jobs.clear();
 }
 
-bool CVideoLibraryQueue::IsRunning() const
+bool CLibraryQueue::IsRunning() const
 {
   return CJobQueue::IsProcessing() || m_modal;
 }
 
-void CVideoLibraryQueue::Refresh()
+void CLibraryQueue::Refresh()
 {
   CUtil::DeleteVideoDatabaseDirectoryCache();
   CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE);
   CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msg);
 }
 
-void CVideoLibraryQueue::OnJobComplete(unsigned int jobID, bool success, CJob *job)
+void CLibraryQueue::OnJobComplete(unsigned int jobID, bool success, CJob* job)
 {
   if (success)
   {
@@ -229,9 +239,9 @@ void CVideoLibraryQueue::OnJobComplete(unsigned int jobID, bool success, CJob *j
   {
     CSingleLock lock(m_critical);
     // remove the job from our list of queued/running jobs
-    VideoLibraryJobMap::iterator jobsIt = m_jobs.find(job->GetType());
+    LibraryJobMap::iterator jobsIt = m_jobs.find(job->GetType());
     if (jobsIt != m_jobs.end())
-      jobsIt->second.erase(static_cast<CVideoLibraryJob*>(job));
+      jobsIt->second.erase(static_cast<CLibraryJob*>(job));
   }
 
   return CJobQueue::OnJobComplete(jobID, success, job);
diff --git a/xbmc/video/VideoLibraryQueue.h b/xbmc/LibraryQueue.h
similarity index 56%
rename from xbmc/video/VideoLibraryQueue.h
rename to xbmc/LibraryQueue.h
index 328c132da6fe..d4e6658fef65 100644
--- a/xbmc/video/VideoLibraryQueue.h
+++ b/xbmc/LibraryQueue.h
@@ -16,32 +16,61 @@
 #include <set>
 
 class CGUIDialogProgressBarHandle;
-class CVideoLibraryJob;
 
 /*!
- \brief Queue for video library jobs.
+\brief Basic implementation/interface of a CJob which interacts with a library.
+*/
+class CLibraryJob : public CJob
+{
+public:
+  virtual ~CLibraryJob() {}
+
+  /*!
+  \brief Whether the job can be cancelled or not.
+  */
+  virtual bool CanBeCancelled() const { return false; }
+
+  /*!
+  \brief Tries to cancel the running job.
+
+  \return True if the job was cancelled, false otherwise
+  */
+  virtual bool Cancel() { return false; }
+
+  // implementation of CJob
+  virtual const char* GetType() const { return "LibraryJob"; }
+  virtual bool operator==(const CJob* job) const { return false; }
+
+protected:
+  CLibraryJob() {}
+};
+
+/*!
+ \brief Queue for library jobs.
 
  The queue can only process a single job at any time and every job will be
  executed at the lowest priority.
  */
-class CVideoLibraryQueue : protected CJobQueue
+class CLibraryQueue : protected CJobQueue
 {
 public:
-  ~CVideoLibraryQueue() override;
+  ~CLibraryQueue() override;
 
   /*!
-   \brief Gets the singleton instance of the video library queue.
+   \brief Gets the singleton instance of the library queue.
   */
-  static CVideoLibraryQueue& GetInstance();
+  static CLibraryQueue& GetInstance();
 
   /*!
-   \brief Enqueue a library scan job.
+   \brief Enqueue a video library scan job.
 
    \param[in] directory Directory to scan
    \param[in] scanAll Ignore exclude setting for items. Defaults to false
    \param[in] showProgress Whether or not to show a progress dialog. Defaults to true
    */
-  void ScanLibrary(const std::string& directory, bool scanAll = false, bool showProgress = true);
+  void ScanVideoLibrary(const std::string& directory,
+                        bool scanAll = false,
+                        bool showProgress = true);
 
   /*!
    \brief Check if a library scan is in progress.
@@ -56,20 +85,23 @@ class CVideoLibraryQueue : protected CJobQueue
   void StopLibraryScanning();
 
   /*!
-   \brief Enqueue a library cleaning job.
+   \brief Enqueue a video library cleaning job.
 
    \param[in] paths Set with database IDs of paths to be cleaned
    \param[in] asynchronous Run the clean job asynchronously. Defaults to true
-   \param[in] progressBar Progress bar to update in GUI. Defaults to NULL (no progress bar to update)
+   \param[in] progressBar Progress bar to update in GUI. Defaults to NULL (no progress bar to
+   update)
    */
-  void CleanLibrary(const std::set<int>& paths = std::set<int>(), bool asynchronous = true, CGUIDialogProgressBarHandle* progressBar = NULL);
+  void CleanVideoLibrary(const std::set<int>& paths = std::set<int>(),
+                         bool asynchronous = true,
+                         CGUIDialogProgressBarHandle* progressBar = NULL);
 
   /*!
-  \brief Executes a library cleaning with a modal dialog.
+  \brief Executes a video library cleaning with a modal dialog.
 
   \param[in] paths Set with database IDs of paths to be cleaned
   */
-  void CleanLibraryModal(const std::set<int>& paths = std::set<int>());
+  void CleanVideoLibraryModal(const std::set<int>& paths = std::set<int>());
 
   /*!
    \brief Enqueues a job to refresh the details of the given item.
@@ -78,9 +110,14 @@ class CVideoLibraryQueue : protected CJobQueue
    \param[in] ignoreNfo Whether or not to ignore local NFO files
    \param[in] forceRefresh Whether to force a complete refresh (including NFO or internet lookup)
    \param[in] refreshAll Whether to refresh all sub-items (in case of a tvshow)
-   \param[in] searchTitle Title to use for the search (instead of determining it from the item's filename/path)
+   \param[in] searchTitle Title to use for the search (instead of determining it from the item's
+   filename/path)
    */
-  void RefreshItem(CFileItemPtr item, bool ignoreNfo = false, bool forceRefresh = true, bool refreshAll = false, const std::string& searchTitle = "");
+  void RefreshItem(CFileItemPtr item,
+                   bool ignoreNfo = false,
+                   bool forceRefresh = true,
+                   bool refreshAll = false,
+                   const std::string& searchTitle = "");
 
   /*!
    \brief Refreshes the details of the given item with a modal dialog.
@@ -98,7 +135,7 @@ class CVideoLibraryQueue : protected CJobQueue
    \param[in] item Item to update watched status for
    \param[in] watched New watched status
    */
-  void MarkAsWatched(const CFileItemPtr &item, bool watched);
+  void MarkAsWatched(const CFileItemPtr& item, bool watched);
 
   /*!
    \brief Queue a reset resume point job.
@@ -110,16 +147,16 @@ class CVideoLibraryQueue : protected CJobQueue
   /*!
    \brief Adds the given job to the queue.
 
-   \param[in] job Video library job to be queued.
+   \param[in] job Library job to be queued.
    */
-  void AddJob(CVideoLibraryJob *job);
+  void AddJob(CLibraryJob* job);
 
   /*!
    \brief Cancels the given job and removes it from the queue.
 
-   \param[in] job Video library job to be canceled and removed from the queue.
+   \param[in] job Library job to be canceled and removed from the queue.
    */
-  void CancelJob(CVideoLibraryJob *job);
+  void CancelJob(CLibraryJob* job);
 
   /*!
    \brief Cancels all running and queued jobs.
@@ -133,7 +170,7 @@ class CVideoLibraryQueue : protected CJobQueue
 
 protected:
   // implementation of IJobCallback
-  void OnJobComplete(unsigned int jobID, bool success, CJob *job) override;
+  void OnJobComplete(unsigned int jobID, bool success, CJob* job) override;
 
   /*!
    \brief Notifies all to refresh the current listings.
@@ -141,13 +178,13 @@ class CVideoLibraryQueue : protected CJobQueue
   void Refresh();
 
 private:
-  CVideoLibraryQueue();
-  CVideoLibraryQueue(const CVideoLibraryQueue&) = delete;
-  CVideoLibraryQueue const& operator=(CVideoLibraryQueue const&) = delete;
+  CLibraryQueue();
+  CLibraryQueue(const CLibraryQueue&) = delete;
+  CLibraryQueue const& operator=(CLibraryQueue const&) = delete;
 
-  typedef std::set<CVideoLibraryJob*> VideoLibraryJobs;
-  typedef std::map<std::string, VideoLibraryJobs> VideoLibraryJobMap;
-  VideoLibraryJobMap m_jobs;
+  typedef std::set<CLibraryJob*> LibraryJobs;
+  typedef std::map<std::string, LibraryJobs> LibraryJobMap;
+  LibraryJobMap m_jobs;
   CCriticalSection m_critical;
 
   bool m_modal = false;
diff --git a/xbmc/interfaces/json-rpc/VideoLibrary.cpp b/xbmc/interfaces/json-rpc/VideoLibrary.cpp
index fa3de223f85a..a0d838bed9d3 100644
--- a/xbmc/interfaces/json-rpc/VideoLibrary.cpp
+++ b/xbmc/interfaces/json-rpc/VideoLibrary.cpp
@@ -8,6 +8,7 @@
 
 #include "VideoLibrary.h"
 
+#include "LibraryQueue.h"
 #include "TextureDatabase.h"
 #include "Util.h"
 #include "messaging/ApplicationMessenger.h"
@@ -16,7 +17,6 @@
 #include "utils/URIUtils.h"
 #include "utils/Variant.h"
 #include "video/VideoDatabase.h"
-#include "video/VideoLibraryQueue.h"
 
 using namespace JSONRPC;
 using namespace KODI::MESSAGING;
@@ -777,7 +777,8 @@ JSONRPC_STATUS CVideoLibrary::RefreshMovie(const std::string &method, ITransport
 
   bool ignoreNfo = parameterObject["ignorenfo"].asBoolean();
   std::string searchTitle = parameterObject["title"].asString();
-  CVideoLibraryQueue::GetInstance().RefreshItem(CFileItemPtr(new CFileItem(infos)), ignoreNfo, true, false, searchTitle);
+  CLibraryQueue::GetInstance().RefreshItem(CFileItemPtr(new CFileItem(infos)), ignoreNfo, true,
+                                           false, searchTitle);
 
   return ACK;
 }
@@ -800,7 +801,7 @@ JSONRPC_STATUS CVideoLibrary::RefreshTVShow(const std::string &method, ITranspor
   bool ignoreNfo = parameterObject["ignorenfo"].asBoolean();
   bool refreshEpisodes = parameterObject["refreshepisodes"].asBoolean();
   std::string searchTitle = parameterObject["title"].asString();
-  CVideoLibraryQueue::GetInstance().RefreshItem(item, ignoreNfo, true, refreshEpisodes, searchTitle);
+  CLibraryQueue::GetInstance().RefreshItem(item, ignoreNfo, true, refreshEpisodes, searchTitle);
 
   return ACK;
 }
@@ -825,7 +826,7 @@ JSONRPC_STATUS CVideoLibrary::RefreshEpisode(const std::string &method, ITranspo
 
   bool ignoreNfo = parameterObject["ignorenfo"].asBoolean();
   std::string searchTitle = parameterObject["title"].asString();
-  CVideoLibraryQueue::GetInstance().RefreshItem(item, ignoreNfo, true, false, searchTitle);
+  CLibraryQueue::GetInstance().RefreshItem(item, ignoreNfo, true, false, searchTitle);
 
   return ACK;
 }
@@ -844,7 +845,8 @@ JSONRPC_STATUS CVideoLibrary::RefreshMusicVideo(const std::string &method, ITran
 
   bool ignoreNfo = parameterObject["ignorenfo"].asBoolean();
   std::string searchTitle = parameterObject["title"].asString();
-  CVideoLibraryQueue::GetInstance().RefreshItem(CFileItemPtr(new CFileItem(infos)), ignoreNfo, true, false, searchTitle);
+  CLibraryQueue::GetInstance().RefreshItem(CFileItemPtr(new CFileItem(infos)), ignoreNfo, true,
+                                           false, searchTitle);
 
   return ACK;
 }
diff --git a/xbmc/profiles/ProfileManager.cpp b/xbmc/profiles/ProfileManager.cpp
index 14fbc3766332..560df866c899 100644
--- a/xbmc/profiles/ProfileManager.cpp
+++ b/xbmc/profiles/ProfileManager.cpp
@@ -15,6 +15,7 @@
 #include "FileItem.h"
 #include "GUIInfoManager.h"
 #include "GUIPassword.h"
+#include "LibraryQueue.h"
 #include "PasswordManager.h"
 #include "ServiceBroker.h"
 #include "Util.h"
@@ -53,7 +54,6 @@
 #include "network/Network.h" //! @todo Remove me
 #include "network/NetworkServices.h" //! @todo Remove me
 #include "pvr/PVRManager.h" //! @todo Remove me
-#include "video/VideoLibraryQueue.h"//! @todo Remove me
 #include "weather/WeatherManager.h" //! @todo Remove me
 #include "Application.h" //! @todo Remove me
 #include "ContextMenuManager.h" //! @todo Remove me
@@ -441,8 +441,8 @@ void CProfileManager::LogOff()
   if (g_application.IsMusicScanning())
     g_application.StopMusicScan();
 
-  if (CVideoLibraryQueue::GetInstance().IsRunning())
-    CVideoLibraryQueue::GetInstance().CancelAllJobs();
+  if (CLibraryQueue::GetInstance().IsRunning())
+    CLibraryQueue::GetInstance().CancelAllJobs();
 
   // Stop PVR services
   CServiceBroker::GetPVRManager().Stop();
diff --git a/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp b/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
index 3abec4f8100d..85ea5399bd2c 100644
--- a/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
@@ -9,6 +9,7 @@
 #include "GUIWindowPVRRecordings.h"
 
 #include "GUIInfoManager.h"
+#include "LibraryQueue.h"
 #include "ServiceBroker.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIMessage.h"
@@ -27,7 +28,6 @@
 #include "settings/SettingsComponent.h"
 #include "threads/SingleLock.h"
 #include "utils/URIUtils.h"
-#include "video/VideoLibraryQueue.h"
 #include "video/windows/GUIWindowVideoNav.h"
 
 #include <memory>
@@ -114,7 +114,7 @@ bool CGUIWindowPVRRecordingsBase::OnAction(const CAction& action)
     else
       return false;
 
-    CVideoLibraryQueue::GetInstance().MarkAsWatched(pItem, bUnWatched);
+    CLibraryQueue::GetInstance().MarkAsWatched(pItem, bUnWatched);
     return true;
   }
 
diff --git a/xbmc/video/CMakeLists.txt b/xbmc/video/CMakeLists.txt
index 4cb7944725ac..8b5d9528ae25 100644
--- a/xbmc/video/CMakeLists.txt
+++ b/xbmc/video/CMakeLists.txt
@@ -8,7 +8,6 @@ set(SOURCES Bookmark.cpp
             VideoInfoDownloader.cpp
             VideoInfoScanner.cpp
             VideoInfoTag.cpp
-            VideoLibraryQueue.cpp
             VideoThumbLoader.cpp
             ViewModeSettings.cpp)
 
@@ -24,7 +23,6 @@ set(HEADERS Bookmark.h
             VideoInfoDownloader.h
             VideoInfoScanner.h
             VideoInfoTag.h
-            VideoLibraryQueue.h
             VideoThumbLoader.h
             ViewModeSettings.h)
 
diff --git a/xbmc/video/ContextMenus.cpp b/xbmc/video/ContextMenus.cpp
index c7097b633342..24f5120d99dd 100644
--- a/xbmc/video/ContextMenus.cpp
+++ b/xbmc/video/ContextMenus.cpp
@@ -10,6 +10,7 @@
 
 #include "Application.h"
 #include "Autorun.h"
+#include "LibraryQueue.h"
 #include "ServiceBroker.h"
 #include "filesystem/Directory.h"
 #include "guilib/GUIComponent.h"
@@ -55,7 +56,7 @@ bool CRemoveResumePoint::IsVisible(const CFileItem& itemIn) const
 
 bool CRemoveResumePoint::Execute(const CFileItemPtr& item) const
 {
-  CVideoLibraryQueue::GetInstance().ResetResumePoint(item);
+  CLibraryQueue::GetInstance().ResetResumePoint(item);
   return true;
 }
 
@@ -81,7 +82,7 @@ bool CMarkWatched::IsVisible(const CFileItem& item) const
 
 bool CMarkWatched::Execute(const CFileItemPtr& item) const
 {
-  CVideoLibraryQueue::GetInstance().MarkAsWatched(item, true);
+  CLibraryQueue::GetInstance().MarkAsWatched(item, true);
   return true;
 }
 
@@ -107,7 +108,7 @@ bool CMarkUnWatched::IsVisible(const CFileItem& item) const
 
 bool CMarkUnWatched::Execute(const CFileItemPtr& item) const
 {
-  CVideoLibraryQueue::GetInstance().MarkAsWatched(item, false);
+  CLibraryQueue::GetInstance().MarkAsWatched(item, false);
   return true;
 }
 
diff --git a/xbmc/video/ContextMenus.h b/xbmc/video/ContextMenus.h
index f000f5246cb9..875d2c9cea9b 100644
--- a/xbmc/video/ContextMenus.h
+++ b/xbmc/video/ContextMenus.h
@@ -9,7 +9,6 @@
 #pragma once
 
 #include "ContextMenuItem.h"
-#include "VideoLibraryQueue.h"
 
 namespace CONTEXTMENU
 {
diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index 96281ea4a315..c4dd7837413b 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -11,6 +11,7 @@
 #include "FileItem.h"
 #include "GUIInfoManager.h"
 #include "GUIUserMessages.h"
+#include "LibraryQueue.h"
 #include "NfoFile.h"
 #include "ServiceBroker.h"
 #include "TextureCache.h"
@@ -44,7 +45,6 @@
 #include "utils/URIUtils.h"
 #include "utils/Variant.h"
 #include "utils/log.h"
-#include "video/VideoLibraryQueue.h"
 #include "video/VideoThumbLoader.h"
 
 #include <algorithm>
@@ -87,7 +87,7 @@ namespace VIDEO
       if (m_bClean && m_pathsToScan.empty())
       {
         std::set<int> paths;
-        CVideoLibraryQueue::GetInstance().CleanLibrary(paths, false, m_handle);
+        CLibraryQueue::GetInstance().CleanVideoLibrary(paths, false, m_handle);
 
         if (m_handle)
           m_handle->MarkFinished();
@@ -143,7 +143,7 @@ namespace VIDEO
       if (!bCancelled)
       {
         if (m_bClean)
-          CVideoLibraryQueue::GetInstance().CleanLibrary(m_pathsToClean, false, m_handle);
+          CLibraryQueue::GetInstance().CleanVideoLibrary(m_pathsToClean, false, m_handle);
         else
         {
           if (m_handle)
diff --git a/xbmc/video/jobs/VideoLibraryJob.h b/xbmc/video/jobs/VideoLibraryJob.h
index a8f7851b4a52..acabc1997e08 100644
--- a/xbmc/video/jobs/VideoLibraryJob.h
+++ b/xbmc/video/jobs/VideoLibraryJob.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "utils/Job.h"
+#include "LibraryQueue.h"
 
 class CVideoDatabase;
 
@@ -16,23 +16,11 @@ class CVideoDatabase;
  \brief Basic implementation/interface of a CJob which interacts with the
  video database.
  */
-class CVideoLibraryJob : public CJob
+class CVideoLibraryJob : public CLibraryJob
 {
 public:
   ~CVideoLibraryJob() override;
 
-  /*!
-   \brief Whether the job can be cancelled or not.
-   */
-  virtual bool CanBeCancelled() const { return false; }
-
-  /*!
-   \brief Tries to cancel the running job.
-
-   \return True if the job was cancelled, false otherwise
-  */
-  virtual bool Cancel() { return false; }
-
   // implementation of CJob
   bool DoWork() override;
   const char *GetType() const override { return "VideoLibraryJob"; }
diff --git a/xbmc/video/windows/GUIWindowVideoBase.cpp b/xbmc/video/windows/GUIWindowVideoBase.cpp
index b337d3e0ca8e..6664c735cc81 100644
--- a/xbmc/video/windows/GUIWindowVideoBase.cpp
+++ b/xbmc/video/windows/GUIWindowVideoBase.cpp
@@ -12,6 +12,7 @@
 #include "Autorun.h"
 #include "GUIPassword.h"
 #include "GUIUserMessages.h"
+#include "LibraryQueue.h"
 #include "PartyModeManager.h"
 #include "PlayListPlayer.h"
 #include "ServiceBroker.h"
@@ -51,7 +52,6 @@
 #include "utils/log.h"
 #include "video/VideoInfoDownloader.h"
 #include "video/VideoInfoScanner.h"
-#include "video/VideoLibraryQueue.h"
 #include "video/dialogs/GUIDialogVideoInfo.h"
 #include "view/GUIViewState.h"
 
@@ -436,7 +436,7 @@ bool CGUIWindowVideoBase::ShowIMDB(CFileItemPtr item, const ScraperPtr &info2, b
   // 3. Run a loop so that if we Refresh we re-run this block
   do
   {
-    if (!CVideoLibraryQueue::GetInstance().RefreshItemModal(item, needsRefresh, pDlgInfo->RefreshAll()))
+    if (!CLibraryQueue::GetInstance().RefreshItemModal(item, needsRefresh, pDlgInfo->RefreshAll()))
       return listNeedsUpdating;
 
     // remove directory caches and reload images
diff --git a/xbmc/video/windows/GUIWindowVideoNav.cpp b/xbmc/video/windows/GUIWindowVideoNav.cpp
index a59f00903ee6..555338b86676 100644
--- a/xbmc/video/windows/GUIWindowVideoNav.cpp
+++ b/xbmc/video/windows/GUIWindowVideoNav.cpp
@@ -11,6 +11,7 @@
 #include "Application.h"
 #include "FileItem.h"
 #include "GUIPassword.h"
+#include "LibraryQueue.h"
 #include "PartyModeManager.h"
 #include "ServiceBroker.h"
 #include "Util.h"
@@ -41,7 +42,6 @@
 #include "utils/Variant.h"
 #include "utils/log.h"
 #include "video/VideoInfoScanner.h"
-#include "video/VideoLibraryQueue.h"
 #include "video/dialogs/GUIDialogVideoInfo.h"
 #include "view/GUIViewState.h"
 
@@ -86,7 +86,8 @@ bool CGUIWindowVideoNav::OnAction(const CAction &action)
 
     if (pItem && pItem->HasVideoInfoTag())
     {
-      CVideoLibraryQueue::GetInstance().MarkAsWatched(pItem, pItem->GetVideoInfoTag()->GetPlayCount() == 0);
+      CLibraryQueue::GetInstance().MarkAsWatched(pItem,
+                                                 pItem->GetVideoInfoTag()->GetPlayCount() == 0);
       return true;
     }
   }

From aeb23fa383affb03627453e7e80626338619183c Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Fri, 13 Mar 2015 11:02:42 +0100
Subject: [PATCH 30/88] [library] CLibraryQueue: allow to provide an additional
 IJobCallback callback

---
 xbmc/LibraryQueue.cpp | 40 +++++++++++++++++++++++++++++++++++++---
 xbmc/LibraryQueue.h   |  8 +++++++-
 2 files changed, 44 insertions(+), 4 deletions(-)

diff --git a/xbmc/LibraryQueue.cpp b/xbmc/LibraryQueue.cpp
index 07a460764d81..4ddd32054088 100644
--- a/xbmc/LibraryQueue.cpp
+++ b/xbmc/LibraryQueue.cpp
@@ -31,6 +31,7 @@ CLibraryQueue::~CLibraryQueue()
 {
   CSingleLock lock(m_critical);
   m_jobs.clear();
+  m_callbacks.clear();
 }
 
 CLibraryQueue& CLibraryQueue::GetInstance()
@@ -160,7 +161,7 @@ void CLibraryQueue::ResetResumePoint(const CFileItemPtr item)
   AddJob(new CVideoLibraryResetResumePointJob(item));
 }
 
-void CLibraryQueue::AddJob(CLibraryJob* job)
+void CLibraryQueue::AddJob(CLibraryJob* job, IJobCallback* callback /* = nullptr */)
 {
   if (job == NULL)
     return;
@@ -180,6 +181,10 @@ void CLibraryQueue::AddJob(CLibraryJob* job)
   }
   else
     jobsIt->second.insert(job);
+
+  // if there's a specific callback, add it to the callback map
+  if (callback != NULL)
+    m_callbacks.insert(std::make_pair(job, callback));
 }
 
 void CLibraryQueue::CancelJob(CLibraryJob* job)
@@ -205,6 +210,9 @@ void CLibraryQueue::CancelJob(CLibraryJob* job)
   LibraryJobMap::iterator jobsIt = m_jobs.find(jobType);
   if (jobsIt != m_jobs.end())
     jobsIt->second.erase(job);
+
+  // remove the job (and its callback) from the callback map
+  m_callbacks.erase(job);
 }
 
 void CLibraryQueue::CancelAllJobs()
@@ -212,8 +220,9 @@ void CLibraryQueue::CancelAllJobs()
   CSingleLock lock(m_critical);
   CJobQueue::CancelJobs();
 
-  // remove all scanning jobs
+  // remove all jobs
   m_jobs.clear();
+  m_callbacks.clear();
 }
 
 bool CLibraryQueue::IsRunning() const
@@ -228,6 +237,23 @@ void CLibraryQueue::Refresh()
   CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msg);
 }
 
+void CLibraryQueue::OnJobProgress(unsigned int jobID,
+                                  unsigned int progress,
+                                  unsigned int total,
+                                  const CJob* job)
+{
+  if (job == NULL)
+    return;
+
+  // check if we need to call a specific callback
+  LibraryJobCallbacks::iterator callback = m_callbacks.find(static_cast<const CLibraryJob*>(job));
+  if (callback != m_callbacks.end())
+    callback->second->OnJobProgress(jobID, progress, total, job);
+
+  // let the generic job queue do its work
+  CJobQueue::OnJobProgress(jobID, progress, total, job);
+}
+
 void CLibraryQueue::OnJobComplete(unsigned int jobID, bool success, CJob* job)
 {
   if (success)
@@ -238,11 +264,19 @@ void CLibraryQueue::OnJobComplete(unsigned int jobID, bool success, CJob* job)
 
   {
     CSingleLock lock(m_critical);
+    CLibraryJob* libraryJob = static_cast<CLibraryJob*>(job);
+
+    // check if we need to call a specific callback
+    LibraryJobCallbacks::iterator callback = m_callbacks.find(libraryJob);
+    if (callback != m_callbacks.end())
+      callback->second->OnJobComplete(jobID, success, job);
+
     // remove the job from our list of queued/running jobs
     LibraryJobMap::iterator jobsIt = m_jobs.find(job->GetType());
     if (jobsIt != m_jobs.end())
-      jobsIt->second.erase(static_cast<CLibraryJob*>(job));
+      jobsIt->second.erase(libraryJob);
   }
 
+  // let the generic job queue do its work
   return CJobQueue::OnJobComplete(jobID, success, job);
 }
diff --git a/xbmc/LibraryQueue.h b/xbmc/LibraryQueue.h
index d4e6658fef65..db286f950c07 100644
--- a/xbmc/LibraryQueue.h
+++ b/xbmc/LibraryQueue.h
@@ -149,7 +149,7 @@ class CLibraryQueue : protected CJobQueue
 
    \param[in] job Library job to be queued.
    */
-  void AddJob(CLibraryJob* job);
+  void AddJob(CLibraryJob* job, IJobCallback* callback = nullptr);
 
   /*!
    \brief Cancels the given job and removes it from the queue.
@@ -170,6 +170,10 @@ class CLibraryQueue : protected CJobQueue
 
 protected:
   // implementation of IJobCallback
+  void OnJobProgress(unsigned int jobID,
+                     unsigned int progress,
+                     unsigned int total,
+                     const CJob* job) override;
   void OnJobComplete(unsigned int jobID, bool success, CJob* job) override;
 
   /*!
@@ -185,6 +189,8 @@ class CLibraryQueue : protected CJobQueue
   typedef std::set<CLibraryJob*> LibraryJobs;
   typedef std::map<std::string, LibraryJobs> LibraryJobMap;
   LibraryJobMap m_jobs;
+  typedef std::map<const CLibraryJob*, IJobCallback*> LibraryJobCallbacks;
+  LibraryJobCallbacks m_callbacks;
   CCriticalSection m_critical;
 
   bool m_modal = false;

From 39c82271799a82623ab84095263f5c03e7e169ee Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 30 Oct 2016 12:06:09 +0100
Subject: [PATCH 31/88] [media] cleanup CMediaTypes

---
 xbmc/media/MediaType.cpp | 33 +++++++++++++--------------------
 xbmc/media/MediaType.h   | 20 ++++++++++----------
 2 files changed, 23 insertions(+), 30 deletions(-)

diff --git a/xbmc/media/MediaType.cpp b/xbmc/media/MediaType.cpp
index 0f1a86aab2d2..4a60b1adb615 100644
--- a/xbmc/media/MediaType.cpp
+++ b/xbmc/media/MediaType.cpp
@@ -15,26 +15,19 @@
 
 static const std::string MediaTypeStringSeparator = ",";
 
-static std::map<std::string, CMediaTypes::MediaTypeInfo> fillDefaultMediaTypes()
-{
-  std::map<std::string, CMediaTypes::MediaTypeInfo> mediaTypes;
-
-  mediaTypes.insert(std::make_pair(MediaTypeMusic,            CMediaTypes::MediaTypeInfo(MediaTypeMusic,           MediaTypeMusic,               true,  36914, 36915,   249,   249)));
-  mediaTypes.insert(std::make_pair(MediaTypeArtist,           CMediaTypes::MediaTypeInfo(MediaTypeArtist,          MediaTypeArtist "s",          true,  36916, 36917,   557,   133)));
-  mediaTypes.insert(std::make_pair(MediaTypeAlbum,            CMediaTypes::MediaTypeInfo(MediaTypeAlbum,           MediaTypeAlbum "s",           true,  36918, 36919,   558,   132)));
-  mediaTypes.insert(std::make_pair(MediaTypeSong,             CMediaTypes::MediaTypeInfo(MediaTypeSong,            MediaTypeSong "s",            false, 36920, 36921,   172,   134)));
-  mediaTypes.insert(std::make_pair(MediaTypeVideo,            CMediaTypes::MediaTypeInfo(MediaTypeVideo,           MediaTypeVideo "s",           true,  36912, 36913,   291,     3)));
-  mediaTypes.insert(std::make_pair(MediaTypeVideoCollection,  CMediaTypes::MediaTypeInfo(MediaTypeVideoCollection, MediaTypeVideoCollection "s", true,  36910, 36911, 20141, 20434)));
-  mediaTypes.insert(std::make_pair(MediaTypeMusicVideo,       CMediaTypes::MediaTypeInfo(MediaTypeMusicVideo,      MediaTypeMusicVideo "s",      false, 36908, 36909, 20391, 20389)));
-  mediaTypes.insert(std::make_pair(MediaTypeMovie,            CMediaTypes::MediaTypeInfo(MediaTypeMovie,           MediaTypeMovie "s",           false, 36900, 36901, 20338, 20342)));
-  mediaTypes.insert(std::make_pair(MediaTypeTvShow,           CMediaTypes::MediaTypeInfo(MediaTypeTvShow,          MediaTypeTvShow "s",          true,  36902, 36903, 36902, 36903)));
-  mediaTypes.insert(std::make_pair(MediaTypeSeason,           CMediaTypes::MediaTypeInfo(MediaTypeSeason,          MediaTypeSeason "s",          true,  36904, 36905, 20373, 33054)));
-  mediaTypes.insert(std::make_pair(MediaTypeEpisode,          CMediaTypes::MediaTypeInfo(MediaTypeEpisode,         MediaTypeEpisode "s",         false, 36906, 36907, 20359, 20360)));
-
-  return mediaTypes;
-}
-
-std::map<std::string, CMediaTypes::MediaTypeInfo> CMediaTypes::m_mediaTypes = fillDefaultMediaTypes();
+std::map<std::string, CMediaTypes::MediaTypeInfo> CMediaTypes::m_mediaTypes = {
+  std::make_pair(MediaTypeMusic,            CMediaTypes::MediaTypeInfo(MediaTypeMusic,           MediaTypeMusic,               true,  36914, 36915,   249,   249)),
+  std::make_pair(MediaTypeArtist,           CMediaTypes::MediaTypeInfo(MediaTypeArtist,          MediaTypeArtist "s",          true,  36916, 36917,   557,   133)),
+  std::make_pair(MediaTypeAlbum,            CMediaTypes::MediaTypeInfo(MediaTypeAlbum,           MediaTypeAlbum "s",           true,  36918, 36919,   558,   132)),
+  std::make_pair(MediaTypeSong,             CMediaTypes::MediaTypeInfo(MediaTypeSong,            MediaTypeSong "s",            false, 36920, 36921,   172,   134)),
+  std::make_pair(MediaTypeVideo,            CMediaTypes::MediaTypeInfo(MediaTypeVideo,           MediaTypeVideo "s",           true,  36912, 36913,   291,     3)),
+  std::make_pair(MediaTypeVideoCollection,  CMediaTypes::MediaTypeInfo(MediaTypeVideoCollection, MediaTypeVideoCollection "s", true,  36910, 36911, 20141, 20434)),
+  std::make_pair(MediaTypeMusicVideo,       CMediaTypes::MediaTypeInfo(MediaTypeMusicVideo,      MediaTypeMusicVideo "s",      false, 36908, 36909, 20391, 20389)),
+  std::make_pair(MediaTypeMovie,            CMediaTypes::MediaTypeInfo(MediaTypeMovie,           MediaTypeMovie "s",           false, 36900, 36901, 20338, 20342)),
+  std::make_pair(MediaTypeTvShow,           CMediaTypes::MediaTypeInfo(MediaTypeTvShow,          MediaTypeTvShow "s",          true,  36902, 36903, 36902, 36903)),
+  std::make_pair(MediaTypeSeason,           CMediaTypes::MediaTypeInfo(MediaTypeSeason,          MediaTypeSeason "s",          true,  36904, 36905, 20373, 33054)),
+  std::make_pair(MediaTypeEpisode,          CMediaTypes::MediaTypeInfo(MediaTypeEpisode,         MediaTypeEpisode "s",         false, 36906, 36907, 20359, 20360))
+};
 
 bool CMediaTypes::IsValidMediaType(const MediaType &mediaType)
 {
diff --git a/xbmc/media/MediaType.h b/xbmc/media/MediaType.h
index 90679d7bc4e2..0405d7799119 100644
--- a/xbmc/media/MediaType.h
+++ b/xbmc/media/MediaType.h
@@ -49,17 +49,18 @@ class CMediaTypes
   static std::string Join(const GroupedMediaTypes& mediaTypes);
   static GroupedMediaTypes Split(const std::string& mediaTypes);
 
+private:
   typedef struct MediaTypeInfo {
     MediaTypeInfo(const MediaType &mediaType, const std::string &plural, bool container,
-                  int localizationSingular, int localizationPlural,
-                  int localizationSingularCapital, int localizationPluralCapital)
-      : mediaType(mediaType),
-        plural(plural),
-        container(container),
-        localizationSingular(localizationSingular),
-        localizationPlural(localizationPlural),
-        localizationSingularCapital(localizationSingularCapital),
-        localizationPluralCapital(localizationPluralCapital)
+      int localizationSingular, int localizationPlural,
+      int localizationSingularCapital, int localizationPluralCapital)
+      : mediaType(mediaType)
+      , plural(plural)
+      , container(container)
+      , localizationSingular(localizationSingular)
+      , localizationPlural(localizationPlural)
+      , localizationSingularCapital(localizationSingularCapital)
+      , localizationPluralCapital(localizationPluralCapital)
     { }
 
     MediaType mediaType;
@@ -71,7 +72,6 @@ class CMediaTypes
     int localizationPluralCapital;
   } MediaTypeInfo;
 
-private:
   static std::map<std::string, MediaTypeInfo>::const_iterator findMediaType(const std::string &mediaType);
 
   static std::map<std::string, MediaTypeInfo> m_mediaTypes;

From 5c826f42a7d9aedd3a7ddaa08e6dba0b2d2e62e0 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 30 Oct 2016 12:29:48 +0100
Subject: [PATCH 32/88] [media] CMediaTypes: add ToLabel()

---
 xbmc/media/MediaType.cpp | 8 ++++++++
 xbmc/media/MediaType.h   | 2 ++
 2 files changed, 10 insertions(+)

diff --git a/xbmc/media/MediaType.cpp b/xbmc/media/MediaType.cpp
index 4a60b1adb615..d32fb8373795 100644
--- a/xbmc/media/MediaType.cpp
+++ b/xbmc/media/MediaType.cpp
@@ -142,3 +142,11 @@ GroupedMediaTypes CMediaTypes::Split(const std::string& mediaTypes)
 {
   return StringUtils::Split(mediaTypes, MediaTypeStringSeparator);
 }
+
+std::string CMediaTypes::ToLabel(const GroupedMediaTypes& mediaTypes)
+{
+  if (mediaTypes.empty())
+    return "";
+
+  return GetCapitalPluralLocalization(mediaTypes.front());
+}
diff --git a/xbmc/media/MediaType.h b/xbmc/media/MediaType.h
index 0405d7799119..5ec002d19b73 100644
--- a/xbmc/media/MediaType.h
+++ b/xbmc/media/MediaType.h
@@ -49,6 +49,8 @@ class CMediaTypes
   static std::string Join(const GroupedMediaTypes& mediaTypes);
   static GroupedMediaTypes Split(const std::string& mediaTypes);
 
+  static std::string ToLabel(const GroupedMediaTypes& mediaTypes);
+
 private:
   typedef struct MediaTypeInfo {
     MediaTypeInfo(const MediaType &mediaType, const std::string &plural, bool container,

From 888fbb6f1dd1854a245736259b3b549f71d99c02 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 28 Dec 2019 22:25:08 +0100
Subject: [PATCH 33/88] [media import] add structure and logic for importing
 media items

---
 .../resources/strings.po                      |   59 +
 cmake/treedata/common/media.txt               |    2 +
 xbmc/Application.cpp                          |    3 +
 xbmc/GUIUserMessages.h                        |    9 +
 xbmc/ServiceBroker.cpp                        |    5 +
 xbmc/ServiceBroker.h                          |    2 +
 xbmc/ServiceManager.cpp                       |   11 +
 xbmc/ServiceManager.h                         |    4 +
 xbmc/media/import/CMakeLists.txt              |   10 +-
 xbmc/media/import/IMediaImportHandler.h       |  195 ++
 .../media/import/IMediaImportHandlerManager.h |   37 +
 xbmc/media/import/IMediaImportRepository.h    |  163 ++
 xbmc/media/import/IMediaImporter.h            |  299 +++
 xbmc/media/import/IMediaImporterManager.h     |   50 +
 xbmc/media/import/MediaImportChangesetTypes.h |   22 +
 xbmc/media/import/MediaImportManager.cpp      | 2334 +++++++++++++++++
 xbmc/media/import/MediaImportManager.h        |  686 +++++
 xbmc/media/import/jobs/CMakeLists.txt         |   13 +
 .../jobs/MediaImportSourceActivationJob.h     |   25 +
 .../import/jobs/MediaImportSourceJobBase.cpp  |   36 +
 .../import/jobs/MediaImportSourceJobBase.h    |   35 +
 .../import/jobs/MediaImportSourceReadyJob.cpp |   55 +
 .../import/jobs/MediaImportSourceReadyJob.h   |   39 +
 .../jobs/MediaImportSourceRegistrationJob.cpp |   35 +
 .../jobs/MediaImportSourceRegistrationJob.h   |   31 +
 .../jobs/MediaImportTaskProcessorJob.cpp      |  717 +++++
 .../import/jobs/MediaImportTaskProcessorJob.h |  138 +
 xbmc/media/import/jobs/MediaImportTaskTypes.h |   58 +
 xbmc/media/import/jobs/tasks/CMakeLists.txt   |   19 +
 .../import/jobs/tasks/IMediaImportTask.cpp    |   52 +
 .../import/jobs/tasks/IMediaImportTask.h      |  126 +
 .../jobs/tasks/MediaImportChangesetTask.cpp   |  144 +
 .../jobs/tasks/MediaImportChangesetTask.h     |   39 +
 .../jobs/tasks/MediaImportCleanupTask.cpp     |   47 +
 .../jobs/tasks/MediaImportCleanupTask.h       |   26 +
 .../MediaImportImportItemsRetrievalTask.cpp   |  109 +
 .../MediaImportImportItemsRetrievalTask.h     |  114 +
 .../MediaImportLocalItemsRetrievalTask.cpp    |   54 +
 .../MediaImportLocalItemsRetrievalTask.h      |   48 +
 .../jobs/tasks/MediaImportRemovalTask.cpp     |   41 +
 .../jobs/tasks/MediaImportRemovalTask.h       |   26 +
 .../tasks/MediaImportSynchronisationTask.cpp  |  108 +
 .../tasks/MediaImportSynchronisationTask.h    |   36 +
 .../jobs/tasks/MediaImportUpdateTask.cpp      |   48 +
 .../import/jobs/tasks/MediaImportUpdateTask.h |   41 +
 xbmc/utils/JobManager.h                       |    2 +-
 46 files changed, 6151 insertions(+), 2 deletions(-)
 create mode 100644 xbmc/media/import/IMediaImportHandler.h
 create mode 100644 xbmc/media/import/IMediaImportHandlerManager.h
 create mode 100644 xbmc/media/import/IMediaImportRepository.h
 create mode 100644 xbmc/media/import/IMediaImporter.h
 create mode 100644 xbmc/media/import/IMediaImporterManager.h
 create mode 100644 xbmc/media/import/MediaImportChangesetTypes.h
 create mode 100644 xbmc/media/import/MediaImportManager.cpp
 create mode 100644 xbmc/media/import/MediaImportManager.h
 create mode 100644 xbmc/media/import/jobs/CMakeLists.txt
 create mode 100644 xbmc/media/import/jobs/MediaImportSourceActivationJob.h
 create mode 100644 xbmc/media/import/jobs/MediaImportSourceJobBase.cpp
 create mode 100644 xbmc/media/import/jobs/MediaImportSourceJobBase.h
 create mode 100644 xbmc/media/import/jobs/MediaImportSourceReadyJob.cpp
 create mode 100644 xbmc/media/import/jobs/MediaImportSourceReadyJob.h
 create mode 100644 xbmc/media/import/jobs/MediaImportSourceRegistrationJob.cpp
 create mode 100644 xbmc/media/import/jobs/MediaImportSourceRegistrationJob.h
 create mode 100644 xbmc/media/import/jobs/MediaImportTaskProcessorJob.cpp
 create mode 100644 xbmc/media/import/jobs/MediaImportTaskProcessorJob.h
 create mode 100644 xbmc/media/import/jobs/MediaImportTaskTypes.h
 create mode 100644 xbmc/media/import/jobs/tasks/CMakeLists.txt
 create mode 100644 xbmc/media/import/jobs/tasks/IMediaImportTask.cpp
 create mode 100644 xbmc/media/import/jobs/tasks/IMediaImportTask.h
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportChangesetTask.cpp
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportChangesetTask.h
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportCleanupTask.cpp
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportCleanupTask.h
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.cpp
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.h
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.cpp
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.h
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportRemovalTask.cpp
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportRemovalTask.h
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportSynchronisationTask.cpp
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportSynchronisationTask.h
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportUpdateTask.cpp
 create mode 100644 xbmc/media/import/jobs/tasks/MediaImportUpdateTask.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 31bc3ea01a29..4fc5df140f43 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -22175,3 +22175,62 @@ msgid "Manually"
 msgstr ""
 
 # empty strings from id 39537 to 39549 are reserved for media import settings
+
+#. Retrieving media items from (media provider name)
+#: xbmc/media/import/task/MediaImportImportItemsRetrievalTask.cpp
+#: xbmc/media/import/task/MediaImportLocalItemsRetrievalTask.cpp
+msgctxt "#39558"
+msgid "Retrieving media items from {:s}..."
+msgstr ""
+
+#. Retrieving media items from (media provider name)
+#: xbmc/media/import/task/MediaImportChangesetTask.cpp
+msgctxt "#39559"
+msgid "Processing media items from {:s}..."
+msgstr ""
+
+#. Processing (media type plural)...
+#: xbmc/media/import/task/MediaImportChangesetTask.cpp
+msgctxt "#39560"
+msgid "Processing {:s}..."
+msgstr ""
+
+#. Importing (media type plural) from (media provider name)...
+#: xbmc/media/import/task/MediaImportSynchronisationTask.cpp
+msgctxt "#39561"
+msgid "Importing {:s} from {:s}..."
+msgstr ""
+
+#. Adding (media item title)...
+#: xbmc/media/import/task/MediaImportSynchronisationTask.cpp
+msgctxt "#39562"
+msgid "Adding {:s}..."
+msgstr ""
+
+#. Updating (media item title)...
+#: xbmc/media/import/task/MediaImportSynchronisationTask.cpp
+msgctxt "#39563"
+msgid "Updating {:s}..."
+msgstr ""
+
+#. Removing (media item title)...
+#: xbmc/media/import/task/MediaImportSynchronisationTask.cpp
+msgctxt "#39564"
+msgid "Removing {:s}..."
+msgstr ""
+
+#empty string id 39565
+
+#. Removing import of (media type plural) from (media provider name)
+#: xbmc/media/import/task/MediaImportRemovalTask.cpp
+msgctxt "#39566"
+msgid "Removing import of {:s} from {:s}..."
+msgstr ""
+
+# empty strings from id 39567 to 39568
+
+#. Cleaning up (media type plural) from (media provider name)...
+#: xbmc/media/import/task/MediaImportCleanupTask.cpp
+msgctxt "#39569"
+msgid "Cleaning up {:s} from {:s}..."
+msgstr ""
diff --git a/cmake/treedata/common/media.txt b/cmake/treedata/common/media.txt
index 7ae01aa061db..91b0885f4e5c 100644
--- a/cmake/treedata/common/media.txt
+++ b/cmake/treedata/common/media.txt
@@ -1,3 +1,5 @@
 xbmc/media                                      media
 xbmc/media/drm                                  drm
 xbmc/media/import                               media/import
+xbmc/media/import/jobs                          media/import/jobs
+xbmc/media/import/jobs/tasks                    media/import/jobs/tasks
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index df68ee687eb8..2a3a4eeef2db 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -162,6 +162,7 @@
 #include <cdio/logging.h>
 #endif
 
+#include "media/import/MediaImportManager.h"
 #include "storage/MediaManager.h"
 #include "utils/SaveFileStateJob.h"
 #include "utils/AlarmClock.h"
@@ -2639,6 +2640,8 @@ void CApplication::Stop(int exitCode)
     m_ExitCode = exitCode;
     CLog::Log(LOGINFO, "Stopping all");
 
+    CServiceBroker::GetMediaImportManager().Uninitialize();
+
     // cancel any jobs from the jobmanager
     CJobManager::GetInstance().CancelJobs();
 
diff --git a/xbmc/GUIUserMessages.h b/xbmc/GUIUserMessages.h
index 0b5cb6d7dc03..9dd84304e47c 100644
--- a/xbmc/GUIUserMessages.h
+++ b/xbmc/GUIUserMessages.h
@@ -140,3 +140,12 @@ constexpr int GUI_MSG_FLAG_FORCE_UPDATE = 0x00000002;
 // Sent to notify system sleep/wake
 #define GUI_MSG_SYSTEM_SLEEP GUI_MSG_USER + 45
 #define GUI_MSG_SYSTEM_WAKE GUI_MSG_USER + 46
+
+// Sent to CGUIWindowMediaSourceBrowser
+#define GUI_MSG_SOURCE_ADDED          GUI_MSG_USER + 47
+#define GUI_MSG_SOURCE_UPDATED        GUI_MSG_USER + 48
+#define GUI_MSG_SOURCE_REMOVED        GUI_MSG_USER + 49
+#define GUI_MSG_SOURCE_ACTIVE_CHANGED GUI_MSG_USER + 50
+#define GUI_MSG_IMPORT_ADDED          GUI_MSG_USER + 51
+#define GUI_MSG_IMPORT_UPDATED        GUI_MSG_USER + 52
+#define GUI_MSG_IMPORT_REMOVED        GUI_MSG_USER + 53
diff --git a/xbmc/ServiceBroker.cpp b/xbmc/ServiceBroker.cpp
index 4a17340d68cb..b322c078d65a 100644
--- a/xbmc/ServiceBroker.cpp
+++ b/xbmc/ServiceBroker.cpp
@@ -132,6 +132,11 @@ KODI::RETRO::CGUIGameRenderManager& CServiceBroker::GetGameRenderManager()
   return g_application.m_ServiceManager->GetGameRenderManager();
 }
 
+CMediaImportManager& CServiceBroker::GetMediaImportManager()
+{
+  return g_application.m_ServiceManager->GetMediaImportManager();
+}
+
 PERIPHERALS::CPeripherals& CServiceBroker::GetPeripherals()
 {
   return g_application.m_ServiceManager->GetPeripherals();
diff --git a/xbmc/ServiceBroker.h b/xbmc/ServiceBroker.h
index 0e1810db328b..d99a90b76cec 100644
--- a/xbmc/ServiceBroker.h
+++ b/xbmc/ServiceBroker.h
@@ -39,6 +39,7 @@ namespace PLAYLIST
 class CContextMenuManager;
 class XBPython;
 class CDataCacheCore;
+class CMediaImportManager;
 class IAE;
 class CFavouritesService;
 class CInputManager;
@@ -103,6 +104,7 @@ class CServiceBroker
   static KODI::GAME::CControllerManager& GetGameControllerManager();
   static KODI::GAME::CGameServices& GetGameServices();
   static KODI::RETRO::CGUIGameRenderManager& GetGameRenderManager();
+  static CMediaImportManager& GetMediaImportManager();
   static PERIPHERALS::CPeripherals& GetPeripherals();
   static CFavouritesService& GetFavouritesService();
   static ADDON::CServiceAddonManager& GetServiceAddons();
diff --git a/xbmc/ServiceManager.cpp b/xbmc/ServiceManager.cpp
index 5fae97bea3e8..8c8efffd5b2b 100644
--- a/xbmc/ServiceManager.cpp
+++ b/xbmc/ServiceManager.cpp
@@ -24,6 +24,7 @@
 #include "input/InputManager.h"
 #include "interfaces/generic/ScriptInvocationManager.h"
 #include "interfaces/python/XBPython.h"
+#include "media/import/MediaImportManager.h"
 #include "network/Network.h"
 #include "peripherals/Peripherals.h"
 #include "powermanagement/PowerManager.h"
@@ -138,6 +139,8 @@ bool CServiceManager::InitStageTwo(const CAppParamParser &params, const std::str
 
   m_fileExtensionProvider.reset(new CFileExtensionProvider(*m_addonMgr));
 
+  m_mediaImportManager.reset(new CMediaImportManager());
+
   m_powerManager.reset(new CPowerManager());
   m_powerManager->Initialize();
   m_powerManager->SetDefaults();
@@ -170,6 +173,8 @@ bool CServiceManager::InitStageThree(const std::shared_ptr<CProfileManager>& pro
 
   m_playerCoreFactory.reset(new CPlayerCoreFactory(*profileManager));
 
+  m_mediaImportManager->Initialize();
+
   init_level = 3;
   return true;
 }
@@ -223,6 +228,7 @@ void CServiceManager::DeinitStageOne()
   CScriptInvocationManager::GetInstance().UnregisterLanguageInvocationHandler(m_XBPython.get());
   m_XBPython.reset();
 #endif
+  m_mediaImportManager.reset();
 }
 
 ADDON::CAddonMgr &CServiceManager::GetAddonMgr()
@@ -287,6 +293,11 @@ PLAYLIST::CPlayListPlayer& CServiceManager::GetPlaylistPlayer()
   return *m_playlistPlayer;
 }
 
+CMediaImportManager& CServiceManager::GetMediaImportManager()
+{
+  return *m_mediaImportManager;
+}
+
 GAME::CControllerManager& CServiceManager::GetGameControllerManager()
 {
   return *m_gameControllerManager;
diff --git a/xbmc/ServiceManager.h b/xbmc/ServiceManager.h
index 823cd23544c4..0062f3ce64f0 100644
--- a/xbmc/ServiceManager.h
+++ b/xbmc/ServiceManager.h
@@ -39,6 +39,7 @@ class CContextMenuManager;
 class XBPython;
 #endif
 class CDataCacheCore;
+class CMediaImportManager;
 class CFavouritesService;
 class CNetworkBase;
 class CWinSystemBase;
@@ -111,6 +112,8 @@ class CServiceManager
   PLAYLIST::CPlayListPlayer& GetPlaylistPlayer();
   int init_level = 0;
 
+  CMediaImportManager& GetMediaImportManager();
+
   CFavouritesService& GetFavouritesService();
   CInputManager &GetInputManager();
   CFileExtensionProvider &GetFileExtensionProvider();
@@ -158,6 +161,7 @@ class CServiceManager
   std::unique_ptr<KODI::GAME::CControllerManager> m_gameControllerManager;
   std::unique_ptr<KODI::GAME::CGameServices> m_gameServices;
   std::unique_ptr<KODI::RETRO::CGUIGameRenderManager> m_gameRenderManager;
+  std::unique_ptr<CMediaImportManager> m_mediaImportManager;
   std::unique_ptr<PERIPHERALS::CPeripherals> m_peripherals;
   std::unique_ptr<CFavouritesService, delete_favouritesService> m_favouritesService;
   std::unique_ptr<CInputManager> m_inputManager;
diff --git a/xbmc/media/import/CMakeLists.txt b/xbmc/media/import/CMakeLists.txt
index 7e0de5a6b4ed..7384b873a50b 100644
--- a/xbmc/media/import/CMakeLists.txt
+++ b/xbmc/media/import/CMakeLists.txt
@@ -1,8 +1,16 @@
 set(SOURCES MediaImport.cpp
+            MediaImportManager.cpp
             MediaImportSettingsBase.cpp
             MediaImportSource.cpp)
 
-set(HEADERS MediaImport.h
+set(HEADERS IMediaImporter.h
+            IMediaImporterManager.h
+            IMediaImportHandler.h
+            IMediaImportHandlerManager.h
+            IMediaImportRepository.h
+            MediaImport.h
+            MediaImportChangesetTypes.h
+            MediaImportManager.h
             MediaImportSettingsBase.h
             MediaImportSource.h)
 
diff --git a/xbmc/media/import/IMediaImportHandler.h b/xbmc/media/import/IMediaImportHandler.h
new file mode 100644
index 000000000000..137b4d76bd82
--- /dev/null
+++ b/xbmc/media/import/IMediaImportHandler.h
@@ -0,0 +1,195 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/MediaType.h"
+#include "media/import/MediaImportChangesetTypes.h"
+
+#include <memory>
+
+class CFileItem;
+typedef std::shared_ptr<CFileItem> CFileItemPtr;
+
+class CMediaImport;
+class IMediaImportHandlerManager;
+
+/*!
+ * \brief Interface of a handler capable of handling imported media items of a
+ * specific media type.
+ */
+class IMediaImportHandler
+{
+public:
+  virtual ~IMediaImportHandler() = default;
+
+  virtual IMediaImportHandler* Create() const = 0;
+
+  /*!
+   * \brief Returns the media type the implementation is capable of handling.
+   */
+  virtual MediaType GetMediaType() const = 0;
+
+  /*!
+   * \brief Returns a list of media types which must be importable for
+   * this implementation to be usable.
+   */
+  virtual MediaTypes GetRequiredMediaTypes() const { return MediaTypes(); }
+
+  /*!
+   * \brief Returns a list of media types which can be grouped together
+   * with the media type of this implementation.
+   */
+  virtual GroupedMediaTypes GetGroupedMediaTypes() const { return {GetMediaType()}; }
+
+  /*!
+   * \brief Get the translated label representing the given item
+   *
+   * \param item Item to get the label for
+   * \return Translated label representing the given item
+   */
+  virtual std::string GetItemLabel(const CFileItem* item) const = 0;
+
+  /*!
+   * \brief Gets a list of previously imported items from the given media import.
+   *
+   * \param import Place from where the given items were imported
+   * \param items List of previously imported items from the given media import
+   */
+  virtual bool GetLocalItems(const CMediaImport& import,
+                             std::vector<CFileItemPtr>& items) const = 0;
+
+  /*!
+   * \brief Starts the task determining the changeset of the imported items against previously imported items.
+   *
+   * \param import Place from where the given items were imported
+   * \return True if the preparations were successful, false otherwise
+   */
+  virtual bool StartChangeset(const CMediaImport& import) = 0;
+
+  /*!
+   * \brief Finishes the task determining the changeset of the imported items against previously imported items.
+   *
+   * \param import Place from where the given items were imported
+   * \return True if the finalizations were successful, false otherwise
+   */
+  virtual bool FinishChangeset(const CMediaImport& import) = 0;
+
+  /*!
+   * \brief Tries to find a previously imported item matching the given item
+   *
+   * \param import Place from where the given item was imported
+   * \param item Imported item
+   * \param localItems Previously imported items
+   * \return The matching previously imported item or nullptr
+   */
+  virtual CFileItemPtr FindMatchingLocalItem(const CMediaImport& import,
+                                             const CFileItem* item,
+                                             const std::vector<CFileItemPtr>& localItems) const = 0;
+
+  /*!
+   * \brief Determining the changeset of the imported item against the previously imported item.
+   *
+   * \param import Place from where the given items were imported
+   * \param item Imported item
+   * \param localItem Previously imported item
+   * \return Type of the changeset of the two imported items
+   */
+  virtual MediaImportChangesetType DetermineChangeset(const CMediaImport& import,
+                                                      const CFileItem* item,
+                                                      const CFileItemPtr& localItem) = 0;
+
+  /*!
+   * \brief Prepares the given imported item for updating based on the previously imported item.
+   *
+   * \param import Place from where the given items were imported
+   * \param item Imported item to be prepared
+   * \param localItem Previously imported item
+   */
+  virtual void PrepareImportedItem(const CMediaImport& import,
+                                   CFileItem* item,
+                                   const CFileItemPtr& localItem) const = 0;
+
+  /*!
+   * \brief Starts the synchronisation process
+   *
+   * \param import Place from where the given items were imported
+   * \return True if the preparations were successful, false otherwise
+   */
+  virtual bool StartSynchronisation(const CMediaImport& import) = 0;
+
+  /*!
+   * \brief Finishes the synchronisation process
+   *
+   * \param import Place from where the given items were imported
+   * \return True if the finalizations were successful, false otherwise
+   */
+  virtual bool FinishSynchronisation(const CMediaImport& import) = 0;
+
+  /*!
+   * \brief Adds the given item from the given import to the library
+   *
+   * \param import Place from where the given items were imported
+   * \param item Imported item to be added to the library
+   * \return True if the item was successfully added, false otherwise
+   */
+  virtual bool AddImportedItem(const CMediaImport& import, CFileItem* item) = 0;
+
+  /*!
+   * \brief Updates the given item from the given import in the library
+   *
+   * \param import Place from where the given items were imported
+   * \param item Imported item to be updated in the library
+   * \return True if the item was successfully updated, false otherwise
+   */
+  virtual bool UpdateImportedItem(const CMediaImport& import, CFileItem* item) = 0;
+
+  /*!
+   * \brief Removes the given item from the given import from the library
+   *
+   * \param import Place from where the given items were imported
+   * \param item Imported item to be removed from the library
+   * \return True if the item was successfully removed, false otherwise
+   */
+  virtual bool RemoveImportedItem(const CMediaImport& import, const CFileItem* item) = 0;
+
+  /*!
+   * \brief Cleans up the imported items in the library
+   *
+   * \param import Place from where the given items were imported
+   * \return True if the library was successfully cleaned up, false otherwise
+   */
+  virtual bool CleanupImportedItems(const CMediaImport& import) = 0;
+
+  /*!
+   * \brief Removes all imported items from the library
+   *
+   * \param import Place from where the given items were imported
+   * \return True if the imported items were successfully removed from the library, false otherwise
+   */
+  virtual bool RemoveImportedItems(const CMediaImport& import) = 0;
+
+  /*!
+   * \brief Enable/disable imported items
+   *
+   * \param import Place from where the given items were imported
+   * \param enable Whether to enable or disable imported items
+   */
+  virtual void SetImportedItemsEnabled(const CMediaImport& import, bool enable) = 0;
+
+protected:
+  IMediaImportHandler(const IMediaImportHandlerManager* importHandlerManager)
+    : m_importHandlerManager(importHandlerManager)
+  {
+  }
+
+  const IMediaImportHandlerManager* m_importHandlerManager;
+};
+
+using MediaImportHandlerPtr = std::shared_ptr<IMediaImportHandler>;
+using MediaImportHandlerConstPtr = std::shared_ptr<const IMediaImportHandler>;
diff --git a/xbmc/media/import/IMediaImportHandlerManager.h b/xbmc/media/import/IMediaImportHandlerManager.h
new file mode 100644
index 000000000000..78381055336c
--- /dev/null
+++ b/xbmc/media/import/IMediaImportHandlerManager.h
@@ -0,0 +1,37 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/MediaType.h"
+
+#include <memory>
+
+class IMediaImportHandler;
+using MediaImportHandlerConstPtr = std::shared_ptr<const IMediaImportHandler>;
+
+/*!
+ * \brief Interface defining the functionality of a media import handler manager.
+ */
+class IMediaImportHandlerManager
+{
+public:
+  virtual ~IMediaImportHandlerManager() = default;
+
+  /*!
+   * \brief Returns the media import handler implementation capable of handling
+   * imported media items of the given media type.
+   *
+   * \param mediaType Media type of an imported item
+   * \pram Media import handler implementation
+   */
+  virtual MediaImportHandlerConstPtr GetImportHandler(const MediaType& mediaType) const = 0;
+
+protected:
+  IMediaImportHandlerManager() = default;
+};
diff --git a/xbmc/media/import/IMediaImportRepository.h b/xbmc/media/import/IMediaImportRepository.h
new file mode 100644
index 000000000000..420e1c163b26
--- /dev/null
+++ b/xbmc/media/import/IMediaImportRepository.h
@@ -0,0 +1,163 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/MediaType.h"
+#include "media/import/MediaImport.h"
+#include "media/import/MediaImportSource.h"
+
+#include <memory>
+#include <vector>
+
+class CFileItem;
+
+/*!
+ * \brief Interface defining a repository capable of storing media items imported from sources and their imports.
+ */
+class IMediaImportRepository
+{
+public:
+  virtual ~IMediaImportRepository() = default;
+
+  /*
+   * \brief Initializes the repository.
+   *
+   * \return True if the initialization was successful, false otherwise
+   */
+  virtual bool Initialize() = 0;
+
+  /*
+   * \brief Gets all imports stored in the repository.
+   *
+   * \return List of imports
+   */
+  virtual std::vector<CMediaImport> GetImports() const = 0;
+
+  /*
+   * \brief Gets all imports from the source with the given identifier stored in the repository.
+   *
+   * \param sourceIdentifier Source identifier
+   * \return List of imports
+   */
+  virtual std::vector<CMediaImport> GetImportsBySource(
+      const std::string& sourceIdentifier) const = 0;
+
+  /*
+   * \brief Gets all imports for the given media types stored in the repository.
+   *
+   * \param mediaTypes Media types
+   * \return List of imports
+   */
+  virtual std::vector<CMediaImport> GetImportsByMediaType(
+      const GroupedMediaTypes& mediaTypes) const = 0;
+
+  /*!
+   * \brief Gets all imports for the given path stored in the repository.
+   *
+   * \param path Path of the imports
+   * \param includeSubDirectories Whether to include subdirectories or not
+   */
+  virtual std::vector<CMediaImport> GetImportsByPath(const std::string& path,
+                                                     bool includeSubDirectories = false) const = 0;
+
+  /*
+   * \brief Gets the import for the given path and media type.
+   *
+   * \param path Path of the import
+   * \param mediaTypes Media types of the items imported from the import
+   * \param import[out] Import
+   * \return True if a matching import was found, false otherwise
+   */
+  virtual bool GetImport(const std::string& path,
+                         const GroupedMediaTypes& mediaTypes,
+                         CMediaImport& import) const = 0;
+
+  /*
+   * \brief Adds the given import to the repository.
+   *
+   * \param import Import to be added
+   * \param added[out] Whether the import has been added to the repository or not.
+   * \return True if the import was successfully added, false otherwise
+   */
+  virtual bool AddImport(const CMediaImport& import, bool& added) = 0;
+
+  /*
+   * \brief Updates the given import in the repository.
+   *
+   * \param import Import to be updated
+   * \param updated[out] Whether the import has been updated in the repository or not.
+   * \return True if the import was successfully updated, false otherwise
+   */
+  virtual bool UpdateImport(const CMediaImport& import, bool& updated) = 0;
+
+  /*
+   * \brief Removes the given import from the repository.
+   *
+   * \param import Import to be removed
+   * \return True if the import was successfully removed, false otherwise
+   */
+  virtual bool RemoveImport(const CMediaImport& import) = 0;
+
+  /*
+   * \brief Updates the last synchronisation timestamp of the given import in the repository.
+   *
+   * \param import Import to be updated
+   * \return True if the import was successfully updated, false otherwise
+   */
+  virtual bool UpdateLastSync(CMediaImport& import) = 0;
+
+  /*
+   * \brief Gets all sources supporting the given media types stored in the repository.
+   *
+   * \param mediaTypes Media types
+   * \return List of sources
+   */
+  virtual std::vector<CMediaImportSource> GetSources(
+      const GroupedMediaTypes& mediaTypes = GroupedMediaTypes()) const = 0;
+
+  /*
+   * \brief Gets the source with the given identifier.
+   *
+   * \param identifier Source identifier
+   * \param source[out] Source
+   * \return True if a matching source was found, false otherwise
+   */
+  virtual bool GetSource(const std::string& identifier, CMediaImportSource& source) const = 0;
+
+  /*
+   * \brief Adds the given source to the repository.
+   *
+   * \param source Source to be added
+   * \param added[out] Whether the source has been added to the repository or not.
+   * \return True if the source was successfully added, false otherwise
+   */
+  virtual bool AddSource(const CMediaImportSource& source, bool& added) = 0;
+
+  /*
+   * \brief Updates the given source in the repository.
+   *
+   * \param source Source to be updated
+   * \param updated[out] Whether the import has been updated in the repository or not.
+   * \return True if the source was successfully updated, false otherwise
+   */
+  virtual bool UpdateSource(const CMediaImportSource& source, bool& updated) = 0;
+
+  /*
+   * \brief Removes the source with the given identifier from the repository.
+   *
+   * \param identifier Source identifier
+   * \return True if the source was successfully removed, false otherwise
+   */
+  virtual bool RemoveSource(const std::string& identifier) = 0;
+
+protected:
+  IMediaImportRepository() = default;
+};
+
+using MediaImportRepositoryPtr = std::shared_ptr<IMediaImportRepository>;
diff --git a/xbmc/media/import/IMediaImporter.h b/xbmc/media/import/IMediaImporter.h
new file mode 100644
index 000000000000..67fdeef87756
--- /dev/null
+++ b/xbmc/media/import/IMediaImporter.h
@@ -0,0 +1,299 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/MediaImport.h"
+#include "media/import/MediaImportSource.h"
+#include "utils/ILocalizer.h"
+
+#include <memory>
+#include <string>
+
+class CMediaImportImportItemsRetrievalTask;
+class CMediaImportUpdateTask;
+
+/*!
+ * \brief Base innterface of a media importer capable of importing media items from a specific source into
+ * the local library.
+ */
+class IMediaImporterBase
+{
+public:
+  virtual ~IMediaImporterBase() = default;
+
+  /*!
+   * \brief Gets a unique identification of the media importer
+   */
+  virtual const char* GetIdentification() const = 0;
+
+  /*!
+   * \brief Checks if the implementation can manually lookup media sources.
+   */
+  virtual bool CanLookupSource() const { return false; }
+
+  /*!
+   * \brief Provide a protocol of the media importer for manual media source lookup.
+   */
+  virtual std::string GetSourceLookupProtocol() const { return ""; }
+};
+
+/*!
+ * \brief TODO
+ */
+class IMediaImporterDiscoverer : public virtual IMediaImporterBase
+{
+public:
+  virtual ~IMediaImporterDiscoverer() = default;
+
+  /*!
+   * \brief Starts any importer specific tasks/actions.
+   */
+  virtual void Start() {}
+};
+
+/*!
+ * \brief TODO
+ */
+class IMediaImporter : public virtual IMediaImporterBase, public ILocalizer
+{
+public:
+  virtual ~IMediaImporter() = default;
+
+  // implementation of ILocalizer
+  std::string Localize(std::uint32_t code) const override { return ""; }
+
+  /*!
+   * \brief Tries to discover / find a new media source.
+   *
+   * \param source The looked up source.
+   * \return True if a source was found, false otherwise.
+   */
+  virtual bool DiscoverSource(CMediaImportSource& source) = 0;
+
+  /*!
+   * \brief Tries to lookup / find the given media source.
+   *
+   * \param source The source to lookup.
+   * \return True if the given source was found, false otherwise.
+   */
+  virtual bool LookupSource(const CMediaImportSource& source) = 0;
+
+  /*
+   * \brief Checks if the implementation can import items from the given path.
+   *
+   * ATTENTION: This method can be called with a path that does not match the
+   *            path of the import used to create the importer.
+   *
+   * \param path Path to a source or import
+   * \return True if the implementation can import items from the given path, false otherwise
+   */
+  virtual bool CanImport(const std::string& path) = 0;
+
+  /*
+   * \brief Checks if the source is ready for importing.
+   *
+   * \return True if the source is ready for importing, false otherwise
+   */
+  virtual bool IsSourceReady(CMediaImportSource& source) = 0;
+
+  /*
+   * \brief Checks if the import is ready to be processed.
+   *
+   * \return True if the import is ready to be processed, false otherwise
+   */
+  virtual bool IsImportReady(CMediaImport& import) = 0;
+
+  /*
+   * \brief Prepares and loads the source's settings based on the importers functionality.
+   *
+   * The caller needs to guarantee that the given CMediaImportSource instance stays
+   * valid until UnloadSourceSettings() has been called with the same instance.
+   *
+   * \return True if the source's settings have been successfully prepared and loaded, false otherwise
+   */
+  virtual bool LoadSourceSettings(CMediaImportSource& source) { return false; }
+  /*
+   * \brief Saves and unloads the source's settings based on the importers functionality.
+   *
+   * \return True if the source's settings have been successfully saved and unloaded, false otherwise
+   */
+  virtual bool UnloadSourceSettings(CMediaImportSource& source) { return false; }
+
+  /*
+   * \brief Prepares and loads the import's settings based on the importers functionality.
+   *
+   * The caller needs to guarantee that the given CMediaImport instance stays
+   * valid until UnloadImportSettings() has been called with the same instance.
+   *
+   * \return True if the import's settings have been successfully prepared and loaded, false otherwise
+   */
+  virtual bool LoadImportSettings(CMediaImport& import) { return false; }
+  /*
+   * \brief Saves and unloads the import's settings based on the importers functionality.
+   *
+   * \return True if the import's settings have been successfully saved and unloaded, false otherwise
+   */
+  virtual bool UnloadImportSettings(CMediaImport& import) { return false; }
+
+  /*!
+   * \brief Checks if the implementation can update general metadata of an
+   * imported item on the source with the given path.
+   *
+   * \param path Path to a source or import
+   * \return True if the implementation can update general metadata of an imported item on the source with the given path, false otherwise
+   */
+  virtual bool CanUpdateMetadataOnSource(const std::string& path) { return false; }
+
+  /*!
+   * \brief Checks if the implementation can update the playcount of an
+   * imported item on the source with the given path.
+   *
+   * \param path Path to a source or import
+   * \return True if the implementation can update the playcount of an imported item on the source with the given path, false otherwise
+   */
+  virtual bool CanUpdatePlaycountOnSource(const std::string& path) { return false; }
+
+  /*!
+   * \brief Checks if the implementation can update the last played date of an
+   * imported item on the source with the given path.
+   *
+   * \param path Path to a source or import
+   * \return True if the implementation can update the last played date of an imported item on the source with the given path, false otherwise
+   */
+  virtual bool CanUpdateLastPlayedOnSource(const std::string& path) { return false; }
+
+  /*!
+   * \brief Checks if the implementation can update the resume position of an
+   * imported item on the source with the given path.
+   *
+   * \param path Path to a source or import
+   * \return True if the implementation can update the resume position of an imported item on the source with the given path, false otherwise
+   */
+  virtual bool CanUpdateResumePositionOnSource(const std::string& path) { return false; }
+
+  /*!
+   * \brief Imports items from the source.
+   *
+   * The imported items are stored in the given CMediaImportRetrievalTask instance by
+   * their respective media type.
+   *
+   * \param task Task performing the import (to check if we need to cancel import and to report progress)
+   * \return True if the import succeeded, false otherwise
+   */
+  virtual bool Import(CMediaImportImportItemsRetrievalTask* task) = 0;
+
+  /*!
+   * \brief Updates an item's metadata on the source
+   *
+   * The given CMediaImportUpdateTask contains a media item whose metadata
+   * should be updated on the source if it is supported by the importer.
+   *
+   * \param task Task performing the updating
+   * \return True if updating the item's metadata succeeded, false otherwise
+   */
+  virtual bool UpdateOnSource(CMediaImportUpdateTask* task) = 0;
+};
+
+/*!
+ * \brief TODO
+ */
+class IMediaImporterObserver
+{
+public:
+  virtual ~IMediaImporterObserver() = default;
+
+  /*!
+   * \brief TODO
+   */
+  virtual void Start() {}
+
+  /*!
+   * \brief TODO
+   */
+  virtual void OnSourceAdded(const CMediaImportSource& source) {}
+
+  /*!
+   * \brief TODO
+   */
+  virtual void OnSourceUpdated(const CMediaImportSource& source) {}
+
+  /*!
+   * \brief TODO
+   */
+  virtual void OnSourceRemoved(const CMediaImportSource& source) {}
+
+  /*!
+   * \brief TODO
+   */
+  virtual void OnSourceActivated(const CMediaImportSource& source) {}
+
+  /*!
+   * \brief TODO
+   */
+  virtual void OnSourceDeactivated(const CMediaImportSource& source) {}
+
+  /*!
+   * \brief TODO
+   */
+  virtual void OnImportAdded(const CMediaImport& import) {}
+
+  /*!
+   * \brief TODO
+   */
+  virtual void OnImportUpdated(const CMediaImport& import) {}
+
+  /*!
+   * \brief TODO
+   */
+  virtual void OnImportRemoved(const CMediaImport& import) {}
+
+protected:
+  IMediaImporterObserver() = default;
+};
+
+/*!
+ * \brief TODO
+ */
+class IMediaImporterFactory
+{
+public:
+  virtual ~IMediaImporterFactory() = default;
+
+  /*!
+   * \brief Gets a unique identification of the media importer
+   */
+  virtual const char* GetIdentification() const = 0;
+
+  /*!
+  * \brief Creates a new IMediaImporterDiscoverer instance of the implementation.
+  *
+  * \return New IMediaImporterDiscoverer instance of the implementation
+  */
+  virtual std::unique_ptr<IMediaImporterDiscoverer> CreateDiscoverer() const = 0;
+
+  /*!
+  * \brief Creates a new IMediaImporter instance of the implementation.
+  *
+  * \return New IMediaImporter instance of the implementation
+  */
+  virtual std::unique_ptr<IMediaImporter> CreateImporter() const = 0;
+
+  /*!
+  * \brief TODO
+  *
+  * \return New IMediaImporterObserver instance of the implementation
+  */
+  virtual std::unique_ptr<IMediaImporterObserver> CreateObserver() const = 0;
+};
+
+using MediaImporterDiscovererPtr = std::unique_ptr<IMediaImporterDiscoverer>;
+using MediaImporterPtr = std::unique_ptr<IMediaImporter>;
+using MediaImporterObserverPtr = std::unique_ptr<IMediaImporterObserver>;
+using MediaImporterFactoryPtr = std::shared_ptr<IMediaImporterFactory>;
+using MediaImporterFactoryConstPtr = std::shared_ptr<const IMediaImporterFactory>;
diff --git a/xbmc/media/import/IMediaImporterManager.h b/xbmc/media/import/IMediaImporterManager.h
new file mode 100644
index 000000000000..35df54731125
--- /dev/null
+++ b/xbmc/media/import/IMediaImporterManager.h
@@ -0,0 +1,50 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/IMediaImporter.h"
+
+#include <memory>
+#include <string>
+
+class CMediaImportSource;
+
+/*!
+ * \brief Interface defining the functionality of a media importer manager.
+ */
+class IMediaImporterManager
+{
+public:
+  virtual ~IMediaImporterManager() = default;
+
+  /*!
+   * \brief Checks whether an importer with the given identification is available.
+   */
+  virtual bool HasImporter(const std::string& id) const = 0;
+
+  /*!
+   * \brief Returns the media importer implementation with the given identification.
+   *
+   * \param id Identification of the media importer implementation
+   * \return Media importer implementation
+   */
+  virtual MediaImporterPtr GetImporterById(const std::string& id) const = 0;
+
+  /*!
+   * \brief Returns the media importer implementation capable of importing
+   * media items from the given source.
+   *
+   * \param source Source to import items from
+   * \return Media importer implementation
+   */
+  virtual MediaImporterPtr GetImporterBySource(const CMediaImportSource& source) const = 0;
+
+protected:
+  IMediaImporterManager() = default;
+};
diff --git a/xbmc/media/import/MediaImportChangesetTypes.h b/xbmc/media/import/MediaImportChangesetTypes.h
new file mode 100644
index 000000000000..1530ec6635cb
--- /dev/null
+++ b/xbmc/media/import/MediaImportChangesetTypes.h
@@ -0,0 +1,22 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "FileItem.h"
+
+enum class MediaImportChangesetType
+{
+  None = 0,
+  Added,
+  Changed,
+  Removed
+};
+
+typedef std::pair<MediaImportChangesetType, CFileItemPtr> ChangesetItemPtr;
+typedef std::vector<ChangesetItemPtr> ChangesetItems;
diff --git a/xbmc/media/import/MediaImportManager.cpp b/xbmc/media/import/MediaImportManager.cpp
new file mode 100644
index 000000000000..e6bc5ca11508
--- /dev/null
+++ b/xbmc/media/import/MediaImportManager.cpp
@@ -0,0 +1,2334 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportManager.h"
+
+#include "FileItem.h"
+#include "GUIUserMessages.h"
+#include "LibraryQueue.h"
+#include "ServiceBroker.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "interfaces/AnnouncementManager.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/IMediaImportRepository.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/MediaImport.h"
+#include "media/import/MediaImportSource.h"
+#include "media/import/jobs/MediaImportSourceActivationJob.h"
+#include "media/import/jobs/MediaImportSourceJobBase.h"
+#include "media/import/jobs/MediaImportSourceReadyJob.h"
+#include "media/import/jobs/MediaImportSourceRegistrationJob.h"
+#include "media/import/jobs/MediaImportTaskProcessorJob.h"
+#include "media/import/jobs/tasks/MediaImportChangesetTask.h"
+#include "media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.h"
+#include "media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.h"
+#include "media/import/jobs/tasks/MediaImportRemovalTask.h"
+#include "media/import/jobs/tasks/MediaImportSynchronisationTask.h"
+#include "media/import/jobs/tasks/MediaImportUpdateTask.h"
+#include "threads/SingleLock.h"
+#include "utils/SpecialSort.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/Variant.h"
+#include "utils/log.h"
+
+#include <algorithm>
+#include <string.h>
+#include <tuple>
+
+#include <fmt/ostream.h>
+
+CMediaImportManager::CMediaImportManager()
+  : CJobQueue(false, 1, CJob::PRIORITY_NORMAL),
+    m_logger(CServiceBroker::GetLogging().GetLogger("CMediaImportManager")),
+    m_initialized(false),
+    m_manuallyAddedSourceTimer(this)
+{
+}
+
+CMediaImportManager::~CMediaImportManager()
+{
+  Uninitialize();
+}
+
+void CMediaImportManager::Initialize()
+{
+  if (m_initialized)
+    return;
+
+  // register media handlers
+
+  // start all registered importers
+  {
+    CSingleLock importersLock(m_importersLock);
+    for (auto&& importer : m_importers)
+    {
+      importer.second.discoverer = importer.second.factory->CreateDiscoverer();
+      importer.second.discoverer->Start();
+
+      importer.second.observer = importer.second.factory->CreateObserver();
+      importer.second.observer->Start();
+    }
+  }
+
+  // start the timer responsible for checking whether manually imported sources are active or not
+  m_manuallyAddedSourceTimer.Start(1000, true);
+
+  m_initialized = true;
+}
+
+void CMediaImportManager::Uninitialize()
+{
+  // stop the timer responsible for checking whether manually imported sources are active or not
+  m_manuallyAddedSourceTimer.Stop();
+
+  // cancel all MediaImportTaskProcessorJobs
+  CancelAllJobs();
+
+  // clear all importers
+  {
+    CSingleLock lock(m_importersLock);
+    m_importers.clear();
+  }
+
+  // clear all media handlers
+  {
+    CSingleLock lock(m_importHandlersLock);
+    m_importHandlers.clear();
+    m_importHandlersMap.clear();
+  }
+
+  // deactivate all sources
+  {
+    CSingleLock lock(m_sourcesLock);
+    for (const auto& it : m_sources)
+      DeactivateSource(it.first);
+    m_sources.clear();
+  }
+
+  // clear all import repositories
+  {
+    CSingleLock lock(m_importRepositoriesLock);
+    m_importRepositories.clear();
+  }
+}
+
+void CMediaImportManager::RegisterImportRepository(MediaImportRepositoryPtr importRepository)
+{
+  if (importRepository == nullptr || !importRepository->Initialize())
+  {
+    m_logger->warn("failed to register and initialize given import repository");
+    return;
+  }
+
+  std::vector<CMediaImportSource> sources = importRepository->GetSources();
+
+  CSingleLock repositoriesLock(m_importRepositoriesLock);
+  m_importRepositories.insert(importRepository);
+
+  // add the sources from the repository. if the same source is in multiple
+  // repositories, the std::map::insert will not overwrite the existing entry
+  CSingleLock sourcesLock(m_sourcesLock);
+  for (const auto& itSource : sources)
+  {
+    MediaImportSource importSource = {itSource.GetImporterId(), false, false, false};
+    m_sources.insert(std::make_pair(itSource.GetIdentifier(), importSource));
+  }
+
+  m_logger->debug("new import repository with {} sources added", sources.size());
+}
+
+bool CMediaImportManager::UnregisterImportRepository(
+    const MediaImportRepositoryPtr importRepository)
+{
+  if (importRepository == nullptr)
+    return false;
+
+  CSingleLock repositoriesLock(m_importRepositoriesLock);
+  const auto& it = m_importRepositories.find(importRepository);
+  if (it == m_importRepositories.end())
+    return false;
+
+  // remove all sources from that repository
+  std::vector<CMediaImportSource> sources = importRepository->GetSources();
+  {
+    CSingleLock sourceslock(m_sourcesLock);
+    for (const auto& itSource : sources)
+    {
+      // only remove the source if it isn't part of another repository as well
+      CMediaImportSource source(itSource.GetIdentifier());
+      if (!FindSource(source.GetIdentifier(), source))
+        m_sources.erase(itSource.GetIdentifier());
+    }
+  }
+
+  m_importRepositories.erase(it);
+
+  m_logger->debug("import repository with {} sources removed", sources.size());
+  return true;
+}
+
+void CMediaImportManager::RegisterImporter(MediaImporterFactoryPtr importer)
+{
+  if (importer == nullptr)
+    return;
+
+  {
+    CSingleLock importersLock(m_importersLock);
+    if (m_importers.find(importer->GetIdentification()) != m_importers.end())
+      return;
+  }
+
+  MediaImporter internalImporter;
+  internalImporter.factory = importer;
+
+  {
+    CSingleLock importersLock(m_importersLock);
+    const auto inserted = m_importers.emplace(std::string(importer->GetIdentification()),
+                                              std::move(internalImporter));
+    if (inserted.second)
+    {
+      // if the importer has been added after Initialize() has been called, start the importer automatically
+      if (m_initialized)
+      {
+        inserted.first->second.discoverer = importer->CreateDiscoverer();
+        inserted.first->second.discoverer->Start();
+
+        inserted.first->second.observer = importer->CreateObserver();
+        inserted.first->second.observer->Start();
+      }
+
+      m_logger->debug("new importer {} added", importer->GetIdentification());
+    }
+  }
+}
+
+bool CMediaImportManager::UnregisterImporter(const std::string& importerIdentifier)
+{
+  CSingleLock lock(m_importersLock);
+  auto&& it = m_importers.find(importerIdentifier);
+  if (it == m_importers.end())
+    return false;
+
+  m_logger->debug("importer {} removed", it->second.factory->GetIdentification());
+  m_importers.erase(it);
+  lock.Leave();
+
+  return true;
+}
+
+std::vector<MediaImporterFactoryConstPtr> CMediaImportManager::GetImporters() const
+{
+  std::vector<MediaImporterFactoryConstPtr> importer;
+
+  CSingleLock lock(m_importersLock);
+  for (const auto& it : m_importers)
+    importer.push_back(std::const_pointer_cast<const IMediaImporterFactory>(it.second.factory));
+
+  return importer;
+}
+
+bool CMediaImportManager::DiscoverSource(const std::string& importerIdentification,
+                                         CMediaImportSource& source)
+{
+  if (importerIdentification.empty())
+    return false;
+
+  auto importer = GetImporterById(importerIdentification);
+  if (importer == nullptr)
+    return false;
+
+  if (!importer->CanLookupSource())
+    return false;
+
+  if (!importer->DiscoverSource(source))
+    return false;
+
+  source.SetImporterId(importerIdentification);
+  return true;
+}
+
+bool CMediaImportManager::HasImporter(const std::string& id) const
+{
+  CSingleLock lock(m_importersLock);
+  return m_importers.find(id) != m_importers.end();
+}
+
+MediaImporterPtr CMediaImportManager::GetImporterById(const std::string& id) const
+{
+  if (id.empty())
+    return nullptr;
+
+  CSingleLock lock(m_importersLock);
+  const auto& importer = m_importers.find(id);
+  if (importer == m_importers.end())
+    return nullptr;
+
+  return importer->second.factory->CreateImporter();
+}
+
+MediaImporterPtr CMediaImportManager::GetImporterBySource(const CMediaImportSource& source) const
+{
+  std::string importerId = source.GetImporterId();
+  if (importerId.empty())
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    const auto& itSource = m_sources.find(source.GetIdentifier());
+    if (itSource == m_sources.end())
+      return nullptr;
+
+    importerId = itSource->second.importerId;
+  }
+
+  return GetImporterById(importerId);
+}
+
+void CMediaImportManager::RegisterMediaImportHandler(MediaImportHandlerPtr importHandler)
+{
+  if (importHandler == nullptr)
+    return;
+
+  CSingleLock lock(m_importHandlersLock);
+  if (m_importHandlersMap.find(importHandler->GetMediaType()) == m_importHandlersMap.end())
+  {
+    m_importHandlersMap.insert(make_pair(importHandler->GetMediaType(), importHandler));
+
+    // build a dependency list
+    std::vector<std::pair<MediaType, MediaType>> dependencies;
+    for (const auto& itHandler : m_importHandlersMap)
+    {
+      GroupedMediaTypes mediaTypes = itHandler.second->GetGroupedMediaTypes();
+      for (const auto& itMediaType : mediaTypes)
+      {
+        if (itMediaType == itHandler.first)
+          break;
+
+        dependencies.push_back(make_pair(itHandler.first, itMediaType));
+      }
+    }
+
+    // re-sort the import handlers and their dependencies
+    GroupedMediaTypes result = SpecialSort::SortTopologically(dependencies);
+    std::map<MediaType, MediaImportHandlerConstPtr> handlersCopy(m_importHandlersMap.begin(),
+                                                                 m_importHandlersMap.end());
+    m_importHandlers.clear();
+    for (const auto& it : result)
+    {
+      m_importHandlers.push_back(handlersCopy.find(it)->second);
+      handlersCopy.erase(it);
+    }
+    for (const auto& itHandler : handlersCopy)
+      m_importHandlers.push_back(itHandler.second);
+
+    m_logger->debug("new import handler for {} added", importHandler->GetMediaType());
+  }
+}
+
+void CMediaImportManager::UnregisterMediaImportHandler(MediaImportHandlerPtr importHandler)
+{
+  if (importHandler == nullptr)
+    return;
+
+  CSingleLock lock(m_importHandlersLock);
+  auto&& it = m_importHandlersMap.find(importHandler->GetMediaType());
+  if (it == m_importHandlersMap.end() || it->second != importHandler)
+    return;
+
+  // remove the import handler from the map
+  m_importHandlersMap.erase(it);
+  // and from the sorted vector
+  m_importHandlers.erase(
+      std::remove_if(m_importHandlers.begin(), m_importHandlers.end(),
+                     [this, &importHandler](const MediaImportHandlerConstPtr& vecIt) {
+                       if (vecIt == importHandler)
+                       {
+                         m_logger->debug("import handler for {} removed",
+                                         importHandler->GetMediaType());
+                         return true;
+                       }
+
+                       return false;
+                     }),
+      m_importHandlers.end());
+}
+
+MediaImportHandlerConstPtr CMediaImportManager::GetImportHandler(const MediaType& mediaType) const
+{
+  const auto& itMediaImportHandler = m_importHandlersMap.find(mediaType);
+  if (itMediaImportHandler == m_importHandlersMap.end())
+    return MediaImportHandlerPtr();
+
+  return itMediaImportHandler->second;
+}
+
+std::vector<MediaImportHandlerConstPtr> CMediaImportManager::GetImportHandlers() const
+{
+  return m_importHandlers;
+}
+
+std::vector<MediaImportHandlerConstPtr> CMediaImportManager::GetImportHandlers(
+    const MediaTypes& mediaTypes) const
+{
+  if (mediaTypes.empty())
+    return GetImportHandlers();
+
+  std::vector<MediaImportHandlerConstPtr> importHandlers;
+  CSingleLock lock(m_importHandlersLock);
+  std::copy_if(m_importHandlers.begin(), m_importHandlers.end(), importHandlers.begin(),
+               [&mediaTypes](const MediaImportHandlerConstPtr& importHandler) {
+                 return mediaTypes.find(importHandler->GetMediaType()) != mediaTypes.end();
+               });
+
+  return importHandlers;
+}
+
+bool CMediaImportManager::IsMediaTypeSupported(const MediaType& mediaType) const
+{
+  CSingleLock lock(m_importHandlersLock);
+
+  const auto it = std::find_if(m_importHandlers.cbegin(), m_importHandlers.cend(),
+                               [&mediaType](const MediaImportHandlerConstPtr& importHandler) {
+                                 return importHandler->GetMediaType() == mediaType;
+                               });
+
+  return it != m_importHandlers.cend();
+}
+
+MediaTypes CMediaImportManager::GetSupportedMediaTypes() const
+{
+  MediaTypes mediaTypes;
+
+  CSingleLock lock(m_importHandlersLock);
+  // get all media types for which there are handlers
+  for (const auto& it : m_importHandlers)
+    mediaTypes.insert(it->GetMediaType());
+
+  return mediaTypes;
+}
+
+GroupedMediaTypes CMediaImportManager::GetSupportedMediaTypesOrdered(
+    bool reversed /* = false */) const
+{
+  GroupedMediaTypes mediaTypesOrdered;
+
+  CSingleLock lock(m_importHandlersLock);
+  // get all media types for which there are handlers
+  for (const auto& it : m_importHandlers)
+    mediaTypesOrdered.push_back(it->GetMediaType());
+
+  if (reversed)
+    std::reverse(mediaTypesOrdered.begin(), mediaTypesOrdered.end());
+
+  return mediaTypesOrdered;
+}
+
+GroupedMediaTypes CMediaImportManager::GetSupportedMediaTypesOrdered(
+    const MediaTypes& mediaTypes, bool reversed /* = false */) const
+{
+  GroupedMediaTypes mediaTypesOrdered;
+  if (mediaTypes.empty())
+    return GetSupportedMediaTypesOrdered();
+
+  CSingleLock lock(m_importHandlersLock);
+  for (const auto& it : m_importHandlers)
+  {
+    if (mediaTypes.find(it->GetMediaType()) != mediaTypes.end())
+      mediaTypesOrdered.push_back(it->GetMediaType());
+  }
+
+  if (reversed)
+    std::reverse(mediaTypesOrdered.begin(), mediaTypesOrdered.end());
+
+  return mediaTypesOrdered;
+}
+
+std::vector<GroupedMediaTypes> CMediaImportManager::GetSupportedMediaTypesGrouped(
+    const MediaTypes& mediaTypes) const
+{
+  std::vector<GroupedMediaTypes> supportedMediaTypes;
+  MediaTypes handledMediaTypes;
+
+  CSingleLock lock(m_importHandlersLock);
+  // get all media types for which there are handlers
+  for (const auto& handler : m_importHandlers)
+  {
+    if (mediaTypes.find(handler->GetMediaType()) == mediaTypes.end())
+      continue;
+
+    // make sure all required media types are available
+    MediaTypes requiredMediaTypes = handler->GetRequiredMediaTypes();
+    if (std::any_of(requiredMediaTypes.begin(), requiredMediaTypes.end(),
+                    [&mediaTypes](const MediaType& mediaType) {
+                      return mediaTypes.find(mediaType) == mediaTypes.end();
+                    }))
+      continue;
+
+    handledMediaTypes.insert(handler->GetMediaType());
+  }
+
+  for (const auto& handler : m_importHandlers)
+  {
+    const auto& itHandledMediaType = handledMediaTypes.find(handler->GetMediaType());
+    if (itHandledMediaType == handledMediaTypes.end())
+      continue;
+
+    GroupedMediaTypes group;
+    GroupedMediaTypes groupedMediaTypes = handler->GetGroupedMediaTypes();
+    for (const auto& itGroupedMediaType : groupedMediaTypes)
+    {
+      const auto& itMediaType = handledMediaTypes.find(itGroupedMediaType);
+      if (itMediaType != handledMediaTypes.end())
+      {
+        group.push_back(*itMediaType);
+        handledMediaTypes.erase(itMediaType);
+      }
+    }
+
+    if (group.empty())
+    {
+      group.push_back(*itHandledMediaType);
+      handledMediaTypes.erase(itHandledMediaType);
+    }
+
+    supportedMediaTypes.push_back(group);
+  }
+
+  return supportedMediaTypes;
+}
+
+GroupedMediaTypes CMediaImportManager::GetGroupedMediaTypes(const MediaType& mediaType) const
+{
+  if (mediaType.empty())
+    return {};
+
+  CSingleLock lock(m_importHandlersLock);
+  const auto& itHandler = m_importHandlersMap.find(mediaType);
+  if (itHandler == m_importHandlersMap.end())
+    return {};
+
+  return itHandler->second->GetGroupedMediaTypes();
+}
+
+bool CMediaImportManager::AddSource(const std::string& importerId,
+                                    const std::string& sourceID,
+                                    const std::string& basePath,
+                                    const std::string& friendlyName,
+                                    const std::string& iconUrl /* = "" */,
+                                    const MediaTypes& mediaTypes /* = MediaTypes() */)
+{
+  CMediaImportSource source(sourceID, basePath, friendlyName, iconUrl, mediaTypes);
+  source.SetImporterId(importerId);
+  return AddSource(source);
+}
+
+bool CMediaImportManager::AddSource(const CMediaImportSource& source)
+{
+  return AddSourceAsync(source, false, false);
+}
+
+bool CMediaImportManager::AddAndActivateSource(const std::string& importerId,
+                                               const std::string& sourceID,
+                                               const std::string& basePath,
+                                               const std::string& friendlyName,
+                                               const std::string& iconUrl /* = "" */,
+                                               const MediaTypes& mediaTypes /* = MediaTypes() */)
+{
+  CMediaImportSource source(sourceID, basePath, friendlyName, iconUrl, mediaTypes);
+  source.SetImporterId(importerId);
+  return AddAndActivateSource(source);
+}
+
+bool CMediaImportManager::AddAndActivateSource(const CMediaImportSource& source)
+{
+  return AddSourceAsync(source, true, false);
+}
+
+bool CMediaImportManager::AddSourceManually(const std::string& importerId,
+                                            const std::string& sourceID,
+                                            const std::string& basePath,
+                                            const std::string& friendlyName,
+                                            const std::string& iconUrl /* = "" */,
+                                            const MediaTypes& mediaTypes /* = MediaTypes() */)
+{
+  CMediaImportSource source(sourceID, basePath, friendlyName, iconUrl, mediaTypes);
+  source.SetImporterId(importerId);
+  return AddSourceManually(source);
+}
+
+bool CMediaImportManager::AddSourceManually(const CMediaImportSource& source)
+{
+  return AddSourceAsync(source, false, true);
+}
+
+bool CMediaImportManager::AddAndActivateSourceManually(
+    const std::string& importerId,
+    const std::string& sourceID,
+    const std::string& basePath,
+    const std::string& friendlyName,
+    const std::string& iconUrl /* = "" */,
+    const MediaTypes& mediaTypes /* = MediaTypes() */)
+{
+  CMediaImportSource source(sourceID, basePath, friendlyName, iconUrl, mediaTypes);
+  source.SetImporterId(importerId);
+  return AddAndActivateSourceManually(source);
+}
+
+bool CMediaImportManager::AddAndActivateSourceManually(const CMediaImportSource& source)
+{
+  return AddSourceAsync(source, true, true);
+}
+
+bool CMediaImportManager::ActivateSource(const std::string& importerId,
+                                         const std::string& sourceID,
+                                         const std::string& basePath /* = "" */,
+                                         const std::string& friendlyName /* = "" */,
+                                         const std::string& iconUrl /* = "" */)
+{
+  CMediaImportSource source(sourceID, basePath, friendlyName, iconUrl);
+  source.SetImporterId(importerId);
+  return ActivateSource(source);
+}
+
+bool CMediaImportManager::ActivateSource(const CMediaImportSource& source)
+{
+  return ActivateSourceAsync(source);
+}
+
+void CMediaImportManager::DeactivateSource(const std::string& sourceID)
+{
+  if (sourceID.empty())
+    return;
+
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    auto&& itSource = m_sources.find(sourceID);
+    if (itSource == m_sources.end() || itSource->second.removing)
+      return;
+
+    itSource->second.active = false;
+    itSource->second.ready = false;
+  }
+
+  // if there are tasks for the source which haven't started yet or are still running try to cancel them
+  CancelJobs(sourceID);
+
+  // disable all items imported from the unregistered source
+  std::vector<CMediaImport> imports = GetImportsBySource(sourceID);
+  {
+    CSingleLock handlersLock(m_importHandlersLock);
+    for (const auto& import : imports)
+    {
+      for (const auto& mediaType : import.GetMediaTypes())
+      {
+        auto&& itHandler = m_importHandlersMap.find(mediaType);
+        if (itHandler != m_importHandlersMap.end())
+        {
+          auto importHandler = std::unique_ptr<IMediaImportHandler>(itHandler->second->Create());
+          importHandler->SetImportedItemsEnabled(import, false);
+        }
+      }
+    }
+  }
+
+  CMediaImportSource source(sourceID);
+  if (!FindSource(sourceID, source))
+    return;
+
+  m_logger->debug("source {} deactivated", source);
+  OnSourceDeactivated(source);
+}
+
+bool CMediaImportManager::UpdateSource(const CMediaImportSource& source)
+{
+  if (source.GetIdentifier().empty())
+    return false;
+
+  bool updated = false;
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    auto&& itSource = m_sources.find(source.GetIdentifier());
+    if (itSource == m_sources.end() || itSource->second.removing)
+      return false;
+
+    bool success = false;
+    {
+      CSingleLock repositoriesLock(m_importRepositoriesLock);
+      // try to update the source in at least one of the repositories
+      for (auto& repository : m_importRepositories)
+      {
+        bool tmpUpdated;
+        if (repository->UpdateSource(source, tmpUpdated))
+        {
+          success = true;
+          updated |= tmpUpdated;
+        }
+      }
+    }
+
+    if (!success)
+      return false;
+  }
+
+  if (updated)
+  {
+    AddJob(source.GetIdentifier(), new CMediaImportSourceReadyJob(source, this));
+
+    m_logger->info("source ready task for {} started", source);
+  }
+
+  return true;
+}
+
+void CMediaImportManager::RemoveSource(const std::string& sourceID)
+{
+  if (sourceID.empty())
+    return;
+
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    auto&& itSource = m_sources.find(sourceID);
+    if (itSource == m_sources.end() || itSource->second.removing)
+      return;
+
+    // mark the source as being removed
+    itSource->second.removing = true;
+  }
+
+  CMediaImportSource source(sourceID);
+  if (!FindSource(sourceID, source))
+    return;
+
+  // if there are tasks for the source which haven't started yet or are still running try to cancel them
+  CancelJobs(sourceID);
+
+  std::vector<CMediaImport> imports;
+  {
+    CSingleLock importRepositoriesLock(m_importRepositoriesLock);
+    for (const auto& repository : m_importRepositories)
+    {
+      std::vector<CMediaImport> repoImports = repository->GetImportsBySource(sourceID);
+      for (auto& import : repoImports)
+        imports.push_back(import);
+    }
+  }
+
+  CMediaImportTaskProcessorJob* processorJob =
+      CMediaImportTaskProcessorJob::Remove(source, imports, this, this);
+  AddJob(source.GetIdentifier(), processorJob);
+
+  m_logger->info("source removal task for {} started", source);
+}
+
+bool CMediaImportManager::HasSources() const
+{
+  return !m_sources.empty();
+}
+
+bool CMediaImportManager::HasSources(bool active) const
+{
+  if (!HasSources())
+    return false;
+
+  CSingleLock sourcesLock(m_sourcesLock);
+  return std::any_of(m_sources.begin(), m_sources.end(),
+                     [active](const std::pair<std::string, MediaImportSource>& source) {
+                       return source.second.active == active;
+                     });
+}
+
+std::vector<CMediaImportSource> CMediaImportManager::GetSources() const
+{
+  std::vector<CMediaImportSource> sources;
+  {
+    CSingleLock lock(m_importRepositoriesLock);
+    for (const auto& repository : m_importRepositories)
+    {
+      std::vector<CMediaImportSource> tmpSources = repository->GetSources();
+      sources.insert(sources.end(), tmpSources.begin(), tmpSources.end());
+    }
+  }
+
+  std::map<std::string, CMediaImportSource> mapSources;
+  {
+    CSingleLock lock(m_sourcesLock);
+    for (auto& source : sources)
+    {
+      const auto& itSourceLocal = m_sources.find(source.GetIdentifier());
+      if (itSourceLocal == m_sources.end() || itSourceLocal->second.removing)
+        continue;
+
+      auto&& itSourceMap = mapSources.find(source.GetIdentifier());
+      if (itSourceMap == mapSources.end())
+      {
+        // add the source to the list
+        source.SetActive(itSourceLocal->second.active);
+        source.SetReady(itSourceLocal->second.ready);
+        mapSources.insert(std::make_pair(source.GetIdentifier(), source));
+      }
+      else
+      {
+        // check if we need to update the last synced timestamp
+        if (itSourceMap->second.GetLastSynced() < source.GetLastSynced())
+          itSourceMap->second.SetLastSynced(source.GetLastSynced());
+
+        // update the list of media types
+        MediaTypes mediaTypes = itSourceMap->second.GetAvailableMediaTypes();
+        mediaTypes.insert(source.GetAvailableMediaTypes().begin(),
+                          source.GetAvailableMediaTypes().end());
+        itSourceMap->second.SetAvailableMediaTypes(mediaTypes);
+      }
+    }
+  }
+
+  sources.clear();
+  for (const auto& itSourceMap : mapSources)
+    sources.push_back(itSourceMap.second);
+
+  return sources;
+}
+
+std::vector<CMediaImportSource> CMediaImportManager::GetSources(bool active) const
+{
+  const auto matchesSourceActive = [active](const CMediaImportSource& source) {
+    return source.IsActive() != active;
+  };
+
+  auto sources = GetSources();
+  sources.erase(std::remove_if(sources.begin(), sources.end(), matchesSourceActive), sources.end());
+  return sources;
+}
+
+bool CMediaImportManager::GetSource(const std::string& sourceID, CMediaImportSource& source) const
+{
+  if (sourceID.empty())
+    return false;
+
+  CSingleLock lock(m_sourcesLock);
+  return GetSourceInternal(sourceID, source);
+}
+
+bool CMediaImportManager::IsSourceActive(const std::string& sourceID) const
+{
+  if (sourceID.empty())
+    return false;
+
+  CSingleLock lock(m_sourcesLock);
+  const auto& itSource = m_sources.find(sourceID);
+  if (itSource == m_sources.end() || itSource->second.removing)
+    return false;
+
+  return itSource->second.active;
+}
+
+bool CMediaImportManager::IsSourceActive(const CMediaImportSource& source) const
+{
+  return IsSourceActive(source.GetIdentifier());
+}
+
+bool CMediaImportManager::IsSourceReady(const std::string& sourceID) const
+{
+  if (sourceID.empty())
+    return false;
+
+  CSingleLock lock(m_sourcesLock);
+  const auto& itSource = m_sources.find(sourceID);
+  if (itSource == m_sources.end() || itSource->second.removing)
+    return false;
+
+  return itSource->second.ready;
+}
+
+bool CMediaImportManager::IsSourceReady(const CMediaImportSource& source) const
+{
+  return IsSourceReady(source.GetIdentifier());
+}
+
+bool CMediaImportManager::HasImports() const
+{
+  if (m_sources.empty())
+    return false;
+
+  CSingleLock importRepositoriesLock(m_importRepositoriesLock);
+  return std::any_of(
+      m_importRepositories.begin(), m_importRepositories.end(),
+      [](const MediaImportRepositoryPtr& repository) { return !repository->GetImports().empty(); });
+}
+
+bool CMediaImportManager::HasImports(const std::string& sourceID) const
+{
+  if (sourceID.empty())
+    return false;
+
+  {
+    CSingleLock lock(m_sourcesLock);
+    const auto& itSource = m_sources.find(sourceID);
+    if (itSource == m_sources.end() || itSource->second.removing)
+      return false;
+  }
+
+  CSingleLock importRepositoriesLock(m_importRepositoriesLock);
+  return std::any_of(m_importRepositories.begin(), m_importRepositories.end(),
+                     [sourceID](const MediaImportRepositoryPtr& repository) {
+                       return !repository->GetImportsBySource(sourceID).empty();
+                     });
+}
+
+bool CMediaImportManager::HasImports(const CMediaImportSource& source) const
+{
+  return HasImports(source.GetIdentifier());
+}
+
+bool CMediaImportManager::AddSelectiveImport(const std::string& sourceID,
+                                             const std::string& path,
+                                             const GroupedMediaTypes& mediaTypes)
+{
+  if (sourceID.empty() || path.empty() || mediaTypes.empty())
+  {
+    m_logger->error("unable to add new selective import from source \"{}\" with "
+                    "path \"{}\" and media type \"{}\"",
+                    sourceID, path, CMediaTypes::Join(mediaTypes));
+    return false;
+  }
+
+  return AddImport(sourceID, path, mediaTypes, false);
+}
+
+bool CMediaImportManager::AddRecursiveImport(const std::string& sourceID,
+                                             const std::string& path,
+                                             const GroupedMediaTypes& mediaTypes)
+{
+  if (sourceID.empty() || path.empty() || mediaTypes.empty())
+  {
+    m_logger->error("unable to add new recursive import from source \"{}\" with "
+                    "path \"{}\" and media type \"{}\"",
+                    sourceID, path, CMediaTypes::Join(mediaTypes));
+    return false;
+  }
+
+  return AddImport(sourceID, path, mediaTypes, true);
+}
+
+bool CMediaImportManager::AddRecursiveImports(const std::string& sourceID,
+                                              const std::string& path,
+                                              const std::set<GroupedMediaTypes>& mediaTypes)
+{
+  if (sourceID.empty() || path.empty() || mediaTypes.empty())
+  {
+    m_logger->error("unable to add new recursive imports from source \"{}\" with "
+                    "path \"{}\" and media types ({})",
+                    sourceID, path, mediaTypes.size());
+    return false;
+  }
+
+  // check if the given source exists
+  std::vector<CMediaImport> addedImports;
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+
+    CMediaImportSource source(sourceID);
+    auto&& itSource = m_sources.find(sourceID);
+    if (itSource == m_sources.end() || // source doesn't exist
+        itSource->second.removing || !FindSource(sourceID, source))
+    {
+      m_logger->warn("trying to add new recursive imports from unknown source \"{}\"", sourceID);
+      return false;
+    }
+
+    CSingleLock importHandlersLock(m_importHandlersLock);
+    for (const auto& itMediaTypes : mediaTypes)
+    {
+      // check if the import already exists
+      CMediaImport import;
+      if (FindImport(path, itMediaTypes, import))
+      {
+        m_logger->error("unable to add already existing recursive import from "
+                        "source \"{}\" with path \"{}\" and media type \"{}\"",
+                        sourceID, path, CMediaTypes::Join(itMediaTypes));
+        continue;
+      }
+
+      bool mediaTypesHandled = true;
+      for (const auto& mediaType : itMediaTypes)
+      {
+        // check if there's an import handler that can handle the given media type
+        if (m_importHandlersMap.find(mediaType) == m_importHandlersMap.end())
+        {
+          m_logger->error(
+              "unable to add new recursive import from source \"{}\" "
+              "with path \"{}\" and media type \"{}\" because there is no matching import "
+              "handler available",
+              sourceID, path, mediaType);
+          mediaTypesHandled = false;
+          break;
+        }
+      }
+
+      if (!mediaTypesHandled)
+        continue;
+
+      CMediaImport newImport = CMediaImport::CreateRecursive(path, itMediaTypes, source);
+      if (!AddImport(newImport))
+      {
+        m_logger->error("failed to add new recursive import for source \"{}\" with "
+                        "path \"{}\" and media type \"{}\" to any import repository",
+                        sourceID, path, CMediaTypes::Join(itMediaTypes));
+        continue;
+      }
+
+      addedImports.push_back(newImport);
+    }
+  }
+
+  for (const auto& import : addedImports)
+    OnImportAdded(import);
+
+  return true;
+}
+
+bool CMediaImportManager::UpdateImport(const CMediaImport& import)
+{
+  if (import.GetPath().empty() || import.GetMediaTypes().empty())
+    return false;
+
+  bool success = false;
+  bool updated = false;
+  {
+    CSingleLock importRepositoriesLock(m_importRepositoriesLock);
+    for (const auto& repository : m_importRepositories)
+    {
+      bool tmpUpdated;
+      if (repository->UpdateImport(import, tmpUpdated))
+      {
+        success = true;
+        updated |= tmpUpdated;
+      }
+    }
+  }
+
+  if (!success)
+    return false;
+
+  if (updated)
+    OnImportUpdated(import);
+
+  return true;
+}
+
+void CMediaImportManager::RemoveImport(const std::string& path, const GroupedMediaTypes& mediaTypes)
+{
+  if (path.empty() || mediaTypes.empty())
+    return;
+
+  CMediaImport import;
+  if (!FindImport(path, mediaTypes, import))
+    return;
+
+  CMediaImportTaskProcessorJob* processorJob =
+      CMediaImportTaskProcessorJob::Remove(import, this, this);
+  AddJob(import.GetSource().GetIdentifier(), processorJob);
+
+  m_logger->info("import removal task for {} started", import);
+}
+
+std::vector<CMediaImport> CMediaImportManager::GetImports() const
+{
+  std::vector<CMediaImport> imports;
+  {
+    CSingleLock importRepositoriesLock(m_importRepositoriesLock);
+    for (const auto& repository : m_importRepositories)
+    {
+      std::vector<CMediaImport> repoImports = repository->GetImports();
+      imports.insert(imports.end(), repoImports.begin(), repoImports.end());
+    }
+  }
+
+  PrepareImports(imports);
+  return imports;
+}
+
+std::vector<CMediaImport> CMediaImportManager::GetImportsByMediaType(
+    const GroupedMediaTypes& mediaTypes) const
+{
+  std::vector<CMediaImport> imports;
+  if (mediaTypes.empty())
+    return imports;
+
+  {
+    CSingleLock importRepositoriesLock(m_importRepositoriesLock);
+    for (const auto& repository : m_importRepositories)
+    {
+      std::vector<CMediaImport> repoImports = repository->GetImportsByMediaType(mediaTypes);
+      imports.insert(imports.end(), repoImports.begin(), repoImports.end());
+    }
+  }
+
+  PrepareImports(imports);
+  return imports;
+}
+
+std::vector<CMediaImport> CMediaImportManager::GetImportsBySource(const std::string& sourceID) const
+{
+  std::vector<CMediaImport> imports;
+  if (sourceID.empty())
+    return imports;
+
+  CSingleLock sourcesLock(m_sourcesLock);
+  const auto& itSource = m_sources.find(sourceID);
+  if (itSource == m_sources.end() || itSource->second.removing)
+    return imports;
+
+  {
+    CSingleLock importRepositoriesLock(m_importRepositoriesLock);
+    for (const auto& repository : m_importRepositories)
+    {
+      std::vector<CMediaImport> repoImports = repository->GetImportsBySource(sourceID);
+      imports.insert(imports.end(), repoImports.begin(), repoImports.end());
+    }
+  }
+
+  PrepareImports(imports);
+  return imports;
+}
+
+std::vector<CMediaImport> CMediaImportManager::GetImportsByPath(
+    const std::string& path, bool includeSubDirectories /* = false */) const
+{
+  std::vector<CMediaImport> imports;
+  if (path.empty())
+    return imports;
+
+  {
+    CSingleLock importRepositoriesLock(m_importRepositoriesLock);
+    for (const auto& repository : m_importRepositories)
+    {
+      std::vector<CMediaImport> repoImports =
+          repository->GetImportsByPath(path, includeSubDirectories);
+      imports.insert(imports.end(), repoImports.begin(), repoImports.end());
+    }
+  }
+
+  PrepareImports(imports);
+  return imports;
+}
+
+bool CMediaImportManager::GetImport(const std::string& path,
+                                    const GroupedMediaTypes& mediaTypes,
+                                    CMediaImport& import) const
+{
+  if (path.empty())
+    return false;
+
+  return FindImport(path, mediaTypes, import);
+}
+
+bool CMediaImportManager::IsImportReady(const std::string& path,
+                                        const GroupedMediaTypes& mediaTypes) const
+{
+  CMediaImport import(path);
+  return GetImport(path, mediaTypes, import) && IsImportReady(import);
+}
+
+bool CMediaImportManager::IsImportReady(const CMediaImport& import) const
+{
+  // try to get an importer that can import the given path
+  const auto& importer = GetImporterBySource(import.GetSource());
+  if (importer == nullptr)
+    return false;
+
+  CMediaImport tmpImport(import);
+  return importer->IsImportReady(tmpImport);
+}
+
+bool CMediaImportManager::IsImported(const std::string& path) const
+{
+  return !GetImportsByPath(path, false).empty();
+}
+
+bool CMediaImportManager::IsImportedInHierarchy(const std::string& path) const
+{
+  return !GetImportsByPath(path, true).empty();
+}
+
+bool CMediaImportManager::Import()
+{
+  bool result = false;
+  CSingleLock sourcesLock(m_sourcesLock);
+  for (const auto& source : m_sources)
+  {
+    if (!source.second.active || !source.second.ready || source.second.removing)
+      continue;
+
+    result |= Import(source.first);
+  }
+
+  return result;
+}
+
+bool CMediaImportManager::Import(const std::string& sourceID)
+{
+  if (sourceID.empty())
+  {
+    m_logger->warn("unable to import from an empty source identifier");
+    return false;
+  }
+
+  CMediaImportSource source(sourceID);
+  if (!FindSource(sourceID, source))
+    return false;
+
+  Import(source, false);
+  return true;
+}
+
+bool CMediaImportManager::Import(const std::string& path, const GroupedMediaTypes& mediaTypes)
+{
+  if (path.empty() || mediaTypes.empty())
+  {
+    m_logger->warn("unable to import from invalid path \"{}\" or without media types ({})", path,
+                   CMediaTypes::Join(mediaTypes));
+    return false;
+  }
+
+  CMediaImport import;
+  if (!FindImport(path, mediaTypes, import))
+    return false;
+
+  // check if the source exists and is active
+  CSingleLock sourcesLock(m_sourcesLock);
+  auto&& itSource = m_sources.find(import.GetSource().GetIdentifier());
+  if (itSource == m_sources.end() || // source doesn't exist
+      itSource->second.removing || !itSource->second.active)
+  {
+    m_logger->warn("unable to import from unregistered source \"{}\"", import.GetSource());
+    return false;
+  }
+
+  // import media items from the given import (and all other imports whose media types depend upon this import's one or are grouped together with it)
+  Import(import);
+
+  return true;
+}
+
+void CMediaImportManager::Import(const CMediaImportSource& source, bool automatically /* = false */)
+{
+  auto& sourceInfo = m_sources[source.GetIdentifier()];
+  if (!sourceInfo.active || !sourceInfo.ready)
+    return;
+
+  auto imports = GetImportsBySource(source.GetIdentifier());
+  bool importStarted = false;
+  for (const auto& import : imports)
+  {
+    auto processorJob =
+        CMediaImportTaskProcessorJob::Import(import, automatically, this, this, this);
+    if (processorJob == nullptr)
+      continue;
+
+    AddJob(source.GetIdentifier(), processorJob);
+    importStarted = true;
+  }
+
+  if (importStarted)
+    m_logger->info("import tasks for source {} started", source);
+}
+
+void CMediaImportManager::Import(const CMediaImport& import, bool automatically /* = false */)
+{
+  CMediaImportTaskProcessorJob* processorJob =
+      CMediaImportTaskProcessorJob::Import(import, automatically, this, this, this);
+  AddJob(import.GetSource().GetIdentifier(), processorJob);
+
+  m_logger->info("import task for {} started", import);
+}
+
+CMediaImportManager::MediaImporterMap::iterator CMediaImportManager::GetImporterBySourceInternal(
+    const std::string& sourceId)
+{
+  CSingleLock sourcesLock(m_sourcesLock);
+  const auto& source = m_sources.find(sourceId);
+  if (source == m_sources.end() || source->second.importerId.empty())
+    return m_importers.end();
+
+  return m_importers.find(source->second.importerId);
+}
+
+void CMediaImportManager::PrepareImports(std::vector<CMediaImport>& imports) const
+{
+  CSingleLock sourcesLock(m_sourcesLock);
+  for (auto itImport = imports.begin(); itImport != imports.end();)
+  {
+    const auto& itSource = m_sources.find(itImport->GetSource().GetIdentifier());
+    if (itSource == m_sources.end() || itSource->second.removing)
+      itImport = imports.erase(itImport);
+    else
+    {
+      itImport->SetActive(itSource->second.active);
+      itImport->SetReady(itSource->second.ready);
+      ++itImport;
+    }
+  }
+}
+
+bool CMediaImportManager::AddSourceAsync(CMediaImportSource source,
+                                         bool activate,
+                                         bool manuallyAdded)
+{
+  if (source.GetIdentifier().empty() || source.GetFriendlyName().empty())
+  {
+    m_logger->warn("unable to add source {}", source);
+    return false;
+  }
+
+  source.SetManuallyAdded(manuallyAdded);
+  if (source.GetImporterId().empty() || !HasImporter(source.GetImporterId()))
+  {
+    m_logger->warn("unable to add source {} with invalid importer \"{}\"", source,
+                   source.GetImporterId());
+    return false;
+  }
+
+  bool sourceFound = false;
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    CMediaImportSource currentSource;
+    auto&& itSource = m_sources.find(source.GetIdentifier());
+    if (itSource != m_sources.end() && FindSource(source.GetIdentifier(), currentSource))
+      sourceFound = true;
+  }
+
+  if (sourceFound)
+  {
+    if (activate)
+      return ActivateSourceAsync(source);
+
+    return true;
+  }
+
+  AddJob(source.GetIdentifier(), new CMediaImportSourceRegistrationJob(source, activate, this));
+
+  m_logger->info("source registration task for {} started", source);
+
+  return true;
+}
+
+bool CMediaImportManager::AddSourceSync(const CMediaImportSource& source)
+{
+  const auto importerId = source.GetImporterId();
+  if (importerId.empty() || !HasImporter(importerId))
+    return false;
+
+  bool success = false;
+  bool added = false;
+  CSingleLock repositoriesLock(m_importRepositoriesLock);
+  // try to add the source to at least one of the repositories
+  for (auto& repository : m_importRepositories)
+  {
+    bool tmpAdded;
+    if (repository->AddSource(source, tmpAdded))
+    {
+      success = true;
+      added |= tmpAdded;
+    }
+  }
+
+  if (!success)
+    return false;
+
+  if (!added)
+    return true;
+
+  MediaImportSource importSource = {importerId, true, false, false};
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    m_sources.emplace(source.GetIdentifier(), importSource);
+  }
+
+  m_logger->debug("new source {} registered", source);
+
+  return true;
+}
+
+bool CMediaImportManager::ActivateSourceAsync(const CMediaImportSource& source)
+{
+  if (source.GetIdentifier().empty())
+  {
+    m_logger->warn("unable to activate invalid source {}", source);
+    return false;
+  }
+
+  const auto importerId = source.GetImporterId();
+  if (importerId.empty() || !HasImporter(importerId))
+  {
+    m_logger->warn("unable to activate source {} with invalid importer \"{}\"", source, importerId);
+    return false;
+  }
+
+  CMediaImportSource updatedSource;
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    auto&& itSource = m_sources.find(source.GetIdentifier());
+    if (itSource == m_sources.end() || !FindSource(source.GetIdentifier(), updatedSource))
+    {
+      m_logger->warn("unable to activate unknown source {}", source);
+      return false;
+    }
+  }
+
+  // update any provided values from the existing source
+  if (!source.GetBasePath().empty())
+    updatedSource.SetBasePath(source.GetBasePath());
+  if (!source.GetFriendlyName().empty())
+    updatedSource.SetFriendlyName(source.GetFriendlyName());
+  if (!source.GetIconUrl().empty())
+    updatedSource.SetIconUrl(source.GetIconUrl());
+
+  AddJob(source.GetIdentifier(), new CMediaImportSourceActivationJob(updatedSource, this));
+
+  m_logger->info("source activation task for {} started", source);
+
+  return true;
+}
+
+bool CMediaImportManager::ActivateSourceSync(const CMediaImportSource& source, bool ready)
+{
+  const auto importerId = source.GetImporterId();
+  if (importerId.empty() || !HasImporter(importerId))
+    return false;
+
+  bool updated = false;
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    CMediaImportSource currentSource;
+    auto&& itSource = m_sources.find(source.GetIdentifier());
+    if (itSource == m_sources.end() || !FindSource(source.GetIdentifier(), currentSource))
+      return false;
+
+    {
+      CSingleLock repositoriesLock(m_importRepositoriesLock);
+      // try to update the source in at least one of the repositories
+      for (auto& repository : m_importRepositories)
+      {
+        bool tmpUpdated;
+        if (repository->UpdateSource(source, tmpUpdated))
+        {
+          updated |= tmpUpdated;
+        }
+      }
+    }
+
+    // update the source's active flag
+    itSource->second.active = true;
+    // update the source's ready flag
+    itSource->second.ready = ready;
+  }
+  m_logger->debug("source {} activated", source);
+
+  if (updated)
+  {
+    m_logger->debug("source {} updated", source);
+    OnSourceUpdated(source);
+  }
+
+  OnSourceActivated(source);
+
+  // start processing all imports of the source
+  Import(source, true);
+
+  return true;
+}
+
+bool CMediaImportManager::GetSourceInternal(const std::string& sourceID,
+                                            CMediaImportSource& source) const
+{
+  const auto& itSource = m_sources.find(sourceID);
+  if (itSource == m_sources.end() || itSource->second.removing)
+    return false;
+
+  if (!FindSource(sourceID, source))
+    return false;
+
+  source.SetActive(itSource->second.active);
+  source.SetReady(itSource->second.ready);
+  return true;
+}
+
+bool CMediaImportManager::FindSource(const std::string& sourceID, CMediaImportSource& source) const
+{
+  CSingleLock repositoriesLock(m_importRepositoriesLock);
+  // try to find the source in at least one of the repositories
+  return std::any_of(m_importRepositories.begin(), m_importRepositories.end(),
+                     [&sourceID, &source](const MediaImportRepositoryPtr& repository) {
+                       return repository->GetSource(sourceID, source);
+                     });
+}
+
+void CMediaImportManager::UpdateManuallyAddedSources()
+{
+  // get a copy of all sources
+  std::vector<std::tuple<std::string, bool>> sourceInfos;
+  {
+    CSingleLock lock(m_sourcesLock);
+    for (const auto& it : m_sources)
+    {
+      if (!it.second.removing)
+        sourceInfos.emplace_back(it.first, it.second.active);
+    }
+  }
+
+  // check all manually added sources
+  for (const auto& sourceInfo : sourceInfos)
+  {
+    const auto sourceId = std::get<0>(sourceInfo);
+    CMediaImportSource source(sourceId);
+    if (!GetSourceInternal(sourceId, source))
+      continue;
+
+    // ignore automatically added sources
+    if (!source.IsManuallyAdded())
+      continue;
+
+    // find the matching importer
+    bool active = false;
+    if (LookupSource(source))
+      active = true;
+
+    const auto wasActive = std::get<1>(sourceInfo);
+    // activate / deactivate the source if necessary
+    if (active && !wasActive)
+      ActivateSource(source);
+    else if (!active && wasActive)
+      DeactivateSource(source.GetIdentifier());
+  }
+}
+
+bool CMediaImportManager::LookupSource(const CMediaImportSource& source)
+{
+  auto importer = GetImporterBySource(source);
+  if (importer == nullptr)
+    return false;
+
+  if (!importer->CanLookupSource())
+    return false;
+
+  return importer->LookupSource(source);
+}
+
+bool CMediaImportManager::AddImport(const std::string& sourceID,
+                                    const std::string& path,
+                                    const GroupedMediaTypes& mediaTypes,
+                                    bool recursive)
+{
+  // check if the import already exists
+  CMediaImport import;
+  if (FindImport(path, mediaTypes, import))
+  {
+    m_logger->error("unable to add already existing import from source \"{}\" with "
+                    "path \"{}\" and media type \"{}\"",
+                    sourceID, path, CMediaTypes::Join(mediaTypes));
+    return false;
+  }
+
+  // check if the given source exists
+  CMediaImportSource source(sourceID);
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    if (!GetSourceInternal(sourceID, source))
+    {
+      m_logger->warn("trying to add new import from unknown source \"{}\"", sourceID);
+      return false;
+    }
+  }
+
+  {
+    CSingleLock importHandlersLock(m_importHandlersLock);
+    for (const auto& mediaType : mediaTypes)
+    {
+      // check if there's an import handler that can handle the given media type
+      if (m_importHandlersMap.find(mediaType) == m_importHandlersMap.end())
+      {
+        m_logger->error("unable to add new import from source \"{}\" with path \"{}\" and "
+                        "media type \"{}\" because there is no matching import handler available",
+                        sourceID, path, mediaType);
+        return false;
+      }
+    }
+  }
+
+  CMediaImport newImport;
+  if (recursive)
+    newImport = CMediaImport::CreateRecursive(path, mediaTypes, source);
+  else
+    newImport = CMediaImport::CreateSelective(path, mediaTypes, source);
+
+  if (!AddImport(newImport))
+  {
+    m_logger->error("failed to add new import for source \"{}\" with path \"{}\" "
+                    "and media type \"{}\" to any import repository",
+                    sourceID, path, CMediaTypes::Join(mediaTypes));
+    return false;
+  }
+
+  OnImportAdded(newImport);
+
+  return true;
+}
+
+bool CMediaImportManager::AddImport(const CMediaImport& import)
+{
+  bool success = false;
+  bool added = false;
+  CSingleLock repositoriesLock(m_importRepositoriesLock);
+  // try to add the import to at least one of the repositories
+  for (auto& repository : m_importRepositories)
+  {
+    bool tmpAdded;
+    if (repository->AddImport(import, tmpAdded))
+    {
+      success = true;
+      added |= tmpAdded;
+    }
+  }
+
+  if (!success)
+    return false;
+
+  return true;
+}
+
+bool CMediaImportManager::FindImport(const std::string& path,
+                                     const GroupedMediaTypes& mediaTypes,
+                                     CMediaImport& import) const
+{
+  CSingleLock repositoriesLock(m_importRepositoriesLock);
+  // try to find the import in at least one of the repositories
+  return std::any_of(m_importRepositories.begin(), m_importRepositories.end(),
+                     [&path, &mediaTypes, &import](const MediaImportRepositoryPtr& repository) {
+                       return repository->GetImport(path, mediaTypes, import);
+                     });
+}
+
+bool CMediaImportManager::AddImportedItems(const CMediaImport& import, const CFileItemList& items)
+{
+  // make sure the import is known
+  CMediaImport tmpImport;
+  if (!FindImport(import.GetPath(), import.GetMediaTypes(), tmpImport))
+    return false;
+
+  ChangesetItems changedItems;
+  // make sure the items belong to the media import
+  for (const auto& item : items)
+  {
+    // check the media type
+    if (!IsMediaTypeSupported(item->GetMediaType()) ||
+        !import.ContainsMediaType(item->GetMediaType()))
+    {
+      m_logger->warn("item {} with media type \"{}\" not supported by the given "
+                     "media import",
+                     item->GetPath(), item->GetMediaType());
+      continue;
+    }
+
+    changedItems.push_back(std::make_pair(MediaImportChangesetType::Added, item));
+  }
+
+  if (changedItems.empty())
+    return false;
+
+  CMediaImportTaskProcessorJob* processorJob =
+      CMediaImportTaskProcessorJob::ChangeImportedItems(import, changedItems, this, this);
+  AddJob(import.GetSource().GetIdentifier(), processorJob);
+
+  m_logger->info("add imported items task for {} started", import);
+
+  return true;
+}
+
+bool CMediaImportManager::UpdateImportedItems(const CMediaImport& import,
+                                              const CFileItemList& items)
+{
+  // make sure the import is known
+  CMediaImport tmpImport;
+  if (!FindImport(import.GetPath(), import.GetMediaTypes(), tmpImport))
+    return false;
+
+  ChangesetItems changedItems;
+  // make sure the items belong to the media import
+  for (const auto& item : items)
+  {
+    // check the media type
+    if (!IsMediaTypeSupported(item->GetMediaType()) ||
+        !import.ContainsMediaType(item->GetMediaType()))
+    {
+      m_logger->warn("item {} with media type \"{}\" not supported by the given "
+                     "media import",
+                     item->GetPath(), item->GetMediaType());
+      continue;
+    }
+
+    changedItems.push_back(std::make_pair(MediaImportChangesetType::Changed, item));
+  }
+
+  if (changedItems.empty())
+    return false;
+
+  CMediaImportTaskProcessorJob* processorJob =
+      CMediaImportTaskProcessorJob::ChangeImportedItems(import, changedItems, this, this);
+  AddJob(import.GetSource().GetIdentifier(), processorJob);
+
+  m_logger->info("update imported items task for {} started", import);
+
+  return true;
+}
+
+bool CMediaImportManager::RemoveImportedItems(const CMediaImport& import,
+                                              const CFileItemList& items)
+{
+  // make sure the import is known
+  CMediaImport tmpImport;
+  if (!FindImport(import.GetPath(), import.GetMediaTypes(), tmpImport))
+    return false;
+
+  ChangesetItems changedItems;
+  // make sure the items belong to the media import
+  for (const auto& item : items)
+  {
+    // check the media type
+    if (!IsMediaTypeSupported(item->GetMediaType()) ||
+        !import.ContainsMediaType(item->GetMediaType()))
+    {
+      m_logger->warn("item {} with media type \"{}\" not supported by the given "
+                     "media import",
+                     item->GetPath(), item->GetMediaType());
+      continue;
+    }
+
+    changedItems.push_back(std::make_pair(MediaImportChangesetType::Removed, item));
+  }
+
+  if (changedItems.empty())
+    return false;
+
+  CMediaImportTaskProcessorJob* processorJob =
+      CMediaImportTaskProcessorJob::ChangeImportedItems(import, changedItems, this, this);
+  AddJob(import.GetSource().GetIdentifier(), processorJob);
+
+  m_logger->info("remove imported items task from {} started", import);
+
+  return true;
+}
+
+bool CMediaImportManager::ChangeImportedItems(const CMediaImport& import,
+                                              const ChangesetItems& items)
+{
+  // make sure the import is known
+  CMediaImport tmpImport;
+  if (!FindImport(import.GetPath(), import.GetMediaTypes(), tmpImport))
+    return false;
+
+  ChangesetItems changedItems;
+  // make sure the items belong to the media import
+  for (const auto& item : items)
+  {
+    // check the media type
+    if (!IsMediaTypeSupported(item.second->GetMediaType()) ||
+        !import.ContainsMediaType(item.second->GetMediaType()))
+    {
+      m_logger->warn("item {} with media type \"{}\" not supported by the given "
+                     "media import",
+                     item.second->GetPath(), item.second->GetMediaType());
+      continue;
+    }
+
+    changedItems.push_back(item);
+  }
+
+  if (changedItems.empty())
+    return false;
+
+  CMediaImportTaskProcessorJob* processorJob =
+      CMediaImportTaskProcessorJob::ChangeImportedItems(import, changedItems, this, this);
+  AddJob(import.GetSource().GetIdentifier(), processorJob);
+
+  m_logger->info("change imported items task for {} started", import);
+
+  return true;
+}
+
+bool CMediaImportManager::UpdateImportedItemOnSource(const CFileItem& item)
+{
+  if (!item.IsImported())
+    return false;
+
+  std::string sourceID = item.GetSource();
+  std::string importPath = item.GetImportPath();
+
+  if (!IsMediaTypeSupported(item.GetMediaType()))
+  {
+    m_logger->warn("unable to update {} due to unknown media type", item.GetPath());
+    return false;
+  }
+
+  // get all media types belonging to the item's media type
+  GroupedMediaTypes mediaTypes = GetGroupedMediaTypes(item.GetMediaType());
+  if (mediaTypes.empty())
+  {
+    m_logger->warn("unable to update {} due to unsupported media type ({})", item.GetPath(),
+                   item.GetMediaType());
+    return false;
+  }
+
+  CMediaImport import;
+  if (!FindImport(importPath, mediaTypes, import))
+  {
+    m_logger->warn("unable to update {} due to no import found for {} of {}", item.GetPath(),
+                   importPath, CMediaTypes::Join(mediaTypes));
+    return false;
+  }
+
+  if (!import.Settings()->UpdatePlaybackMetadataOnSource())
+    return false;
+
+  if (!m_sources[import.GetSource().GetIdentifier()].active)
+  {
+    m_logger->warn("unable to update item {} on inactive source {}", item.GetPath(),
+                   import.GetSource().GetIdentifier());
+    return false;
+  }
+
+  CMediaImportTaskProcessorJob* processorJob =
+      CMediaImportTaskProcessorJob::UpdateImportedItemOnSource(import, item, this, this);
+  AddJob(import.GetSource().GetIdentifier(), processorJob);
+
+  m_logger->info("import update task for {} on {} started", item.GetPath(), import);
+
+  return true;
+}
+
+std::vector<CFileItemPtr> CMediaImportManager::GetImportedItemsBySource(
+    const CMediaImportSource& source) const
+{
+  std::vector<CFileItemPtr> items;
+  const auto imports = GetImportsBySource(source.GetIdentifier());
+  for (const auto& import : imports)
+  {
+    const auto importedItems = GetImportedItemsByImport(import);
+    items.insert(items.end(), importedItems.begin(), importedItems.end());
+  }
+
+  return items;
+}
+
+std::vector<CFileItemPtr> CMediaImportManager::GetImportedItemsByImport(
+    const CMediaImport& import) const
+{
+  // make sure the import is known
+  CMediaImport tmpImport;
+  if (!FindImport(import.GetPath(), import.GetMediaTypes(), tmpImport))
+    return {};
+
+  std::map<MediaType, MediaImportHandlerPtr> importHandlers;
+  for (const auto& mediaType : import.GetMediaTypes())
+  {
+    const auto importHandler = GetImportHandler(mediaType);
+    if (importHandler == nullptr)
+    {
+      m_logger->warn("no import handler for unknown media type \"{}\" for import {}", mediaType,
+                     import);
+      continue;
+    }
+    importHandlers.emplace(mediaType, importHandler->Create());
+  }
+
+  CMediaImportLocalItemsRetrievalTask localItemsRetrievalTask(tmpImport, importHandlers);
+  if (!localItemsRetrievalTask.DoWork())
+  {
+    m_logger->warn("failed to retrieve imported items for import {}", import);
+    return {};
+  }
+
+  std::vector<CFileItemPtr> items;
+  for (const auto& mediaType : import.GetMediaTypes())
+  {
+    const auto& importedItems = localItemsRetrievalTask.GetLocalItems(mediaType);
+    items.insert(items.end(), importedItems.begin(), importedItems.end());
+  }
+  return items;
+}
+
+void CMediaImportManager::AddJob(const std::string& sourceID, CMediaImportSourceJobBase* job)
+{
+  if (job == nullptr)
+    return;
+
+  CSingleLock jobsLock(m_sourceJobsLock);
+  m_sourceJobMap[sourceID].insert(job);
+
+  CJobQueue::AddJob(job);
+}
+
+void CMediaImportManager::AddJob(const std::string& sourceID, CMediaImportTaskProcessorJob* job)
+{
+  if (job == nullptr)
+    return;
+
+  CSingleLock jobsLock(m_importJobsLock);
+  m_importJobMap[sourceID].insert(job);
+
+  CLibraryQueue::GetInstance().AddJob(job, this);
+}
+
+template<class TJob>
+void RemoveJob(const std::string& sourceID,
+               const TJob* job,
+               std::map<std::string, std::set<TJob*>>& jobMap,
+               Logger logger)
+{
+  auto&& itJobs = jobMap.find(sourceID);
+  if (itJobs != jobMap.end())
+  {
+    itJobs->second.erase(const_cast<TJob*>(job));
+    if (itJobs->second.empty())
+      jobMap.erase(itJobs);
+  }
+  else
+    logger->warn("failed to remove task for source \"{}\"", sourceID);
+}
+
+void CMediaImportManager::RemoveJob(const std::string& sourceID,
+                                    const CMediaImportSourceJobBase* job)
+{
+  CSingleLock jobsLock(m_sourceJobsLock);
+  ::RemoveJob(sourceID, job, m_sourceJobMap, m_logger);
+}
+
+void CMediaImportManager::RemoveJob(const std::string& sourceID,
+                                    const CMediaImportTaskProcessorJob* job)
+{
+  CSingleLock jobsLock(m_importJobsLock);
+  ::RemoveJob(sourceID, job, m_importJobMap, m_logger);
+}
+
+void CMediaImportManager::CancelJobs(const std::string& sourceID)
+{
+  bool cancelled = false;
+  {
+    CSingleLock jobsLock(m_importJobsLock);
+    const auto& itJobs = m_importJobMap.find(sourceID);
+    if (itJobs != m_importJobMap.end())
+    {
+      for (const auto& itJob : itJobs->second)
+      {
+        if (itJob != nullptr)
+          CLibraryQueue::GetInstance().CancelJob(itJob);
+      }
+
+      m_importJobMap.erase(sourceID);
+      cancelled = true;
+    }
+  }
+
+  {
+    CSingleLock jobsLock(m_sourceJobsLock);
+    const auto& itJobs = m_sourceJobMap.find(sourceID);
+    if (itJobs != m_sourceJobMap.end())
+    {
+      for (const auto& itJob : itJobs->second)
+      {
+        if (itJob != nullptr)
+          CJobQueue::CancelJob(itJob);
+      }
+
+      m_sourceJobMap.erase(sourceID);
+      cancelled = true;
+    }
+  }
+
+  if (cancelled)
+    m_logger->debug("tasks for {} cancelled", sourceID);
+}
+
+void CMediaImportManager::CancelAllJobs()
+{
+  std::set<std::string> sources;
+  {
+    CSingleLock jobsLock(m_sourceJobsLock);
+    for (const auto& itJobs : m_sourceJobMap)
+      sources.insert(itJobs.first);
+  }
+  {
+    CSingleLock jobsLock(m_importJobsLock);
+    for (const auto& itJobs : m_importJobMap)
+      sources.insert(itJobs.first);
+  }
+
+  for (const auto& source : sources)
+    CancelJobs(source);
+}
+
+void CMediaImportManager::OnSourceJobComplete(const CMediaImportSourceJobBase* sourceJob,
+                                              bool success)
+{
+  const std::string sourceJobType = sourceJob->GetType();
+  if (sourceJobType == "MediaImportSourceRegistrationJob")
+  {
+    const auto sourceRegistrationTask =
+        dynamic_cast<const CMediaImportSourceRegistrationJob*>(sourceJob);
+    if (sourceRegistrationTask == nullptr)
+      return;
+
+    const auto& source = sourceRegistrationTask->GetSource();
+
+    // nothing to do if the import job failed
+    if (!success)
+    {
+      m_logger->warn("source registration task for {} failed", source);
+      return;
+    }
+
+    if (!AddSourceSync(source))
+    {
+      m_logger->warn("source {} couldn't be added to any import repository", source);
+      return;
+    }
+    OnSourceAdded(source);
+
+    // check if the source should also be activated
+    if (sourceRegistrationTask->ActivateSource())
+    {
+      if (!ActivateSourceSync(source, sourceRegistrationTask->IsSourceReady()))
+      {
+        m_logger->warn("source {} couldn't be activated", source);
+        return;
+      }
+    }
+  }
+  else if (sourceJobType == "MediaImportSourceActivationJob")
+  {
+    const auto sourceActivationTask =
+        dynamic_cast<const CMediaImportSourceActivationJob*>(sourceJob);
+    if (sourceActivationTask == nullptr)
+      return;
+
+    const auto& source = sourceActivationTask->GetSource();
+
+    // nothing to do if the import job failed
+    if (!success)
+    {
+      m_logger->warn("source activation task for {} failed", source);
+      return;
+    }
+
+    if (!ActivateSourceSync(source, sourceActivationTask->IsSourceReady()))
+    {
+      m_logger->warn("source {} couldn't be activated", source);
+      return;
+    }
+  }
+  else if (sourceJobType == "MediaImportSourceReadyJob")
+  {
+    const auto sourceReadyTask = dynamic_cast<const CMediaImportSourceReadyJob*>(sourceJob);
+    if (sourceReadyTask == nullptr)
+      return;
+
+    const auto& source = sourceReadyTask->GetSource();
+
+    // nothing to do if the import job failed
+    if (!success)
+    {
+      m_logger->warn("source ready task for {} failed", source);
+      return;
+    }
+
+    {
+      CSingleLock sourcesLock(m_sourcesLock);
+      auto&& itSource = m_sources.find(source.GetIdentifier());
+      if (itSource == m_sources.end())
+        return;
+
+      itSource->second.ready = sourceReadyTask->IsSourceReady();
+    }
+
+    m_logger->debug("source ready for {} updated", source);
+    OnSourceUpdated(source);
+  }
+  else
+    m_logger->warn("unknown source job of type \"{}\" completed", sourceJobType);
+}
+
+void CMediaImportManager::OnJobComplete(unsigned int jobID, bool success, CJob* job)
+{
+  if (job == nullptr)
+    return;
+
+  std::string sourceID;
+  auto taskProcessorJob = dynamic_cast<CMediaImportTaskProcessorJob*>(job);
+  if (taskProcessorJob != nullptr)
+  {
+    sourceID = taskProcessorJob->GetPath();
+    RemoveJob(taskProcessorJob->GetPath(), taskProcessorJob);
+  }
+  else
+  {
+    auto sourceJob = dynamic_cast<CMediaImportSourceJobBase*>(job);
+    if (sourceJob == nullptr)
+    {
+      m_logger->warn("unknown job of type \"{}\" completed", job->GetType());
+      return;
+    }
+
+    OnSourceJobComplete(sourceJob, success);
+
+    const auto source = sourceJob->GetSource();
+    UpdateSource(source);
+
+    sourceID = source.GetIdentifier();
+    RemoveJob(sourceID, sourceJob);
+    CJobQueue::OnJobComplete(jobID, success, job);
+  }
+
+  if (!sourceID.empty())
+  {
+    CSingleLock sourcesLock(m_sourcesLock);
+    // check if the source belonging to the completed process is being removed
+    auto itSource = m_sources.find(sourceID);
+    if (itSource != m_sources.end() && itSource->second.removing)
+    {
+      CMediaImportSource source(sourceID);
+      if (FindSource(sourceID, source))
+      {
+        {
+          CSingleLock repositoriesLock(m_importRepositoriesLock);
+          for (auto& repository : m_importRepositories)
+            repository->RemoveSource(sourceID);
+        }
+
+        m_sources.erase(itSource);
+        sourcesLock.Leave();
+
+        OnSourceRemoved(source);
+        m_logger->debug("source {} removed", source);
+      }
+    }
+  }
+}
+
+void CMediaImportManager::OnJobProgress(unsigned int jobID,
+                                        unsigned int progress,
+                                        unsigned int total,
+                                        const CJob* job)
+{
+  if (job == nullptr)
+    return;
+
+  if (strcmp(job->GetType(), "MediaImportTaskProcessorJob") == 0)
+  {
+    const CMediaImportTaskProcessorJob* processorJob =
+        static_cast<const CMediaImportTaskProcessorJob*>(job);
+    if (processorJob->GetCurrentTask() != nullptr &&
+        processorJob->GetCurrentTask()->GetProgressBarHandle() != nullptr)
+      processorJob->GetCurrentTask()->GetProgressBarHandle()->SetProgress(progress, total);
+  }
+}
+
+void CMediaImportManager::OnTimeout()
+{
+  UpdateManuallyAddedSources();
+
+  m_manuallyAddedSourceTimer.RestartAsync(MANUALLY_ADDED_SOURCE_INTERVAL_MS);
+}
+
+bool CMediaImportManager::OnTaskComplete(bool success, const IMediaImportTask* task)
+{
+  if (task == nullptr)
+    return false;
+
+  MediaImportTaskType taskType = task->GetType();
+  if (taskType == MediaImportTaskType::ImportItemsRetrieval)
+  {
+    if (!success)
+      return false;
+
+    const auto* itemsRetrievalTask =
+        dynamic_cast<const CMediaImportImportItemsRetrievalTask*>(task);
+    if (itemsRetrievalTask == nullptr)
+      return false;
+
+    const auto& import = itemsRetrievalTask->GetImport();
+    UpdateImport(import);
+    UpdateSource(import.GetSource());
+  }
+  else if (taskType == MediaImportTaskType::Synchronisation)
+  {
+    if (!success)
+      return false;
+
+    const auto* synchronisationTask = dynamic_cast<const CMediaImportSynchronisationTask*>(task);
+    if (synchronisationTask == nullptr)
+      return false;
+
+    auto import = synchronisationTask->GetImport();
+    // early return here if this is not the last media type to be synchronised to avoid multiple updates
+    if (synchronisationTask->GetMediaType() != import.GetMediaTypes().back())
+      return true;
+
+    bool updated = false;
+    {
+      CSingleLock repositoriesLock(m_importRepositoriesLock);
+      updated = std::any_of(m_importRepositories.begin(), m_importRepositories.end(),
+                            [&import](MediaImportRepositoryPtr repository) {
+                              return repository->UpdateLastSync(import);
+                            });
+    }
+
+    if (updated)
+    {
+      OnSourceUpdated(import.GetSource());
+      OnImportUpdated(import);
+    }
+  }
+  else if (taskType == MediaImportTaskType::Removal)
+  {
+    if (!success)
+      return false;
+
+    const auto* removalTask = dynamic_cast<const CMediaImportRemovalTask*>(task);
+    if (removalTask == nullptr)
+      return false;
+
+    const auto& import = removalTask->GetImport();
+
+    // remove the import from the import repositories
+    {
+      CSingleLock repositoriesLock(m_importRepositoriesLock);
+      for (auto& repository : m_importRepositories)
+        repository->RemoveImport(import);
+    }
+
+    // let everyone know that the import has been removed
+    OnImportRemoved(import);
+  }
+  else if (taskType == MediaImportTaskType::Update)
+  {
+    if (!success)
+      return false;
+
+    const auto* updateTask = dynamic_cast<const CMediaImportUpdateTask*>(task);
+    if (updateTask == nullptr)
+      return false;
+
+    const auto& import = updateTask->GetImport();
+    UpdateImport(import);
+    UpdateSource(import.GetSource());
+  }
+
+  return true;
+}
+
+void CMediaImportManager::OnSourceAdded(const CMediaImportSource& source)
+{
+  SendSourceMessage(source, GUI_MSG_SOURCE_ADDED);
+
+  CSingleLock lock(m_importersLock);
+  auto importer = GetImporterBySourceInternal(source.GetIdentifier());
+  if (importer != m_importers.end())
+    importer->second.observer->OnSourceAdded(source);
+}
+
+void CMediaImportManager::OnSourceUpdated(const CMediaImportSource& source)
+{
+  SendSourceMessage(source, GUI_MSG_SOURCE_UPDATED);
+
+  CSingleLock lock(m_importersLock);
+  auto importer = GetImporterBySourceInternal(source.GetIdentifier());
+  if (importer != m_importers.end())
+    importer->second.observer->OnSourceUpdated(source);
+}
+
+void CMediaImportManager::OnSourceRemoved(const CMediaImportSource& source)
+{
+  SendSourceMessage(source, GUI_MSG_SOURCE_REMOVED);
+
+  CSingleLock lock(m_importersLock);
+  auto importer = GetImporterBySourceInternal(source.GetIdentifier());
+  if (importer != m_importers.end())
+    importer->second.observer->OnSourceRemoved(source);
+}
+
+void CMediaImportManager::OnSourceActivated(const CMediaImportSource& source)
+{
+  SendSourceMessage(source, GUI_MSG_SOURCE_ACTIVE_CHANGED, 1);
+
+  CSingleLock lock(m_importersLock);
+  auto importer = GetImporterBySourceInternal(source.GetIdentifier());
+  if (importer != m_importers.end())
+    importer->second.observer->OnSourceActivated(source);
+}
+
+void CMediaImportManager::OnSourceDeactivated(const CMediaImportSource& source)
+{
+  SendSourceMessage(source, GUI_MSG_SOURCE_ACTIVE_CHANGED, 0);
+
+  CSingleLock lock(m_importersLock);
+  auto importer = GetImporterBySourceInternal(source.GetIdentifier());
+  if (importer != m_importers.end())
+    importer->second.observer->OnSourceDeactivated(source);
+}
+
+void CMediaImportManager::OnImportAdded(const CMediaImport& import)
+{
+  SendImportMessage(import, GUI_MSG_IMPORT_ADDED);
+
+  CSingleLock lock(m_importersLock);
+  auto importer = GetImporterBySourceInternal(import.GetSource().GetIdentifier());
+  if (importer != m_importers.end())
+    importer->second.observer->OnImportAdded(import);
+}
+
+void CMediaImportManager::OnImportUpdated(const CMediaImport& import)
+{
+  SendImportMessage(import, GUI_MSG_IMPORT_UPDATED);
+
+  CSingleLock lock(m_importersLock);
+  auto importer = GetImporterBySourceInternal(import.GetSource().GetIdentifier());
+  if (importer != m_importers.end())
+    importer->second.observer->OnImportUpdated(import);
+}
+
+void CMediaImportManager::OnImportRemoved(const CMediaImport& import)
+{
+  SendImportMessage(import, GUI_MSG_IMPORT_REMOVED);
+
+  CSingleLock lock(m_importersLock);
+  auto importer = GetImporterBySourceInternal(import.GetSource().GetIdentifier());
+  if (importer != m_importers.end())
+    importer->second.observer->OnImportRemoved(import);
+}
+
+void CMediaImportManager::SendSourceMessage(const CMediaImportSource& source,
+                                            int message,
+                                            int param /* = 0 */)
+{
+  CFileItemPtr sourceItem(new CFileItem(source.GetFriendlyName()));
+  sourceItem->SetProperty("Source.ID", source.GetIdentifier());
+
+  CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, message, param, sourceItem);
+  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msg);
+}
+
+void CMediaImportManager::SendImportMessage(const CMediaImport& import, int message)
+{
+  CFileItemPtr importItem(new CFileItem());
+  importItem->SetProperty("Source.ID", import.GetSource().GetIdentifier());
+  importItem->SetProperty("Import.Path", import.GetPath());
+  importItem->SetProperty("Import.MediaTypes", CMediaTypes::Join(import.GetMediaTypes()));
+
+  CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, message, 0, importItem);
+  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msg);
+}
diff --git a/xbmc/media/import/MediaImportManager.h b/xbmc/media/import/MediaImportManager.h
new file mode 100644
index 000000000000..1b74488c5323
--- /dev/null
+++ b/xbmc/media/import/MediaImportManager.h
@@ -0,0 +1,686 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/MediaType.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/IMediaImportHandlerManager.h"
+#include "media/import/IMediaImportRepository.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/IMediaImporterManager.h"
+#include "media/import/MediaImportSource.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+#include "threads/CriticalSection.h"
+#include "threads/Timer.h"
+#include "utils/JobManager.h"
+#include "utils/logtypes.h"
+
+#include <map>
+#include <set>
+#include <vector>
+
+class CFileItem;
+class CGUIDialogProgress;
+class CMediaImportSourceJobBase;
+class CMediaImportTaskProcessorJob;
+
+class CMediaImportManager : public virtual IJobCallback,
+                            public ITimerCallback,
+                            public IMediaImportTaskCallback,
+                            public IMediaImporterManager,
+                            public IMediaImportHandlerManager,
+                            protected CJobQueue
+{
+public:
+  CMediaImportManager();
+  CMediaImportManager(const CMediaImportManager&) = delete;
+  CMediaImportManager const& operator=(CMediaImportManager const&) = delete;
+  ~CMediaImportManager();
+
+  /*!
+  * \brief Initializes the media manager by registering all importers and import handlers.
+  */
+  void Initialize();
+
+  /*!
+   * \brief Uninitializes the media manager by releasing all importers, import handlers and repositories.
+   */
+  void Uninitialize();
+
+  /*!
+   * \brief Register a media import repository implementation
+   *
+   * \param importRepository media import repository implementation to register
+   */
+  void RegisterImportRepository(MediaImportRepositoryPtr importRepository);
+  /*!
+   * \brief Unregister a media import repository implementation
+   *
+   * \param importRepository media import repository implementation to unregister
+   * \return True if the media import repository implementation was unregistered, false otherwise
+   */
+  bool UnregisterImportRepository(const MediaImportRepositoryPtr importRepository);
+
+  /*!
+   * \brief Register a media importer implementation
+   *
+   * \param importer media importer implementation to register
+   */
+  void RegisterImporter(MediaImporterFactoryPtr importer);
+  /*!
+   * \brief Unregister a media importer implementation
+   *
+   * \param importerIdentifier identifier of the media importer to unregister
+   * \return True if the importer was unregistered, false otherwise
+   */
+  bool UnregisterImporter(const std::string& importerIdentifier);
+
+  /*!
+   * \brief Returns a list of registered media importer implementations.
+   */
+  std::vector<MediaImporterFactoryConstPtr> GetImporters() const;
+
+  /*!
+   * \brief Tries to discover / find a new media source using the given importer.
+   *
+   * \param importerIdentification Identification of the importer to use for finding the new source.
+   * \param source The found source.
+   * \return True if a source was found, false otherwise.
+   */
+  bool DiscoverSource(const std::string& importerIdentification, CMediaImportSource& source);
+
+  // implementations of IMediaImporterManager
+  bool HasImporter(const std::string& id) const override;
+  MediaImporterPtr GetImporterById(const std::string& id) const override;
+  MediaImporterPtr GetImporterBySource(const CMediaImportSource& source) const override;
+
+  /*!
+   * \brief Register a media import handler implementation
+   *
+   * \param importHandler media import handler implementation to register
+   */
+  void RegisterMediaImportHandler(MediaImportHandlerPtr importHandler);
+  /*!
+   * \brief Unregister a media import handler implementation
+   *
+   * \param importHandler media import handler implementation to unregister
+   */
+  void UnregisterMediaImportHandler(MediaImportHandlerPtr importHandler);
+
+  // implementation of IMediaImportHandlerManager
+  MediaImportHandlerConstPtr GetImportHandler(const MediaType& mediaType) const override;
+
+  /*!
+   * \brief Returns a list of registered media import handler implementations.
+   */
+  std::vector<MediaImportHandlerConstPtr> GetImportHandlers() const;
+
+  /*!
+   * \brief Returns a list of registered media import handler implementations
+   * capable of handling imported media items of one of the given media types.
+   *
+   * \param mediaTypes Media types of imported items
+   * \pram List of media import handler implementations
+   */
+  std::vector<MediaImportHandlerConstPtr> GetImportHandlers(const MediaTypes& mediaTypes) const;
+
+  /*!
+   * \brief Checks if the given media type is supported.
+   */
+  bool IsMediaTypeSupported(const MediaType& mediaType) const;
+
+  /*!
+   * \brief Returns a list of all supported media types.
+   */
+  MediaTypes GetSupportedMediaTypes() const;
+
+  /*!
+   * \brief Returns a list of all supported media types in the order they need to be synchronised.
+   *
+   * \param reversed Whether the list should be reversed or not
+   */
+  GroupedMediaTypes GetSupportedMediaTypesOrdered(bool reversed = false) const;
+
+  /*!
+   * \brief Returns a list of the given media types in the order they need to be synchronised.
+   *
+   * \param mediaTypes List of media types to be ordered
+   * \param reversed Whether the list should be reversed or not
+   */
+  GroupedMediaTypes GetSupportedMediaTypesOrdered(const MediaTypes& mediaTypes,
+                                                  bool reversed = false) const;
+
+  /*!
+   * \brief Returns a list of the given media types with depending media types grouped together.
+   *
+   * \param mediaTypes List of media types to be grouped
+   */
+  std::vector<GroupedMediaTypes> GetSupportedMediaTypesGrouped(const MediaTypes& mediaTypes) const;
+
+  /*!
+   * \brief Returns a set of all media types grouped together with the given media type.
+   */
+  GroupedMediaTypes GetGroupedMediaTypes(const MediaType& mediaType) const;
+
+  /*!
+   * \brief Adds a discovered source asynchronously
+   *
+   * \param importerId Unique identifier of the importer used to add the source
+   * \param sourceID Unique identifier of the source
+   * \param basePath Base path (VFS path) of the source
+   * \param friendlyName Friendly name of the source
+   * \param iconUrl URL to the icon of the source
+   * \param mediaTypes Media types supported by the source
+   */
+  bool AddSource(const std::string& importerId,
+                 const std::string& sourceID,
+                 const std::string& basePath,
+                 const std::string& friendlyName,
+                 const std::string& iconUrl = "",
+                 const MediaTypes& mediaTypes = MediaTypes());
+  bool AddSource(const CMediaImportSource& source);
+
+  /*!
+   * \brief Adds and activates a discovered source asynchronously
+   *
+   * \param importerId Unique identifier of the importer used to add the source
+   * \param sourceID Unique identifier of the source
+   * \param basePath Base path (VFS path) of the source
+   * \param friendlyName Friendly name of the source
+   * \param iconUrl URL to the icon of the source
+   * \param mediaTypes Media types supported by the source
+   */
+  bool AddAndActivateSource(const std::string& importerId,
+                            const std::string& sourceID,
+                            const std::string& basePath,
+                            const std::string& friendlyName,
+                            const std::string& iconUrl = "",
+                            const MediaTypes& mediaTypes = MediaTypes());
+  bool AddAndActivateSource(const CMediaImportSource& source);
+
+  /*!
+   * \brief Adds a manuallyAdded looked up source asynchronously
+   *
+   * \param importerId Unique identifier of the importer used to add the source
+   * \param sourceID Unique identifier of the source
+   * \param basePath Base path (VFS path) of the source
+   * \param friendlyName Friendly name of the source
+   * \param iconUrl URL to the icon of the source
+   * \param mediaTypes Media types supported by the source
+   */
+  bool AddSourceManually(const std::string& importerId,
+                         const std::string& sourceID,
+                         const std::string& basePath,
+                         const std::string& friendlyName,
+                         const std::string& iconUrl = "",
+                         const MediaTypes& mediaTypes = MediaTypes());
+  bool AddSourceManually(const CMediaImportSource& source);
+
+  /*!
+   * \brief Adds and activates a manuallyAdded looked up source asynchronously
+   *
+   * \param importerId Unique identifier of the importer used to add the source
+   * \param sourceID Unique identifier of the source
+   * \param basePath Base path (VFS path) of the source
+   * \param friendlyName Friendly name of the source
+   * \param iconUrl URL to the icon of the source
+   * \param mediaTypes Media types supported by the source
+   */
+  bool AddAndActivateSourceManually(const std::string& importerId,
+                                    const std::string& sourceID,
+                                    const std::string& basePath,
+                                    const std::string& friendlyName,
+                                    const std::string& iconUrl = "",
+                                    const MediaTypes& mediaTypes = MediaTypes());
+  bool AddAndActivateSourceManually(const CMediaImportSource& source);
+
+  /*!
+   * \brief Activates a discovered source
+   * If the source is already known all imports from that source are being
+   * triggered.
+   *
+   * \param sourceID Unique identifier (VFS path) of the source
+   * \param basePath Base path (VFS path) of the source
+   * \param friendlyName Friendly name of the source
+   * \param iconUrl URL to the icon of the source
+   * \return True if the source was successfully activated, false otherwise
+   */
+  bool ActivateSource(const std::string& importerId,
+                      const std::string& sourceID,
+                      const std::string& basePath = "",
+                      const std::string& friendlyName = "",
+                      const std::string& iconUrl = "");
+  bool ActivateSource(const CMediaImportSource& source);
+
+  /*!
+   * \brief Deactivates the source with the given identifier
+   * All items imported from the source are being marked as disabled.
+   *
+   * \param sourceID Unique identifier of the source
+   */
+  void DeactivateSource(const std::string& sourceID);
+
+  /*!
+  * \brief Updates the details and settings of the given source.
+  *
+  * \param source Updated source
+  * \return True if the source was successfully updated, false otherwise
+  */
+  bool UpdateSource(const CMediaImportSource& source);
+
+  /*!
+   * \brief Completely removes the source with the given identifier
+   * Removes the source, all its imports and all items imported from the
+   * source from the libraries.
+   *
+   * \param sourceID Unique identifier of the source
+   */
+  void RemoveSource(const std::string& sourceID);
+
+  /*!
+   * \brief Whether any sources have been registered.
+   *
+   * \return True if at least one source has been registered, false otherwise.
+   */
+  bool HasSources() const;
+
+  /*!
+   * \brief Whether any active/inactive sources have been registered.
+   *
+   * \return True if at least one active/inactive source has been registered, false otherwise.
+   */
+  bool HasSources(bool active) const;
+
+  /*!
+   * \brief Gets all registered sources
+   *
+   * \return Set of all registered sources
+   */
+  std::vector<CMediaImportSource> GetSources() const;
+
+  /*!
+   * \brief Gets all active or inactive registered sources
+   *
+   * \param active Whether to get active or inactive sources
+   * \return Set of all active or inactive registered sources
+   */
+  std::vector<CMediaImportSource> GetSources(bool active) const;
+
+  /*!
+   * \brief Gets the source with the given identifier.
+   *
+   * \param sourceID Unique identifier of the source
+   * \param source Source with the given identifier
+   * \return True if the source with the given identifier was found, false otherwise
+   */
+  bool GetSource(const std::string& sourceID, CMediaImportSource& source) const;
+
+  /*!
+   * \brief Checks whether the given source is active or not.
+   *
+   * \param sourceID Unique identifier of the source
+   * \return True if the given source is active, otherwise false
+   */
+  bool IsSourceActive(const std::string& sourceID) const;
+
+  /*!
+   * \brief Checks whether the given source is active or not.
+   *
+   * \param source Source object
+   * \return True if the given source is active, otherwise false
+   */
+  bool IsSourceActive(const CMediaImportSource& source) const;
+
+  /*
+  * \brief Checks whether the given source is ready for importing.
+  *
+  * \param sourceID Unique identifier of the source to be checked for readiness
+  * \return True if the given source is ready for importing, false otherwise
+  */
+  bool IsSourceReady(const std::string& sourceID) const;
+
+  /*
+  * \brief Checks whether the given source is ready for importing.
+  *
+  * \param source Source to be checked for readiness
+  * \return True if the given source is ready for importing, false otherwise
+  */
+  bool IsSourceReady(const CMediaImportSource& source) const;
+
+  /*!
+   * \brief Whether any imports have been defined.
+   *
+   * \return True if at least one import has been defined, false otherwise.
+   */
+  bool HasImports() const;
+
+  /*!
+   * \brief Whether the source with the given identifier has imports defined.
+   *
+   * \param sourceID Identifier of a source
+   * \return True if the source with the given identifier has imports defined, false otherwise.
+   */
+  bool HasImports(const std::string& sourceID) const;
+
+  /*!
+   * \brief Whether the given source has imports defined.
+   *
+   * \param source Source
+   * \return True if the given source has imports defined, false otherwise.
+   */
+  bool HasImports(const CMediaImportSource& source) const;
+
+  /*!
+   * \brief Adds a new selective import to the given source for the given path and media type.
+   *
+   * Selective importing means that the given import path must point to a single
+   * item to be imported.
+   *
+   * \param sourceID Source identifier
+   * \param path Path from where to import media items
+   * \param mediaTypes Types of the media items to import
+   * \return True if the import was successfully added, false otherwise
+   */
+  bool AddSelectiveImport(const std::string& sourceID,
+                          const std::string& path,
+                          const GroupedMediaTypes& mediaTypes);
+
+  /*!
+   * \brief Adds a new recursive import to the given source for the given path and media type.
+   *
+   * Recursive importing means that the given import path must be a path to a
+   * directory which can be listed.
+   *
+   * \param sourceID Source identifier
+   * \param path Path from where to import media items
+   * \param mediaTypes Types of the media items to import
+   * \return True if the import was successfully added, false otherwise
+   */
+  bool AddRecursiveImport(const std::string& sourceID,
+                          const std::string& path,
+                          const GroupedMediaTypes& mediaTypes);
+
+  /*!
+   * \brief Adds new recursive imports to the given source for the given path and media types.
+   *
+   * \param sourceID Source identifier
+   * \param path Path from where to import media items
+   * \param mediaTypes Set of types of the media items to import
+   * \return True if the imports were successfully added, false otherwise
+   */
+  bool AddRecursiveImports(const std::string& sourceID,
+                           const std::string& path,
+                           const std::set<GroupedMediaTypes>& mediaTypes);
+
+  /*!
+   * \brief Updates the details and settings of the given import.
+   *
+   * \param import Updated import
+   * \return True if the import was successfully updated, false otherwise
+   */
+  bool UpdateImport(const CMediaImport& import);
+
+  /*!
+   * \brief Completely removes the import with the given path and media type.
+   * 
+   * \details Removes the import and all items imported from the import from the libraries.
+   *
+   * \param path Path of the import
+   * \param mediaTypes Media types of the import
+   */
+  void RemoveImport(const std::string& path, const GroupedMediaTypes& mediaTypes);
+
+  /*!
+   * \brief Returns a list of all registered media imports.
+   */
+  std::vector<CMediaImport> GetImports() const;
+
+  /*!
+   * \brief Returns a list of all registered media imports for the given media type.
+   *
+   * \param mediaTypes Media types of the imports
+   */
+  std::vector<CMediaImport> GetImportsByMediaType(const GroupedMediaTypes& mediaTypes) const;
+
+  /*!
+   * \brief Returns a list of media imports belonging to the source with the given identifier.
+   *
+   * \param sourceID Source identifier
+   */
+  std::vector<CMediaImport> GetImportsBySource(const std::string& sourceID) const;
+
+  /*!
+   * \brief Returns a list of media imports belonging to the given path.
+   *
+   * \param path Path of the imports
+   * \param includeSubDirectories Whether to include subdirectories or not
+   */
+  std::vector<CMediaImport> GetImportsByPath(const std::string& path,
+                                             bool includeSubDirectories = false) const;
+
+  /*!
+   * \brief Gets the import for the given path and media type.
+   *
+   * \param path Path of the import
+   * \param mediaTypes Media types of the import
+   * \return True if the import for the given path and media type was found, false otherwise
+   */
+  bool GetImport(const std::string& path,
+                 const GroupedMediaTypes& mediaTypes,
+                 CMediaImport& import) const;
+
+  /*
+  * \brief Checks if the given import is ready to be processed.
+  *
+  * \param path Path of the import to be checked for readiness
+   * \param mediaTypes Media types of the import to be checked for readiness
+  * \return True if the given import is ready to be processed, false otherwise
+  */
+  bool IsImportReady(const std::string& path, const GroupedMediaTypes& mediaTypes) const;
+
+  /*
+  * \brief Checks if the given import is ready to be processed.
+  *
+  * \param import Import to be checked for readiness
+  * \return True if the given import is ready to be processed, false otherwise
+  */
+  bool IsImportReady(const CMediaImport& import) const;
+
+  /*!
+  * \brief Checks if the given path is imported (ignoring parent paths).
+  *
+  * \return True if the given path is imported, false otherwise
+  */
+  bool IsImported(const std::string& path) const;
+
+  /*!
+   * \brief Checks if the given path or any of its parent paths is imported.
+   *
+   * \return True if the given path is imported, false otherwise
+   */
+  bool IsImportedInHierarchy(const std::string& path) const;
+
+  /*!
+   * \brief Import media items from all registered sources and imports.
+   *
+   * \return True if the import of media items has been started, false otherwise
+   */
+  bool Import();
+
+  /*!
+   * \brief Import media items from the given source.
+   *
+   * \param sourceID Unique identifier of the source
+   * \return True if the import of media items has been started, false otherwise
+   */
+  bool Import(const std::string& sourceID);
+
+  /*!
+   * \brief Import media items of the given media type from the given path.
+   *
+   * \param path Path from where media items will be imported
+   * \param mediaTypes media types to import
+   * \return True if the import of media items has been started, false otherwise
+   */
+  bool Import(const std::string& path, const GroupedMediaTypes& mediaTypes);
+
+  /*!
+   * \brief Adds the given items as imported items from the given media import.
+   *
+   * \param import Media import the given item has been imported from
+   * \param items Newly imported items
+   * \return True if the import of the items has been started, false otherwise
+   */
+  bool AddImportedItems(const CMediaImport& import, const CFileItemList& item);
+
+  /*!
+  * \brief Updates the given items imported from the given media import.
+   *
+   * \param import Media import the given item has been imported from
+   * \param items Updated imported items
+   * \return True if the update of the imported items has been started, false otherwise
+  */
+  bool UpdateImportedItems(const CMediaImport& import, const CFileItemList& items);
+
+  /*!
+  * \brief Removes the given items previously imported from the given media import.
+   *
+   * \param import Media import the given item has been imported from
+   * \param items Removed imported items
+   * \return True if the removal of the imported items has been started, false otherwise
+  */
+  bool RemoveImportedItems(const CMediaImport& import, const CFileItemList& items);
+
+  /*!
+  * \brief changes the given items imported from the given media import.
+  *
+  * \param import Media import the given item has been imported from
+  * \param items Changed imported items
+  * \return True if the change of the imported items has been started, false otherwise
+  */
+  bool ChangeImportedItems(const CMediaImport& import, const ChangesetItems& items);
+
+  /*!
+   * \brief Updates the details of the imported media item on the source from where it was imported.
+   *
+   * \param item Imported media item to update on the source
+   * \return True if the imported media item was successfully updated on the source, false otherwise
+   */
+  bool UpdateImportedItemOnSource(const CFileItem& item);
+
+  /*!
+   * \brief TODO
+   */
+  std::vector<CFileItemPtr> GetImportedItemsBySource(const CMediaImportSource& source) const;
+
+  /*!
+   * \brief TODO
+   */
+  std::vector<CFileItemPtr> GetImportedItemsByImport(const CMediaImport& import) const;
+
+  // implementation of IJobCallback
+  void OnJobComplete(unsigned int jobID, bool success, CJob* job) override;
+  void OnJobProgress(unsigned int jobID,
+                     unsigned int progress,
+                     unsigned int total,
+                     const CJob* job) override;
+
+  // implementation of ITimerCallback
+  void OnTimeout() override;
+
+  // implementation of IMediaImportTaskCallback
+  bool OnTaskComplete(bool success, const IMediaImportTask* task) override;
+
+private:
+  typedef struct MediaImporter
+  {
+    MediaImporterFactoryPtr factory;
+    MediaImporterDiscovererPtr discoverer;
+    MediaImporterObserverPtr observer;
+  } MediaImporter;
+  using MediaImporterMap = std::map<std::string, MediaImporter>;
+
+  MediaImporterMap::iterator GetImporterBySourceInternal(const std::string& sourceId);
+
+  void PrepareImports(std::vector<CMediaImport>& imports) const;
+
+  bool AddSourceAsync(CMediaImportSource source, bool activate, bool manuallyAdded);
+  bool AddSourceSync(const CMediaImportSource& source);
+  bool ActivateSourceAsync(const CMediaImportSource& source);
+  bool ActivateSourceSync(const CMediaImportSource& source, bool ready);
+  bool GetSourceInternal(const std::string& sourceID, CMediaImportSource& source) const;
+  bool FindSource(const std::string& sourceID, CMediaImportSource& source) const;
+  void UpdateManuallyAddedSources();
+  bool LookupSource(const CMediaImportSource& source);
+
+  bool AddImport(const std::string& sourceID,
+                 const std::string& path,
+                 const GroupedMediaTypes& mediaTypes,
+                 bool recursive);
+  bool AddImport(const CMediaImport& import);
+  bool FindImport(const std::string& path,
+                  const GroupedMediaTypes& mediaTypes,
+                  CMediaImport& import) const;
+
+  void AddJob(const std::string& sourceID, CMediaImportSourceJobBase* job);
+  void AddJob(const std::string& sourceID, CMediaImportTaskProcessorJob* job);
+  void RemoveJob(const std::string& sourceID, const CMediaImportSourceJobBase* job);
+  void RemoveJob(const std::string& sourceID, const CMediaImportTaskProcessorJob* job);
+  void CancelJobs(const std::string& sourceID);
+  void CancelAllJobs();
+
+  void OnSourceJobComplete(const CMediaImportSourceJobBase* sourceJob, bool success);
+
+  void Import(const CMediaImportSource& source, bool automatically = false);
+  void Import(const CMediaImport& import, bool automatically = false);
+
+  void OnSourceAdded(const CMediaImportSource& source);
+  void OnSourceUpdated(const CMediaImportSource& source);
+  void OnSourceRemoved(const CMediaImportSource& source);
+  void OnSourceActivated(const CMediaImportSource& source);
+  void OnSourceDeactivated(const CMediaImportSource& source);
+  void OnImportAdded(const CMediaImport& import);
+  void OnImportUpdated(const CMediaImport& import);
+  void OnImportRemoved(const CMediaImport& import);
+  void SendSourceMessage(const CMediaImportSource& source, int message, int param = 0);
+  void SendImportMessage(const CMediaImport& import, int message);
+
+  Logger m_logger;
+
+  bool m_initialized;
+
+  static const uint32_t MANUALLY_ADDED_SOURCE_INTERVAL_MS = 60 * 1000;
+  CTimer m_manuallyAddedSourceTimer;
+
+  mutable CCriticalSection m_importRepositoriesLock;
+  std::set<MediaImportRepositoryPtr> m_importRepositories;
+
+  typedef struct MediaImportSource
+  {
+    std::string importerId;
+    bool active;
+    bool ready;
+    bool removing;
+  } MediaImportSource;
+
+  mutable CCriticalSection m_sourcesLock;
+  std::map<std::string, MediaImportSource> m_sources;
+
+  mutable CCriticalSection m_importersLock;
+  std::map<std::string, MediaImporter> m_importers;
+
+  mutable CCriticalSection m_importHandlersLock;
+  std::map<MediaType, MediaImportHandlerConstPtr> m_importHandlersMap;
+  std::vector<MediaImportHandlerConstPtr> m_importHandlers;
+
+  mutable CCriticalSection m_sourceJobsLock;
+  std::map<std::string, std::set<CMediaImportSourceJobBase*>> m_sourceJobMap;
+  mutable CCriticalSection m_importJobsLock;
+  std::map<std::string, std::set<CMediaImportTaskProcessorJob*>> m_importJobMap;
+};
diff --git a/xbmc/media/import/jobs/CMakeLists.txt b/xbmc/media/import/jobs/CMakeLists.txt
new file mode 100644
index 000000000000..2cf22a092f93
--- /dev/null
+++ b/xbmc/media/import/jobs/CMakeLists.txt
@@ -0,0 +1,13 @@
+set(SOURCES MediaImportSourceJobBase.cpp
+            MediaImportSourceReadyJob.cpp
+            MediaImportSourceRegistrationJob.cpp
+            MediaImportTaskProcessorJob.cpp)
+
+set(HEADERS MediaImportSourceActivationJob.h
+            MediaImportSourceJobBase.h
+            MediaImportSourceReadyJob.h
+            MediaImportSourceRegistrationJob.h
+            MediaImportTaskProcessorJob.h
+            MediaImportTaskTypes.h)
+
+core_add_library(media_import_jobs)
diff --git a/xbmc/media/import/jobs/MediaImportSourceActivationJob.h b/xbmc/media/import/jobs/MediaImportSourceActivationJob.h
new file mode 100644
index 000000000000..b2019f2ddaff
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportSourceActivationJob.h
@@ -0,0 +1,25 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/jobs/MediaImportSourceReadyJob.h"
+
+class CMediaImportSourceActivationJob : public CMediaImportSourceReadyJob
+{
+public:
+  CMediaImportSourceActivationJob(const CMediaImportSource& source,
+                                  const IMediaImporterManager* importerManager)
+    : CMediaImportSourceReadyJob(source, importerManager, "CMediaImportSourceActivationJob")
+  {
+  }
+  virtual ~CMediaImportSourceActivationJob() = default;
+
+  // implementation of CJob
+  const char* GetType() const override { return "MediaImportSourceActivationJob"; }
+};
diff --git a/xbmc/media/import/jobs/MediaImportSourceJobBase.cpp b/xbmc/media/import/jobs/MediaImportSourceJobBase.cpp
new file mode 100644
index 000000000000..b032d516ffce
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportSourceJobBase.cpp
@@ -0,0 +1,36 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportSourceJobBase.h"
+
+#include "ServiceBroker.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+CMediaImportSourceJobBase::CMediaImportSourceJobBase(const std::string& name,
+                                                     const CMediaImportSource& source,
+                                                     const IMediaImporterManager* importerManager)
+  : m_logger(CServiceBroker::GetLogging().GetLogger(
+        StringUtils::Format("{}[{}]", name, source.GetIdentifier()))),
+    m_source(source),
+    m_importerManager(importerManager)
+{
+}
+
+bool CMediaImportSourceJobBase::operator==(const CJob* other) const
+{
+  if (strcmp(other->GetType(), GetType()) != 0)
+    return false;
+
+  const CMediaImportSourceJobBase* otherSourceJob =
+      dynamic_cast<const CMediaImportSourceJobBase*>(other);
+  if (otherSourceJob == nullptr)
+    return false;
+
+  return m_source == otherSourceJob->m_source;
+}
diff --git a/xbmc/media/import/jobs/MediaImportSourceJobBase.h b/xbmc/media/import/jobs/MediaImportSourceJobBase.h
new file mode 100644
index 000000000000..a1a0cc4b9178
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportSourceJobBase.h
@@ -0,0 +1,35 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/IMediaImporterManager.h"
+#include "media/import/MediaImportSource.h"
+#include "utils/Job.h"
+#include "utils/logtypes.h"
+
+class CMediaImportSourceJobBase : public CJob
+{
+public:
+  virtual ~CMediaImportSourceJobBase() = default;
+
+  // implementation of CJob
+  bool operator==(const CJob* other) const override;
+
+  const CMediaImportSource& GetSource() const { return m_source; }
+
+protected:
+  CMediaImportSourceJobBase(const std::string& name,
+                            const CMediaImportSource& source,
+                            const IMediaImporterManager* importerManager);
+
+  Logger m_logger;
+
+  CMediaImportSource m_source;
+  const IMediaImporterManager* m_importerManager;
+};
diff --git a/xbmc/media/import/jobs/MediaImportSourceReadyJob.cpp b/xbmc/media/import/jobs/MediaImportSourceReadyJob.cpp
new file mode 100644
index 000000000000..c183d6f58a12
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportSourceReadyJob.cpp
@@ -0,0 +1,55 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportSourceReadyJob.h"
+
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportSourceReadyJob::CMediaImportSourceReadyJob(
+    const CMediaImportSource& source,
+    const IMediaImporterManager* importerManager,
+    const std::string& name /* = "CMediaImportSourceReadyJob" */)
+  : CMediaImportSourceJobBase(name, source, importerManager), m_ready(false)
+{
+}
+
+bool CMediaImportSourceReadyJob::DoWork()
+{
+  const auto& importer = GetImporter();
+  if (importer == nullptr)
+    return false;
+
+  // check if the source is ready
+  m_ready = importer->IsSourceReady(m_source);
+  m_source.SetReady(m_ready);
+
+  return true;
+}
+
+std::shared_ptr<IMediaImporter> CMediaImportSourceReadyJob::GetImporter()
+{
+  if (m_importer != nullptr)
+    return m_importer;
+
+  if (m_importerManager == nullptr)
+  {
+    m_logger->error("invalid media importer manager implementation for source {}", m_source);
+    return nullptr;
+  }
+
+  m_importer = m_importerManager->GetImporterBySource(m_source);
+  if (m_importer == nullptr)
+  {
+    m_logger->error("missing media importer for source {}", m_source);
+    return nullptr;
+  }
+
+  return m_importer;
+}
diff --git a/xbmc/media/import/jobs/MediaImportSourceReadyJob.h b/xbmc/media/import/jobs/MediaImportSourceReadyJob.h
new file mode 100644
index 000000000000..9abf9eed0215
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportSourceReadyJob.h
@@ -0,0 +1,39 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/IMediaImporter.h"
+#include "media/import/jobs/MediaImportSourceJobBase.h"
+#include "utils/logtypes.h"
+
+#include <memory>
+
+class CMediaImportSourceReadyJob : public CMediaImportSourceJobBase
+{
+public:
+  CMediaImportSourceReadyJob(const CMediaImportSource& source,
+                             const IMediaImporterManager* importerManager,
+                             const std::string& name = "CMediaImportSourceReadyJob");
+  virtual ~CMediaImportSourceReadyJob() = default;
+
+  // implementation of CJob
+  const char* GetType() const override { return "MediaImportSourceReadyJob"; }
+
+  // specialization of CMediaImportSourceJobBase
+  bool DoWork() override;
+
+  bool IsSourceReady() const { return m_ready; }
+
+protected:
+  std::shared_ptr<IMediaImporter> GetImporter();
+
+private:
+  std::shared_ptr<IMediaImporter> m_importer;
+  bool m_ready;
+};
diff --git a/xbmc/media/import/jobs/MediaImportSourceRegistrationJob.cpp b/xbmc/media/import/jobs/MediaImportSourceRegistrationJob.cpp
new file mode 100644
index 000000000000..3974f59c79b5
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportSourceRegistrationJob.cpp
@@ -0,0 +1,35 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportSourceRegistrationJob.h"
+
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportSourceRegistrationJob::CMediaImportSourceRegistrationJob(
+    const CMediaImportSource& source, bool activate, const IMediaImporterManager* importerManager)
+  : CMediaImportSourceReadyJob(source, importerManager, "CMediaImportSourceRegistrationJob"),
+    m_activate(activate)
+{
+}
+
+bool CMediaImportSourceRegistrationJob::DoWork()
+{
+  const auto& importer = GetImporter();
+  if (importer == nullptr)
+    return false;
+
+  if (!importer->CanImport(m_source.GetIdentifier()))
+  {
+    m_logger->warn("importer \"{}\" cannot handle source {}", m_source.GetImporterId(), m_source);
+    return false;
+  }
+
+  return CMediaImportSourceReadyJob::DoWork();
+}
diff --git a/xbmc/media/import/jobs/MediaImportSourceRegistrationJob.h b/xbmc/media/import/jobs/MediaImportSourceRegistrationJob.h
new file mode 100644
index 000000000000..b496976c6096
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportSourceRegistrationJob.h
@@ -0,0 +1,31 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/jobs/MediaImportSourceReadyJob.h"
+
+class CMediaImportSourceRegistrationJob : public CMediaImportSourceReadyJob
+{
+public:
+  CMediaImportSourceRegistrationJob(const CMediaImportSource& source,
+                                    bool activate,
+                                    const IMediaImporterManager* importerManager);
+  virtual ~CMediaImportSourceRegistrationJob() = default;
+
+  // implementation of CJob
+  const char* GetType() const override { return "MediaImportSourceRegistrationJob"; }
+
+  // specialization of CMediaImportSourceReadyJob
+  bool DoWork() override;
+
+  bool ActivateSource() const { return m_activate; }
+
+private:
+  const bool m_activate;
+};
diff --git a/xbmc/media/import/jobs/MediaImportTaskProcessorJob.cpp b/xbmc/media/import/jobs/MediaImportTaskProcessorJob.cpp
new file mode 100644
index 000000000000..18a7f5ddcef1
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportTaskProcessorJob.cpp
@@ -0,0 +1,717 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportTaskProcessorJob.h"
+
+#include "ServiceBroker.h"
+#include "dialogs/GUIDialogExtendedProgressBar.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/MediaImportManager.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+#include "media/import/jobs/tasks/MediaImportChangesetTask.h"
+#include "media/import/jobs/tasks/MediaImportCleanupTask.h"
+#include "media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.h"
+#include "media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.h"
+#include "media/import/jobs/tasks/MediaImportRemovalTask.h"
+#include "media/import/jobs/tasks/MediaImportSynchronisationTask.h"
+#include "media/import/jobs/tasks/MediaImportUpdateTask.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "utils/URIUtils.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportTaskProcessorJob::CMediaImportTaskProcessorJob(
+    const std::string& path,
+    const IMediaImporterManager* importerManager,
+    const IMediaImportHandlerManager* importHandlerManager,
+    IMediaImportTaskCallback* callback,
+    bool hasProgress)
+  : CStaticLoggerBase("CMediaImportTaskProcessorJob"),
+    m_importerManager(importerManager),
+    m_importHandlerManager(importHandlerManager),
+    m_callback(callback),
+    m_task(nullptr),
+    m_hasProgress(hasProgress),
+    m_progress(nullptr),
+    m_path(path),
+    m_importTaskData(),
+    m_taskTypesToBeProcessed()
+{
+  if (m_hasProgress && CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+                           CSettings::SETTING_VIDEOLIBRARY_BACKGROUNDUPDATE))
+    m_hasProgress = false;
+}
+
+CMediaImportTaskProcessorJob::~CMediaImportTaskProcessorJob()
+{
+  if (m_progress != nullptr)
+    m_progress->MarkFinished();
+}
+
+CMediaImportTaskProcessorJob* CMediaImportTaskProcessorJob::Import(
+    const CMediaImport& import,
+    bool automatically,
+    const IMediaImporterManager* importerManager,
+    const IMediaImportHandlerManager* importHandlerManager,
+    IMediaImportTaskCallback* callback)
+{
+  if (importerManager == nullptr)
+  {
+    s_logger->error("invalid media importer manager implementation");
+    return nullptr;
+  }
+
+  if (importHandlerManager == nullptr)
+  {
+    s_logger->error("invalid media import handler manager implementation");
+    return nullptr;
+  }
+
+  CMediaImport tmpImport = import;
+  if (automatically && tmpImport.Settings()->Load() &&
+      tmpImport.Settings()->GetImportTrigger() != MediaImportTrigger::Auto)
+  {
+    s_logger->debug("automatic import of items from {} is disabled", import);
+    return nullptr;
+  }
+
+  auto processorJob = new CMediaImportTaskProcessorJob(
+      import.GetSource().GetIdentifier(), importerManager, importHandlerManager, callback, true);
+  if (!processorJob->AddImport(import, {}))
+  {
+    s_logger->warn("failed to import items from {}", import);
+    return nullptr;
+  }
+
+  return processorJob;
+}
+
+CMediaImportTaskProcessorJob* CMediaImportTaskProcessorJob::ChangeImportedItems(
+    const CMediaImport& import,
+    const ChangesetItems& items,
+    const IMediaImportHandlerManager* importHandlerManager,
+    IMediaImportTaskCallback* callback)
+{
+  if (importHandlerManager == nullptr)
+  {
+    s_logger->error("invalid media import handler manager implementation");
+    return nullptr;
+  }
+
+  // add the import to the map of imports to process
+  // and remember to perform a partial changeset
+  MediaImportTaskData importTaskData = {import, true};
+
+  // prepare the media type data
+  std::map<MediaType, MediaImportTaskData::MediaTypeTaskData> mediaTypeDataMap;
+  for (const auto& mediaType : import.GetMediaTypes())
+  {
+    // get the import handler
+    const auto importer = importHandlerManager->GetImportHandler(mediaType);
+    if (importer == nullptr)
+      continue;
+
+    mediaTypeDataMap.insert(
+        std::make_pair(mediaType, MediaImportTaskData::MediaTypeTaskData{mediaType, importer}));
+  }
+
+  for (const auto& changedItem : items)
+  {
+    if (changedItem.second == nullptr)
+      continue;
+
+    // check the media type
+    auto mediaTypeDataIt = mediaTypeDataMap.find(changedItem.second->GetMediaType());
+    if (mediaTypeDataIt == mediaTypeDataMap.end())
+      continue;
+
+    mediaTypeDataIt->second.m_importedItems.push_back(changedItem);
+  }
+
+  for (const auto& mediaTypeData : mediaTypeDataMap)
+  {
+    // ignore media type data without any changed items
+    if (mediaTypeData.second.m_importedItems.empty())
+      continue;
+
+    importTaskData.m_mediaTypeData.push_back(mediaTypeData.second);
+  }
+
+  auto processorJob = new CMediaImportTaskProcessorJob(import.GetSource().GetIdentifier(), nullptr,
+                                                       importHandlerManager, callback, false);
+  processorJob->m_importTaskData.emplace(std::make_pair(import.GetPath(), import.GetMediaTypes()),
+                                         importTaskData);
+
+  // get all local items
+  processorJob->m_taskTypesToBeProcessed.push_back(MediaImportTaskType::LocalItemsRetrieval);
+
+  // determine the partial changeset for the given items
+  processorJob->m_taskTypesToBeProcessed.push_back(MediaImportTaskType::Changeset);
+
+  // do a sychronisation and cleanup
+  processorJob->m_taskTypesToBeProcessed.push_back(MediaImportTaskType::Synchronisation);
+  processorJob->m_taskTypesToBeProcessed.push_back(MediaImportTaskType::Cleanup);
+
+  return processorJob;
+}
+
+CMediaImportTaskProcessorJob* CMediaImportTaskProcessorJob::UpdateImportedItemOnSource(
+    const CMediaImport& import,
+    const CFileItem& item,
+    const IMediaImporterManager* importerManager,
+    IMediaImportTaskCallback* callback)
+{
+  if (importerManager == nullptr)
+  {
+    s_logger->error("invalid media importer manager implementation");
+    return nullptr;
+  }
+
+  auto processorJob = new CMediaImportTaskProcessorJob(import.GetSource().GetIdentifier(),
+                                                       importerManager, nullptr, callback, false);
+
+  auto updateTask = new CMediaImportUpdateTask(import, item, importerManager);
+  processorJob->m_taskTypesToBeProcessed.push_back(MediaImportTaskType::Update);
+  processorJob->SetTask(updateTask);
+
+  return processorJob;
+}
+
+CMediaImportTaskProcessorJob* CMediaImportTaskProcessorJob::Cleanup(
+    const CMediaImportSource& source,
+    const std::vector<CMediaImport>& imports,
+    const IMediaImportHandlerManager* importHandlerManager,
+    IMediaImportTaskCallback* callback)
+{
+  if (importHandlerManager == nullptr)
+  {
+    s_logger->error("invalid media import handler manager implementation");
+    return nullptr;
+  }
+
+  if (imports.empty())
+    return nullptr;
+
+  auto processorJob = new CMediaImportTaskProcessorJob(source.GetIdentifier(), nullptr,
+                                                       importHandlerManager, callback, true);
+
+  bool added = false;
+  std::vector<MediaImportTaskType> tasksToBeProcessed;
+  tasksToBeProcessed.push_back(MediaImportTaskType::Cleanup);
+  for (const auto& import : imports)
+  {
+    if (!processorJob->AddImport(import, tasksToBeProcessed))
+    {
+      s_logger->warn("failed to cleanup imported items from {}", import);
+      continue;
+    }
+
+    added |= true;
+  }
+
+  if (!added)
+  {
+    delete processorJob;
+    return nullptr;
+  }
+
+  return processorJob;
+}
+
+CMediaImportTaskProcessorJob* CMediaImportTaskProcessorJob::Cleanup(
+    const CMediaImport& import,
+    const IMediaImportHandlerManager* importHandlerManager,
+    IMediaImportTaskCallback* callback)
+{
+  return Cleanup(import.GetSource(), {import}, importHandlerManager, callback);
+}
+
+CMediaImportTaskProcessorJob* CMediaImportTaskProcessorJob::Remove(
+    const CMediaImportSource& source,
+    const std::vector<CMediaImport>& imports,
+    const IMediaImportHandlerManager* importHandlerManager,
+    IMediaImportTaskCallback* callback)
+{
+  if (importHandlerManager == nullptr)
+  {
+    s_logger->error("invalid media import handler manager implementation");
+    return nullptr;
+  }
+
+  auto processorJob = new CMediaImportTaskProcessorJob(source.GetIdentifier(), nullptr,
+                                                       importHandlerManager, callback, true);
+
+  std::vector<MediaImportTaskType> tasksToBeProcessed;
+  tasksToBeProcessed.push_back(MediaImportTaskType::Removal);
+  for (const auto& import : imports)
+  {
+    if (!processorJob->AddImport(import, tasksToBeProcessed))
+    {
+      s_logger->warn("failed to remove imported items from {}", import);
+      continue;
+    }
+  }
+
+  return processorJob;
+}
+
+CMediaImportTaskProcessorJob* CMediaImportTaskProcessorJob::Remove(
+    const CMediaImport& import,
+    const IMediaImportHandlerManager* importHandlerManager,
+    IMediaImportTaskCallback* callback)
+{
+  return Remove(import.GetSource(), {import}, importHandlerManager, callback);
+}
+
+void CMediaImportTaskProcessorJob::SetTask(IMediaImportTask* task)
+{
+  m_task = task;
+  if (m_task != nullptr)
+    m_task->SetProcessorJob(this);
+}
+
+void CMediaImportTaskProcessorJob::ResetTask()
+{
+  if (m_task != nullptr)
+    m_task->SetProcessorJob(nullptr);
+
+  m_task = nullptr;
+}
+
+CGUIDialogProgressBarHandle* CMediaImportTaskProcessorJob::GetProgressBarHandle(
+    const std::string& title /* = "" */)
+{
+  if (!m_hasProgress)
+    return nullptr;
+
+  if (m_progress == nullptr)
+  {
+    auto dialog = static_cast<CGUIDialogExtendedProgressBar*>(
+        CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_EXT_PROGRESS));
+    if (dialog != nullptr)
+      m_progress = dialog->GetHandle(title);
+  }
+  else if (!title.empty())
+    m_progress->SetTitle(title);
+
+  return m_progress;
+}
+
+bool CMediaImportTaskProcessorJob::DoWork()
+{
+  return ProcessTask();
+}
+
+bool CMediaImportTaskProcessorJob::operator==(const CJob* job) const
+{
+  if (strcmp(job->GetType(), GetType()) != 0)
+    return false;
+
+  const CMediaImportTaskProcessorJob* rjob = dynamic_cast<const CMediaImportTaskProcessorJob*>(job);
+  if (rjob == nullptr)
+    return false;
+
+  // compare the base properties
+  bool equalBase = m_path == rjob->m_path && m_callback == rjob->m_callback &&
+                   m_task == rjob->m_task && m_progress == rjob->m_progress &&
+                   m_importTaskData.size() == rjob->m_importTaskData.size();
+  if (!equalBase)
+    return false;
+
+  // compare the import task data
+  for (const auto& importTaskData : m_importTaskData)
+  {
+    const auto& rjobImportTaskData = rjob->m_importTaskData.find(importTaskData.first);
+    if (rjobImportTaskData == rjob->m_importTaskData.end())
+      return false;
+
+    if (importTaskData.second.m_import != rjobImportTaskData->second.m_import ||
+        importTaskData.second.m_partialChangeset != rjobImportTaskData->second.m_partialChangeset)
+      return false;
+  }
+
+  return true;
+}
+
+bool CMediaImportTaskProcessorJob::ProcessTask()
+{
+  // check if no task is set and there are no more task types to be performed
+  if (m_task == nullptr && m_taskTypesToBeProcessed.empty())
+    return true;
+
+  // if a task is set perform it
+  if (m_task != nullptr)
+  {
+    // get an independent reference to m_task as it will be reset by ProcessTask()
+    IMediaImportTask* task = m_task;
+
+    // let the current task do its work
+    bool success = ProcessTask(task);
+
+    // delete the previously processed task
+    delete task;
+
+    return success;
+  }
+
+  // if there are no media imports there's nothing to be processed
+  if (m_importTaskData.empty())
+    return true;
+
+  // there's no task set and still task types to perform so go through all the media imports and perform the next task type
+  MediaImportTaskType currentTaskType = m_taskTypesToBeProcessed.front();
+
+  switch (currentTaskType)
+  {
+    case MediaImportTaskType::LocalItemsRetrieval:
+      ProcessLocalItemsRetrievalTasks();
+      break;
+
+    case MediaImportTaskType::ImportItemsRetrieval:
+      ProcessImportItemsRetrievalTasks();
+      break;
+
+    case MediaImportTaskType::Changeset:
+      ProcessChangesetTasks();
+      break;
+
+    case MediaImportTaskType::Synchronisation:
+      ProcessSynchronisationTasks();
+      break;
+
+    case MediaImportTaskType::Cleanup:
+      ProcessCleanupTasks();
+      break;
+
+    case MediaImportTaskType::Removal:
+      ProcessRemovalTasks();
+      break;
+
+    default:
+      s_logger->warn("unknown import task type {}", static_cast<int>(currentTaskType));
+      return false;
+  }
+
+  // remove the processed task type from the list of task types to process
+  m_taskTypesToBeProcessed.erase(m_taskTypesToBeProcessed.begin());
+
+  // let's do another round of processing in case there's more to do
+  return ProcessTask();
+}
+
+bool CMediaImportTaskProcessorJob::ProcessTask(IMediaImportTask* task)
+{
+  if (task == nullptr)
+    return false;
+
+  SetTask(task);
+
+  // let the current task do its work
+  CLog::Log(LOGDEBUG, "CMediaImportTaskProcessorJob: processing %s task",
+    MediaImportTaskTypes::ToString(task->GetType()).c_str());
+  bool success = task->DoWork();
+
+  // the task has been completed
+  success &= OnTaskComplete(success, task);
+
+  ResetTask();
+
+  return success;
+}
+
+void CMediaImportTaskProcessorJob::ProcessLocalItemsRetrievalTasks()
+{
+  for (auto&& taskData = m_importTaskData.begin(); taskData != m_importTaskData.end();)
+  {
+    std::map<MediaType, MediaImportHandlerPtr> mediaImportHandlers;
+    for (const auto& mediaTypeData : taskData->second.m_mediaTypeData)
+      mediaImportHandlers.insert(
+          std::make_pair(mediaTypeData.m_mediaType,
+                         MediaImportHandlerPtr(mediaTypeData.m_importHandler->Create())));
+
+    const CMediaImport& import = taskData->second.m_import;
+    CMediaImportLocalItemsRetrievalTask* localItemsRetrievalTask =
+        new CMediaImportLocalItemsRetrievalTask(import, mediaImportHandlers);
+
+    // if processing the task failed remove the import (no cleanup needed)
+    s_logger->info("starting local items retrieval task for items from {}...", import);
+    if (!ProcessTask(localItemsRetrievalTask))
+    {
+      s_logger->error("local items retrieval task for items from {} failed", import);
+      m_importTaskData.erase(taskData++);
+      delete localItemsRetrievalTask;
+      continue;
+    }
+
+    // get the local items
+    for (auto& mediaTypeData : taskData->second.m_mediaTypeData)
+      mediaTypeData.m_localItems =
+          localItemsRetrievalTask->GetLocalItems(mediaTypeData.m_mediaType);
+
+    delete localItemsRetrievalTask;
+    ++taskData;
+  }
+}
+
+void CMediaImportTaskProcessorJob::ProcessImportItemsRetrievalTasks()
+{
+  for (auto&& taskData = m_importTaskData.begin(); taskData != m_importTaskData.end();)
+  {
+    const CMediaImport& import = taskData->second.m_import;
+    CMediaImportImportItemsRetrievalTask* importItemsRetrievalTask =
+        new CMediaImportImportItemsRetrievalTask(import, m_importerManager);
+
+    // add all previously imported items
+    const auto& mediaTypes = import.GetMediaTypes();
+    for (auto& mediaTypeData : taskData->second.m_mediaTypeData)
+    {
+      if (std::find(mediaTypes.begin(), mediaTypes.end(), mediaTypeData.m_mediaType) !=
+          mediaTypes.end())
+        importItemsRetrievalTask->SetLocalItems(mediaTypeData.m_localItems,
+                                                mediaTypeData.m_mediaType);
+    }
+
+    // if processing the task failed remove the import (no cleanup needed)
+    s_logger->info("starting import items retrieval task for items from {}...", import);
+    if (!ProcessTask(importItemsRetrievalTask))
+    {
+      s_logger->warn("import items retrieval task for items from {} failed", import);
+      m_importTaskData.erase(taskData++);
+      delete importItemsRetrievalTask;
+      continue;
+    }
+
+    // get back the import (in case it has changed)
+    taskData->second.m_import = importItemsRetrievalTask->GetImport();
+
+    // check whether to perform a full or partial changeset
+    taskData->second.m_partialChangeset = importItemsRetrievalTask->IsChangeset();
+
+    // get the retrieved items
+    for (auto& mediaTypeData : taskData->second.m_mediaTypeData)
+      mediaTypeData.m_importedItems =
+          importItemsRetrievalTask->GetRetrievedItems(mediaTypeData.m_mediaType);
+
+    delete importItemsRetrievalTask;
+    ++taskData;
+  }
+}
+
+void CMediaImportTaskProcessorJob::ProcessChangesetTasks()
+{
+  for (auto&& taskData : m_importTaskData)
+  {
+    const CMediaImport& import = taskData.second.m_import;
+    for (auto&& mediaTypeData = taskData.second.m_mediaTypeData.begin();
+         mediaTypeData != taskData.second.m_mediaTypeData.end();)
+    {
+      CMediaImportChangesetTask* changesetTask = new CMediaImportChangesetTask(
+          import, MediaImportHandlerPtr(mediaTypeData->m_importHandler->Create()),
+          mediaTypeData->m_localItems, mediaTypeData->m_importedItems,
+          taskData.second.m_partialChangeset);
+
+      // if processing the task failed remove the import (no cleanup needed)
+      s_logger->info("starting import changeset task for {} items from {}...",
+                     mediaTypeData->m_mediaType.c_str(), import);
+      if (!ProcessTask(changesetTask))
+      {
+        s_logger->warn("import changeset task for {} items from {} failed",
+                       mediaTypeData->m_mediaType.c_str(), import);
+        mediaTypeData = taskData.second.m_mediaTypeData.erase(mediaTypeData);
+        delete changesetTask;
+        continue;
+      }
+
+      // get the changeset
+      mediaTypeData->m_importedItems = changesetTask->GetChangeset();
+      delete changesetTask;
+
+      // if the changeset is empty there is nothing else to do
+      if (mediaTypeData->m_importedItems.empty())
+      {
+        s_logger->debug("no {} items from {} changed", mediaTypeData->m_mediaType.c_str(), import);
+      }
+
+      ++mediaTypeData;
+    }
+  }
+}
+
+void CMediaImportTaskProcessorJob::ProcessSynchronisationTasks()
+{
+  // go through all imports and their media types in the proper order and perform the synchronisation
+  for (auto& taskData : m_importTaskData)
+  {
+    // go through all media types in the proper order and perform the synchronisation
+    for (auto&& mediaTypeData = taskData.second.m_mediaTypeData.begin();
+         mediaTypeData != taskData.second.m_mediaTypeData.end(); ++mediaTypeData)
+    {
+      const CMediaImport& import = taskData.second.m_import;
+      CMediaImportSynchronisationTask* synchronisationTask = new CMediaImportSynchronisationTask(
+          import, MediaImportHandlerPtr(mediaTypeData->m_importHandler->Create()),
+          mediaTypeData->m_importedItems);
+
+      // if processing the task failed remove the import (no cleanup needed)
+      s_logger->info("starting import synchronisation task for {} items from {}...",
+                     mediaTypeData->m_mediaType.c_str(), import);
+      if (!ProcessTask(synchronisationTask))
+      {
+        s_logger->warn("import changeset task for {} items from {} failed",
+                       mediaTypeData->m_mediaType.c_str(), import);
+        // don't remove the import even though it failed because we should run the cleanup
+      }
+
+      delete synchronisationTask;
+    }
+  }
+}
+
+void CMediaImportTaskProcessorJob::ProcessCleanupTasks()
+{
+  // go through all imports and their media types in the proper order and clean them up
+  for (auto& taskData : m_importTaskData)
+  {
+    // go through all media types in the proper order and clean them up
+    for (auto&& mediaTypeData = taskData.second.m_mediaTypeData.rbegin();
+         mediaTypeData != taskData.second.m_mediaTypeData.rend(); ++mediaTypeData)
+    {
+      const CMediaImport& import = taskData.second.m_import;
+      CMediaImportCleanupTask* cleanupTask = new CMediaImportCleanupTask(
+          import, MediaImportHandlerPtr(mediaTypeData->m_importHandler->Create()));
+
+      // if processing the task failed remove the import (no cleanup needed)
+      s_logger->info("starting import cleanup task for {} items from {}...",
+                     mediaTypeData->m_mediaType.c_str(), import);
+      if (!ProcessTask(cleanupTask))
+      {
+        s_logger->warn("import cleanup task for {} items from {} failed",
+                       mediaTypeData->m_mediaType.c_str(), import);
+      }
+
+      delete cleanupTask;
+    }
+  }
+}
+
+void CMediaImportTaskProcessorJob::ProcessRemovalTasks()
+{
+  // go through all imports and their media types in the proper order and remove them
+  for (auto& taskData : m_importTaskData)
+  {
+    // go through all media types in the proper order and remove them
+    for (auto&& mediaTypeData = taskData.second.m_mediaTypeData.rbegin();
+         mediaTypeData != taskData.second.m_mediaTypeData.rend(); ++mediaTypeData)
+    {
+      const CMediaImport& import = taskData.second.m_import;
+      CMediaImportRemovalTask* removalTask = new CMediaImportRemovalTask(
+          import, MediaImportHandlerPtr(mediaTypeData->m_importHandler->Create()));
+
+      // if processing the task failed remove the import
+      s_logger->info("starting import removal task for {} items from {}...",
+                     mediaTypeData->m_mediaType.c_str(), import);
+      if (!ProcessTask(removalTask))
+        s_logger->warn("import removal task for {} items from {} failed",
+                       mediaTypeData->m_mediaType.c_str(), import);
+
+      delete removalTask;
+    }
+  }
+}
+
+bool CMediaImportTaskProcessorJob::OnTaskComplete(bool success, const IMediaImportTask* task)
+{
+  if (m_callback == nullptr)
+    return true;
+
+  return m_callback->OnTaskComplete(success, task);
+}
+
+bool CMediaImportTaskProcessorJob::AddImport(const CMediaImport& import,
+                                             std::vector<MediaImportTaskType> tasksToBeProcessed)
+{
+  if (m_importHandlerManager == nullptr)
+  {
+    s_logger->error("invalid media import handler manager implementation");
+    return false;
+  }
+
+  // check if an import with that path and media type already exists
+  const auto& itImportTaskData =
+      m_importTaskData.find(std::make_pair(import.GetPath(), import.GetMediaTypes()));
+  if (itImportTaskData != m_importTaskData.end())
+    return false;
+
+  // add the import to the map of imports to process
+  MediaImportTaskData importTaskData = {import};
+
+  // get the import handlers
+  for (const auto& mediaType : import.GetMediaTypes())
+  {
+    MediaImportTaskData::MediaTypeTaskData mediaTypeData = {
+        mediaType, m_importHandlerManager->GetImportHandler(mediaType)};
+    if (mediaTypeData.m_importHandler == nullptr)
+      return false;
+
+    importTaskData.m_mediaTypeData.push_back(mediaTypeData);
+  }
+
+  m_importTaskData.emplace(std::make_pair(import.GetPath(), import.GetMediaTypes()),
+                           importTaskData);
+
+  // determine the tasks (and their order) to process
+  if (tasksToBeProcessed.empty())
+  {
+    // always do a retrieval
+    tasksToBeProcessed.push_back(MediaImportTaskType::LocalItemsRetrieval);
+    tasksToBeProcessed.push_back(MediaImportTaskType::ImportItemsRetrieval);
+
+    // also add the changeset task (even though it might not be performed depending on the importer being used)
+    tasksToBeProcessed.push_back(MediaImportTaskType::Changeset);
+
+    // always do a sychronisation and cleanup
+    tasksToBeProcessed.push_back(MediaImportTaskType::Synchronisation);
+    tasksToBeProcessed.push_back(MediaImportTaskType::Cleanup);
+  }
+
+  // now synchronise the list of tasks to be processed for this import with the one for all imports
+  if (m_taskTypesToBeProcessed.empty())
+    m_taskTypesToBeProcessed = tasksToBeProcessed;
+  else
+  {
+    size_t start_index = 0;
+    for (const auto& newTask : tasksToBeProcessed)
+    {
+      bool found = false;
+      for (std::vector<MediaImportTaskType>::const_iterator task =
+               m_taskTypesToBeProcessed.begin() + start_index;
+           task != m_taskTypesToBeProcessed.end(); ++task)
+      {
+        if (*task == newTask)
+        {
+          start_index = std::distance<std::vector<MediaImportTaskType>::const_iterator>(
+              m_taskTypesToBeProcessed.begin(), task);
+          found = true;
+          break;
+        }
+      }
+
+      // if the new task hasn't been found insert it at the earliest position
+      if (!found)
+      {
+        m_taskTypesToBeProcessed.insert(m_taskTypesToBeProcessed.begin() + start_index, newTask);
+        start_index += 1;
+      }
+    }
+  }
+
+  return true;
+}
diff --git a/xbmc/media/import/jobs/MediaImportTaskProcessorJob.h b/xbmc/media/import/jobs/MediaImportTaskProcessorJob.h
new file mode 100644
index 000000000000..3caa8e7ee598
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportTaskProcessorJob.h
@@ -0,0 +1,138 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "LibraryQueue.h"
+#include "media/MediaType.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/IMediaImportHandlerManager.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/IMediaImporterManager.h"
+#include "media/import/MediaImport.h"
+#include "media/import/MediaImportChangesetTypes.h"
+#include "media/import/jobs/MediaImportTaskTypes.h"
+#include "utils/StaticLoggerBase.h"
+
+#include <string>
+#include <vector>
+
+class CFileItem;
+class CGUIDialogProgressBarHandle;
+class CMediaImportSource;
+class IMediaImportTask;
+class IMediaImportTaskCallback;
+
+class CMediaImportTaskProcessorJob : public CLibraryJob, protected CStaticLoggerBase
+{
+public:
+  virtual ~CMediaImportTaskProcessorJob();
+
+  static CMediaImportTaskProcessorJob* Import(
+      const CMediaImport& import,
+      bool automatically,
+      const IMediaImporterManager* importerManager,
+      const IMediaImportHandlerManager* importHandlerManager,
+      IMediaImportTaskCallback* callback);
+
+  static CMediaImportTaskProcessorJob* ChangeImportedItems(
+      const CMediaImport& import,
+      const ChangesetItems& items,
+      const IMediaImportHandlerManager* importHandlerManager,
+      IMediaImportTaskCallback* callback);
+
+  static CMediaImportTaskProcessorJob* UpdateImportedItemOnSource(
+      const CMediaImport& import,
+      const CFileItem& item,
+      const IMediaImporterManager* importerManager,
+      IMediaImportTaskCallback* callback);
+
+  static CMediaImportTaskProcessorJob* Cleanup(
+      const CMediaImportSource& source,
+      const std::vector<CMediaImport>& imports,
+      const IMediaImportHandlerManager* importHandlerManager,
+      IMediaImportTaskCallback* callback);
+  static CMediaImportTaskProcessorJob* Cleanup(
+      const CMediaImport& import,
+      const IMediaImportHandlerManager* importHandlerManager,
+      IMediaImportTaskCallback* callback);
+
+  static CMediaImportTaskProcessorJob* Remove(
+      const CMediaImportSource& source,
+      const std::vector<CMediaImport>& imports,
+      const IMediaImportHandlerManager* importHandlerManager,
+      IMediaImportTaskCallback* callback);
+  static CMediaImportTaskProcessorJob* Remove(
+      const CMediaImport& import,
+      const IMediaImportHandlerManager* importHandlerManager,
+      IMediaImportTaskCallback* callback);
+
+  const std::string& GetPath() const { return m_path; }
+
+  void SetTask(IMediaImportTask* task);
+  void ResetTask();
+  const IMediaImportTask* GetCurrentTask() const { return m_task; }
+
+  /*!
+   * \brief Get the progress bar handle instance used by the import task
+   */
+  CGUIDialogProgressBarHandle* GetProgressBarHandle(const std::string& title = "");
+
+  // implementation of CJob
+  virtual bool DoWork();
+  virtual const char* GetType() const { return "MediaImportTaskProcessorJob"; }
+  virtual bool operator==(const CJob* job) const;
+
+protected:
+  CMediaImportTaskProcessorJob(const std::string& path,
+                               const IMediaImporterManager* importerManager,
+                               const IMediaImportHandlerManager* importHandlerManager,
+                               IMediaImportTaskCallback* callback,
+                               bool hasProgress);
+
+  bool ProcessTask();
+  bool ProcessTask(IMediaImportTask* task);
+  void ProcessLocalItemsRetrievalTasks();
+  void ProcessImportItemsRetrievalTasks();
+  void ProcessChangesetTasks();
+  void ProcessSynchronisationTasks();
+  void ProcessCleanupTasks();
+  void ProcessRemovalTasks();
+  bool OnTaskComplete(bool success, const IMediaImportTask* task);
+
+  bool AddImport(const CMediaImport& import, std::vector<MediaImportTaskType> tasksToBeProcessed);
+
+  const IMediaImporterManager* m_importerManager;
+  const IMediaImportHandlerManager* m_importHandlerManager;
+  IMediaImportTaskCallback* m_callback;
+  IMediaImportTask* m_task;
+  bool m_hasProgress;
+  CGUIDialogProgressBarHandle* m_progress;
+  std::string m_path;
+
+  typedef struct MediaImportTaskData
+  {
+    CMediaImport m_import;
+
+    bool m_partialChangeset;
+
+    typedef struct MediaTypeTaskData
+    {
+      MediaType m_mediaType;
+      MediaImportHandlerConstPtr m_importHandler;
+      std::vector<CFileItemPtr> m_localItems;
+      ChangesetItems m_importedItems;
+    } MediaTypeTaskData;
+
+    std::vector<MediaTypeTaskData> m_mediaTypeData;
+  } MediaImportTaskData;
+
+  using MediaImportTaskKey = std::pair<std::string, GroupedMediaTypes>;
+  std::map<MediaImportTaskKey, MediaImportTaskData> m_importTaskData;
+  std::vector<MediaImportTaskType> m_taskTypesToBeProcessed;
+};
diff --git a/xbmc/media/import/jobs/MediaImportTaskTypes.h b/xbmc/media/import/jobs/MediaImportTaskTypes.h
new file mode 100644
index 000000000000..3df736a7f7da
--- /dev/null
+++ b/xbmc/media/import/jobs/MediaImportTaskTypes.h
@@ -0,0 +1,58 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+enum class MediaImportTaskType
+{
+  LocalItemsRetrieval,
+  ImportItemsRetrieval,
+  Changeset,
+  Synchronisation,
+  Cleanup,
+  Update,
+  Removal
+};
+
+class MediaImportTaskTypes
+{
+public:
+  MediaImportTaskTypes() = delete;
+
+  static std::string ToString(MediaImportTaskType taskType)
+  {
+    switch (taskType)
+    {
+      case MediaImportTaskType::LocalItemsRetrieval:
+        return "local items retrieval";
+
+      case MediaImportTaskType::ImportItemsRetrieval:
+        return "import items retrieval";
+
+      case MediaImportTaskType::Changeset:
+        return "changeset";
+
+      case MediaImportTaskType::Synchronisation:
+        return "synchronisation";
+
+      case MediaImportTaskType::Cleanup:
+        return "cleanup";
+
+      case MediaImportTaskType::Update:
+        return "update";
+
+      case MediaImportTaskType::Removal:
+        return "removal";
+
+      default:
+        break;
+    }
+
+    return "unknown";
+  }
+};
diff --git a/xbmc/media/import/jobs/tasks/CMakeLists.txt b/xbmc/media/import/jobs/tasks/CMakeLists.txt
new file mode 100644
index 000000000000..b223b4e309a5
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/CMakeLists.txt
@@ -0,0 +1,19 @@
+set(SOURCES IMediaImportTask.cpp
+            MediaImportChangesetTask.cpp
+            MediaImportCleanupTask.cpp
+            MediaImportImportItemsRetrievalTask.cpp
+            MediaImportLocalItemsRetrievalTask.cpp
+            MediaImportRemovalTask.cpp
+            MediaImportSynchronisationTask.cpp
+            MediaImportUpdateTask.cpp)
+
+set(HEADERS IMediaImportTask.h
+            MediaImportChangesetTask.h
+            MediaImportCleanupTask.h
+            MediaImportImportItemsRetrievalTask.h
+            MediaImportLocalItemsRetrievalTask.h
+            MediaImportRemovalTask.h
+            MediaImportSynchronisationTask.h
+            MediaImportUpdateTask.h)
+
+core_add_library(media_import_jobs_tasks)
diff --git a/xbmc/media/import/jobs/tasks/IMediaImportTask.cpp b/xbmc/media/import/jobs/tasks/IMediaImportTask.cpp
new file mode 100644
index 000000000000..85279e70d2f5
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/IMediaImportTask.cpp
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "IMediaImportTask.h"
+
+#include "ServiceBroker.h"
+#include "utils/log.h"
+
+IMediaImportTask::IMediaImportTask(const std::string& name, const CMediaImport& import)
+  : m_logger(CServiceBroker::GetLogging().GetLogger(name)),
+    m_import(import),
+    m_processorJob(nullptr),
+    m_progress(nullptr)
+{
+}
+
+bool IMediaImportTask::ShouldCancel(unsigned int progress, unsigned int total) const
+{
+  if (m_processorJob == nullptr)
+    return false;
+
+  return m_processorJob->ShouldCancel(progress, total);
+}
+
+void IMediaImportTask::SetProgressTitle(const std::string& title)
+{
+  if (m_progress != nullptr)
+    m_progress->SetTitle(title);
+}
+
+void IMediaImportTask::SetProgressText(const std::string& text)
+{
+  if (m_progress != nullptr)
+    m_progress->SetText(text);
+}
+
+void IMediaImportTask::SetProgress(int progress, int total)
+{
+  if (m_progress != nullptr)
+    m_progress->SetProgress(progress, total);
+}
+
+void IMediaImportTask::PrepareProgressBarHandle(const std::string& title)
+{
+  if (m_processorJob != nullptr)
+    m_progress = m_processorJob->GetProgressBarHandle(title);
+}
diff --git a/xbmc/media/import/jobs/tasks/IMediaImportTask.h b/xbmc/media/import/jobs/tasks/IMediaImportTask.h
new file mode 100644
index 000000000000..bd24b846a3a7
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/IMediaImportTask.h
@@ -0,0 +1,126 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "dialogs/GUIDialogExtendedProgressBar.h"
+#include "media/import/MediaImport.h"
+#include "media/import/jobs/MediaImportTaskProcessorJob.h"
+#include "media/import/jobs/MediaImportTaskTypes.h"
+#include "utils/logtypes.h"
+
+/*!
+ * \brief Interface of a media importer capable of importing media items from
+ * a specific source into the local library.
+ */
+class IMediaImportTask
+{
+public:
+  virtual ~IMediaImportTask() = default;
+
+  /*!
+   * \brief Gets the import processed by the import task.
+   */
+  CMediaImport& GetImport() { return m_import; }
+
+  /*!
+   * \brief Gets the import processed by the import task.
+   */
+  const CMediaImport& GetImport() const { return m_import; }
+
+  /*!
+   * \brief Gets the processor job which is executing the import task.
+   */
+  CMediaImportTaskProcessorJob* GetProcessorJob() const { return m_processorJob; }
+
+  /*!
+   * \brief Sets the processor job which will be executing the import task.
+   */
+  void SetProcessorJob(CMediaImportTaskProcessorJob* processorJob)
+  {
+    m_processorJob = processorJob;
+  }
+
+  /*!
+   * \brief Get the progress bar handle instance used by the import task.
+   */
+  CGUIDialogProgressBarHandle* GetProgressBarHandle() const { return m_progress; }
+
+  /*!
+  * \brief Gets the type of the import task.
+  */
+  virtual MediaImportTaskType GetType() const = 0;
+
+  /*!
+   * \brief Executes the import task.
+   *
+   * \return True if the task succeeded, false otherwise
+   */
+  virtual bool DoWork() = 0;
+
+  /*
+   * \brief Updates the progress of the task and checks if it should be cancelled.
+   *
+   * \param progress Current progress
+   * \param total Total progress steps
+   * \return True if the task should be cancelled, false otherwise
+   */
+  bool ShouldCancel(unsigned int progress, unsigned int total) const;
+
+  /*
+   * \brief Sets the title of the progress indicator.
+   */
+  void SetProgressTitle(const std::string& title);
+
+  /*
+  * \brief Sets the text/description of the progress indicator.
+  */
+  void SetProgressText(const std::string& text);
+
+  /*
+   * \brief Sets the progress of the progress indicator.
+   *
+   * \param progress Current progress
+   * \param total Total progress steps
+   */
+  void SetProgress(int progress, int total);
+
+protected:
+  IMediaImportTask(const std::string& name, const CMediaImport& import);
+
+  /*
+   * \brief Prepares a progress indicator with the given title set.
+   *
+   * \param title Title to be set in the progress indicator.
+   */
+  void PrepareProgressBarHandle(const std::string& title);
+
+  Logger m_logger;
+
+  CMediaImport m_import;
+  CMediaImportTaskProcessorJob* m_processorJob;
+  CGUIDialogProgressBarHandle* m_progress;
+};
+
+class IMediaImportTaskCallback
+{
+public:
+  virtual ~IMediaImportTaskCallback() = default;
+
+  /*
+   * \brief Callback for completed tasks.
+   *
+   * \param success Whether the task succeeded or failed.
+   * \param task The task that has completed
+   * \return True if the callback succeeded, false otherwise
+   */
+  virtual bool OnTaskComplete(bool success, const IMediaImportTask* task) = 0;
+
+protected:
+  IMediaImportTaskCallback() = default;
+};
diff --git a/xbmc/media/import/jobs/tasks/MediaImportChangesetTask.cpp b/xbmc/media/import/jobs/tasks/MediaImportChangesetTask.cpp
new file mode 100644
index 000000000000..879bd3667e96
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportChangesetTask.cpp
@@ -0,0 +1,144 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportChangesetTask.h"
+
+#include "guilib/LocalizeStrings.h"
+#include "media/import/IMediaImportHandler.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportChangesetTask::CMediaImportChangesetTask(const CMediaImport& import,
+                                                     MediaImportHandlerPtr importHandler,
+                                                     const std::vector<CFileItemPtr>& localItems,
+                                                     const ChangesetItems& retrievedItems,
+                                                     bool partialChangeset /* = false */)
+  : IMediaImportTask("CMediaImportChangesetTask", import),
+    m_importHandler(importHandler),
+    m_localItems(localItems),
+    m_retrievedItems(retrievedItems),
+    m_partialChangeset(partialChangeset)
+{
+}
+
+bool CMediaImportChangesetTask::DoWork()
+{
+  size_t total = m_retrievedItems.size();
+  size_t progress = 0;
+
+  // prepare the progress bar
+  PrepareProgressBarHandle(StringUtils::Format(g_localizeStrings.Get(39559).c_str(),
+                                               m_import.GetSource().GetFriendlyName().c_str()));
+  SetProgressText(StringUtils::Format(
+      g_localizeStrings.Get(39560).c_str(),
+      CMediaTypes::GetPluralLocalization(m_importHandler->GetMediaType()).c_str()));
+
+  if (ShouldCancel(0, total))
+    return false;
+
+  const auto& settings = m_import.Settings();
+
+  for (ChangesetItems::iterator item = m_retrievedItems.begin(); item != m_retrievedItems.end();)
+  {
+    // check if we should cancel
+    if (ShouldCancel(progress, total))
+      return false;
+
+    if (item->second == nullptr)
+      item->first = MediaImportChangesetType::None;
+    else
+    {
+      // try to find a local item matching the retrieved item
+      CFileItemPtr matchingLocalItem =
+          m_importHandler->FindMatchingLocalItem(m_import, item->second.get(), m_localItems);
+
+      // no matching local item found
+      if (matchingLocalItem == nullptr)
+      {
+        if (!m_partialChangeset)
+          item->first = MediaImportChangesetType::Added;
+        else
+        {
+          if (item->first == MediaImportChangesetType::None ||
+              item->first == MediaImportChangesetType::Added)
+            item->first = MediaImportChangesetType::Added;
+          else
+          {
+            // cannot change or remove an imported item without a matching local item
+            if (item->first == MediaImportChangesetType::Changed)
+            {
+              m_logger->warn(
+                  "unable to change item {} from {} because there's no matching local item",
+                  item->second->GetPath(), m_import);
+            }
+
+            item->first = MediaImportChangesetType::None;
+          }
+        }
+      }
+      else
+      {
+        if (m_partialChangeset)
+        {
+          // we can't add an item that has already been imported so we'll update it
+          if (item->first == MediaImportChangesetType::None ||
+              item->first == MediaImportChangesetType::Added)
+            item->first = MediaImportChangesetType::Changed;
+          // if the item should be removed we need to replace it with the matching local item
+          else if (item->first == MediaImportChangesetType::Removed)
+            item->second = matchingLocalItem;
+        }
+
+        // remove the matching item from the local list so that the imported item is not considered non-existant
+        m_localItems.erase(std::remove(m_localItems.begin(), m_localItems.end(), matchingLocalItem),
+                           m_localItems.end());
+
+        // ignoring items to be removed
+        if (item->first != MediaImportChangesetType::Removed)
+        {
+          // nothing to do if we don't need to update imported items
+          if (!settings->UpdateImportedMediaItems())
+            item->first = MediaImportChangesetType::None;
+          // otherwise determine the changeset type and prepare the imported item
+          else
+          {
+            // determine the changeset state of the item
+            item->first = m_importHandler->DetermineChangeset(m_import, item->second.get(),
+                                                              matchingLocalItem);
+
+            // if the imported item has changed prepare it for updating
+            if (item->first != MediaImportChangesetType::None)
+              m_importHandler->PrepareImportedItem(m_import, item->second.get(), matchingLocalItem);
+          }
+        }
+      }
+    }
+
+    // if the changeset state couldn't be determined, ignore the item
+    if (item->first == MediaImportChangesetType::None)
+      item = m_retrievedItems.erase(item);
+    else
+      ++item;
+
+    ++progress;
+    SetProgress(progress, total);
+  }
+
+  if (!m_partialChangeset)
+  {
+    // all local items left need to be removed
+    for (const auto& item : m_localItems)
+      m_retrievedItems.push_back(std::make_pair(MediaImportChangesetType::Removed, item));
+  }
+
+  m_localItems.clear();
+
+  return true;
+}
diff --git a/xbmc/media/import/jobs/tasks/MediaImportChangesetTask.h b/xbmc/media/import/jobs/tasks/MediaImportChangesetTask.h
new file mode 100644
index 000000000000..f55df640e32a
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportChangesetTask.h
@@ -0,0 +1,39 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "FileItem.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/MediaImportChangesetTypes.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+
+#include <vector>
+
+class CMediaImportChangesetTask : public IMediaImportTask
+{
+public:
+  CMediaImportChangesetTask(const CMediaImport& import,
+                            MediaImportHandlerPtr importHandler,
+                            const std::vector<CFileItemPtr>& localItems,
+                            const ChangesetItems& retrievedItems,
+                            bool partialChangeset = false);
+  virtual ~CMediaImportChangesetTask() = default;
+
+  const ChangesetItems& GetChangeset() const { return m_retrievedItems; }
+
+  // implementation of IMediaImportTask
+  MediaImportTaskType GetType() const override { return MediaImportTaskType::Changeset; }
+  bool DoWork() override;
+
+protected:
+  MediaImportHandlerPtr m_importHandler;
+  std::vector<CFileItemPtr> m_localItems;
+  ChangesetItems m_retrievedItems;
+  bool m_partialChangeset;
+};
diff --git a/xbmc/media/import/jobs/tasks/MediaImportCleanupTask.cpp b/xbmc/media/import/jobs/tasks/MediaImportCleanupTask.cpp
new file mode 100644
index 000000000000..036ad7c04660
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportCleanupTask.cpp
@@ -0,0 +1,47 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportCleanupTask.h"
+
+#include "guilib/LocalizeStrings.h"
+#include "media/MediaType.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/MediaImportManager.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportCleanupTask::CMediaImportCleanupTask(const CMediaImport& import,
+                                                 MediaImportHandlerPtr importHandler)
+  : IMediaImportTask("CMediaImportCleanupTask", import), m_importHandler(importHandler)
+{
+}
+
+bool CMediaImportCleanupTask::DoWork()
+{
+  if (m_importHandler == nullptr)
+    return false;
+
+  // prepare the progress bar
+  PrepareProgressBarHandle(StringUtils::Format(
+      g_localizeStrings.Get(39569).c_str(), CMediaTypes::ToLabel(m_import.GetMediaTypes()).c_str(),
+      m_import.GetSource().GetFriendlyName().c_str()));
+  SetProgressText("");
+
+  m_logger->info("cleaning up imported {} items from {}", m_importHandler->GetMediaType(),
+                 m_import.GetSource());
+
+  if (!m_importHandler->CleanupImportedItems(m_import))
+    return false;
+
+  // now make sure the items are enabled
+  m_importHandler->SetImportedItemsEnabled(m_import, true);
+
+  return true;
+}
diff --git a/xbmc/media/import/jobs/tasks/MediaImportCleanupTask.h b/xbmc/media/import/jobs/tasks/MediaImportCleanupTask.h
new file mode 100644
index 000000000000..44a15b27586b
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportCleanupTask.h
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+
+class CMediaImportCleanupTask : public IMediaImportTask
+{
+public:
+  CMediaImportCleanupTask(const CMediaImport& import, MediaImportHandlerPtr importHandler);
+  virtual ~CMediaImportCleanupTask() = default;
+
+  // implementation of IMediaImportTask
+  MediaImportTaskType GetType() const override { return MediaImportTaskType::Cleanup; }
+  bool DoWork() override;
+
+protected:
+  MediaImportHandlerPtr m_importHandler;
+};
diff --git a/xbmc/media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.cpp b/xbmc/media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.cpp
new file mode 100644
index 000000000000..b597f0d797e1
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.cpp
@@ -0,0 +1,109 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportImportItemsRetrievalTask.h"
+
+#include "guilib/LocalizeStrings.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/MediaImportManager.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportImportItemsRetrievalTask::CMediaImportImportItemsRetrievalTask(
+    const CMediaImport& import, const IMediaImporterManager* importerManager)
+  : IMediaImportTask("CMediaImportImportItemsRetrievalTask", import),
+    m_importerManager(importerManager),
+    m_importer(),
+    m_retrievedItems(),
+    m_isChangeset(false)
+{
+  // pre-fill the item maps with all media types to be retrieved
+  for (const auto& mediaType : import.GetMediaTypes())
+  {
+    m_localItems.insert(std::make_pair(mediaType, std::vector<CFileItemPtr>()));
+    m_retrievedItems.insert(std::make_pair(mediaType, ChangesetItems()));
+  }
+}
+
+bool CMediaImportImportItemsRetrievalTask::DoWork()
+{
+  if (m_importer == nullptr)
+  {
+    if (m_importerManager == nullptr)
+    {
+      m_logger->error("invalid media importer manager implementation");
+      return false;
+    }
+
+    // look for an importer than can handle the given path
+    m_importer = m_importerManager->GetImporterBySource(m_import.GetSource());
+    if (m_importer == nullptr)
+    {
+      m_logger->error("no importer capable of handling source {} found", m_import.GetSource());
+      return false;
+    }
+  }
+
+  PrepareProgressBarHandle(StringUtils::Format(g_localizeStrings.Get(39558).c_str(),
+                                               m_import.GetSource().GetFriendlyName()));
+
+  return m_importer->Import(this);
+}
+
+std::vector<CFileItemPtr> CMediaImportImportItemsRetrievalTask::GetLocalItems(
+    const MediaType& mediaType)
+{
+  auto localItems = m_localItems.find(mediaType);
+  if (localItems == m_localItems.end())
+    return {};
+
+  return localItems->second;
+}
+
+void CMediaImportImportItemsRetrievalTask::SetLocalItems(const std::vector<CFileItemPtr>& items,
+                                                         const MediaType& mediaType)
+{
+  auto localItems = m_localItems.find(mediaType);
+  if (localItems == m_localItems.end())
+    return;
+
+  localItems->second = items;
+}
+
+void CMediaImportImportItemsRetrievalTask::AddItem(
+    const CFileItemPtr& item,
+    const MediaType& mediaType,
+    MediaImportChangesetType changesetType /* = MediaImportChangesetTypeNone */)
+{
+  auto retrievedItems = m_retrievedItems.find(mediaType);
+  if (retrievedItems == m_retrievedItems.end())
+    return;
+
+  retrievedItems->second.push_back(std::make_pair(changesetType, item));
+}
+
+void CMediaImportImportItemsRetrievalTask::AddItems(
+    const std::vector<CFileItemPtr>& items,
+    const MediaType& mediaType,
+    MediaImportChangesetType changesetType /* = MediaImportChangesetTypeNone */)
+{
+  for (const auto& item : items)
+    AddItem(item, mediaType, changesetType);
+}
+
+void CMediaImportImportItemsRetrievalTask::SetItems(const ChangesetItems& items,
+                                                    const MediaType& mediaType)
+{
+  auto retrievedItems = m_retrievedItems.find(mediaType);
+  if (retrievedItems == m_retrievedItems.end())
+    return;
+
+  retrievedItems->second = items;
+}
diff --git a/xbmc/media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.h b/xbmc/media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.h
new file mode 100644
index 000000000000..4cd24c92a36c
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.h
@@ -0,0 +1,114 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/MediaType.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/IMediaImporterManager.h"
+#include "media/import/MediaImportChangesetTypes.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+
+#include <map>
+#include <memory>
+
+class CMediaImportImportItemsRetrievalTask : public IMediaImportTask
+{
+public:
+  CMediaImportImportItemsRetrievalTask(const CMediaImport& import,
+                                       const IMediaImporterManager* importerManager);
+  virtual ~CMediaImportImportItemsRetrievalTask() = default;
+
+  /*!
+   * \brief Get the IMediaImporter instance used by the import job
+   */
+  const std::shared_ptr<IMediaImporter> GetImporter() const { return m_importer; }
+
+  /*!
+   * \brief Get the media type of the media import
+   */
+  const GroupedMediaTypes& GetMediaTypes() const { return GetImport().GetMediaTypes(); }
+
+  /*!
+   * \brief Get a list of previously imported items
+   *
+   * \param mediaType media type of the imported items
+   * \return list of previously imported items
+   */
+  std::vector<CFileItemPtr> GetLocalItems(const MediaType& mediaType);
+
+  /*!
+  * \brief Add a list of previously imported items of a specific media type
+  *
+  * \param items previously imported items
+  * \param mediaType media type of the items
+  */
+  void SetLocalItems(const std::vector<CFileItemPtr>& items, const MediaType& mediaType);
+
+  /*!
+   * \brief Get a list of imported items
+   *
+   * \param mediaType media type of the imported items
+   * \return list of imported items
+   */
+  const ChangesetItems& GetRetrievedItems(const MediaType& mediaType) const
+  {
+    return m_retrievedItems.find(mediaType)->second;
+  }
+
+  /*!
+   * \brief Whether the retrieved items are already a changeset or not
+   */
+  bool IsChangeset() const { return m_isChangeset; }
+
+  /*!
+   * \brief Add an imported item of a specific changeset type
+   *
+   * \param item imported item
+   * \param mediaType media type of the item
+   * \param changesetType changeset type of the imported item
+   */
+  void AddItem(const CFileItemPtr& item,
+               const MediaType& mediaType,
+               MediaImportChangesetType changesetType = MediaImportChangesetType::None);
+
+  /*!
+  * \brief Add a list of imported items of a specific changeset type
+  *
+  * \param items imported items
+   * \param mediaType media type of the items
+  * \param changesetType changeset type of the imported items
+  */
+  void AddItems(const std::vector<CFileItemPtr>& items,
+                const MediaType& mediaType,
+                MediaImportChangesetType changesetType = MediaImportChangesetType::None);
+
+  /*!
+   * \brief Add a list of imported items of a specific media type
+   *
+   * \param items imported items
+   * \param mediaType media type of the items
+   */
+  void SetItems(const ChangesetItems& items, const MediaType& mediaType);
+
+  /*!
+   * \brief Specify whether the retrieved items are a changeset or not
+   */
+  void SetChangeset(bool isChangeset) { m_isChangeset = isChangeset; }
+
+  // implementation of IMediaImportTask
+  MediaImportTaskType GetType() const override { return MediaImportTaskType::ImportItemsRetrieval; }
+  bool DoWork() override;
+
+protected:
+  const IMediaImporterManager* m_importerManager;
+  std::shared_ptr<IMediaImporter> m_importer;
+  std::map<MediaType, std::vector<CFileItemPtr>> m_localItems;
+  std::map<MediaType, ChangesetItems> m_retrievedItems;
+  bool m_isChangeset;
+};
diff --git a/xbmc/media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.cpp b/xbmc/media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.cpp
new file mode 100644
index 000000000000..493f7a64353d
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.cpp
@@ -0,0 +1,54 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportLocalItemsRetrievalTask.h"
+
+#include "guilib/LocalizeStrings.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/MediaImportManager.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportLocalItemsRetrievalTask::CMediaImportLocalItemsRetrievalTask(
+    const CMediaImport& import, std::map<MediaType, MediaImportHandlerPtr> importHandlers)
+  : IMediaImportTask("CMediaImportLocalItemsRetrievalTask", import),
+    m_importHandlers(importHandlers),
+    m_localItems()
+{
+  // pre-fill the item maps with all media types to be retrieved
+  for (const auto& mediaType : import.GetMediaTypes())
+    m_localItems.insert(std::make_pair(mediaType, std::vector<CFileItemPtr>()));
+}
+
+bool CMediaImportLocalItemsRetrievalTask::DoWork()
+{
+  PrepareProgressBarHandle(StringUtils::Format(g_localizeStrings.Get(39558).c_str(),
+                                               m_import.GetSource().GetFriendlyName().c_str()));
+
+  // first get a list of items previously imported from the media import
+  for (const auto& importHandler : m_importHandlers)
+  {
+    if (importHandler.second == nullptr)
+      continue;
+
+    std::vector<CFileItemPtr> localItems;
+    if (!importHandler.second->GetLocalItems(m_import, localItems))
+    {
+      m_logger->error("failed to get previously imported items of type {} from {}",
+                      importHandler.first, m_import);
+      return false;
+    }
+
+    m_localItems[importHandler.first] = localItems;
+  }
+
+  return true;
+}
diff --git a/xbmc/media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.h b/xbmc/media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.h
new file mode 100644
index 000000000000..61ba58fdf9ae
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportLocalItemsRetrievalTask.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/MediaType.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/MediaImportChangesetTypes.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+
+#include <map>
+
+class CMediaImportLocalItemsRetrievalTask : public IMediaImportTask
+{
+public:
+  CMediaImportLocalItemsRetrievalTask(const CMediaImport& import,
+                                      std::map<MediaType, MediaImportHandlerPtr> importHandlers);
+  virtual ~CMediaImportLocalItemsRetrievalTask() = default;
+
+  /*!
+   * \brief Get the media type of the media import
+   */
+  const GroupedMediaTypes& GetMediaTypes() const { return GetImport().GetMediaTypes(); }
+
+  /*!
+  * \brief Get a list of previously imported items
+  *
+  * \param mediaType media type of the previously imported items
+  * \return list of previously imported items
+  */
+  const std::vector<CFileItemPtr>& GetLocalItems(const MediaType& mediaType) const
+  {
+    return m_localItems.find(mediaType)->second;
+  }
+
+  // implementation of IMediaImportTask
+  MediaImportTaskType GetType() const override { return MediaImportTaskType::LocalItemsRetrieval; }
+  bool DoWork() override;
+
+protected:
+  std::map<MediaType, MediaImportHandlerPtr> m_importHandlers;
+  std::map<MediaType, std::vector<CFileItemPtr>> m_localItems;
+};
diff --git a/xbmc/media/import/jobs/tasks/MediaImportRemovalTask.cpp b/xbmc/media/import/jobs/tasks/MediaImportRemovalTask.cpp
new file mode 100644
index 000000000000..2f7aaa369160
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportRemovalTask.cpp
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportRemovalTask.h"
+
+#include "guilib/LocalizeStrings.h"
+#include "media/MediaType.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/MediaImportManager.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportRemovalTask::CMediaImportRemovalTask(const CMediaImport& import,
+                                                 MediaImportHandlerPtr importHandler)
+  : IMediaImportTask("CMediaImportRemovalTask", import), m_importHandler(importHandler)
+{
+}
+
+bool CMediaImportRemovalTask::DoWork()
+{
+  if (m_importHandler == nullptr)
+    return false;
+
+  // prepare the progress bar
+  PrepareProgressBarHandle(StringUtils::Format(
+      g_localizeStrings.Get(39566).c_str(), CMediaTypes::ToLabel(m_import.GetMediaTypes()).c_str(),
+      m_import.GetSource().GetFriendlyName().c_str()));
+  SetProgressText("");
+
+  m_logger->info("removing imported {} items from {}", m_importHandler->GetMediaType(),
+                 m_import.GetSource());
+
+  return m_importHandler->RemoveImportedItems(m_import);
+}
diff --git a/xbmc/media/import/jobs/tasks/MediaImportRemovalTask.h b/xbmc/media/import/jobs/tasks/MediaImportRemovalTask.h
new file mode 100644
index 000000000000..114e9149b483
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportRemovalTask.h
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+
+class CMediaImportRemovalTask : public IMediaImportTask
+{
+public:
+  CMediaImportRemovalTask(const CMediaImport& import, MediaImportHandlerPtr importHandler);
+  virtual ~CMediaImportRemovalTask() = default;
+
+  // implementation of IMediaImportTask
+  MediaImportTaskType GetType() const override { return MediaImportTaskType::Removal; }
+  bool DoWork() override;
+
+protected:
+  MediaImportHandlerPtr m_importHandler;
+};
diff --git a/xbmc/media/import/jobs/tasks/MediaImportSynchronisationTask.cpp b/xbmc/media/import/jobs/tasks/MediaImportSynchronisationTask.cpp
new file mode 100644
index 000000000000..5cbba2da85f7
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportSynchronisationTask.cpp
@@ -0,0 +1,108 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportSynchronisationTask.h"
+
+#include "guilib/LocalizeStrings.h"
+#include "media/MediaType.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/MediaImportManager.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportSynchronisationTask::CMediaImportSynchronisationTask(
+    const CMediaImport& import, MediaImportHandlerPtr importHandler, const ChangesetItems& items)
+  : IMediaImportTask("CMediaImportSynchronisationTask", import),
+    m_importHandler(importHandler),
+    m_items(items)
+{
+}
+
+bool CMediaImportSynchronisationTask::DoWork()
+{
+  if (m_importHandler == nullptr)
+    return false;
+
+  // nothing to do if there are no items to synchronise
+  if (m_items.empty())
+    return true;
+
+  if (!m_importHandler->StartSynchronisation(m_import))
+  {
+    m_logger->info("failed to initialize synchronisation of imported {} items from {}",
+                   m_importHandler->GetMediaType(), m_import.GetSource());
+    return false;
+  }
+
+  // prepare the progress bar
+  PrepareProgressBarHandle(StringUtils::Format(
+      g_localizeStrings.Get(39561).c_str(), CMediaTypes::ToLabel(m_import.GetMediaTypes()).c_str(),
+      m_import.GetSource().GetFriendlyName().c_str()));
+  SetProgressText("");
+
+  if (ShouldCancel(0, m_items.size()))
+    return false;
+
+  m_logger->info("handling {} imported {} items from {}", m_items.size(),
+                 m_importHandler->GetMediaType(), m_import.GetSource());
+  // handle the imported items of a specific media type
+  size_t total = m_items.size();
+  size_t progress = 0;
+  for (const auto& item : m_items)
+  {
+    // check if we should cancel
+    if (ShouldCancel(progress, total))
+      return false;
+
+    // get the item label to be used in the progress bar text
+    std::string itemLabel = m_importHandler->GetItemLabel(item.second.get());
+
+    // process the item depending on its changeset state
+    switch (item.first)
+    {
+      case MediaImportChangesetType::Added:
+        SetProgressText(
+            StringUtils::Format(g_localizeStrings.Get(39562).c_str(), itemLabel.c_str()));
+        m_importHandler->AddImportedItem(m_import, item.second.get());
+        break;
+
+      case MediaImportChangesetType::Changed:
+        SetProgressText(
+            StringUtils::Format(g_localizeStrings.Get(39563).c_str(), itemLabel.c_str()));
+        m_importHandler->UpdateImportedItem(m_import, item.second.get());
+        break;
+
+      case MediaImportChangesetType::Removed:
+        SetProgressText(
+            StringUtils::Format(g_localizeStrings.Get(39564).c_str(), itemLabel.c_str()));
+        m_importHandler->RemoveImportedItem(m_import, item.second.get());
+        break;
+
+      case MediaImportChangesetType::None:
+        break;
+
+      default:
+        m_logger->warn("ignoring imported item with unknown changeset type {}", item.first);
+        break;
+    }
+
+    ++progress;
+    SetProgress(progress, total);
+  }
+
+  if (!m_importHandler->FinishSynchronisation(m_import))
+  {
+    m_logger->info("failed to finalize synchronisation of imported {} items from {}",
+                   m_importHandler->GetMediaType(), m_import.GetSource());
+    return false;
+  }
+
+  return true;
+}
diff --git a/xbmc/media/import/jobs/tasks/MediaImportSynchronisationTask.h b/xbmc/media/import/jobs/tasks/MediaImportSynchronisationTask.h
new file mode 100644
index 000000000000..1483926e7e9d
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportSynchronisationTask.h
@@ -0,0 +1,36 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "FileItem.h"
+#include "media/import/IMediaImportHandler.h"
+#include "media/import/MediaImportChangesetTypes.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+
+class CMediaImportSynchronisationTask : public IMediaImportTask
+{
+public:
+  CMediaImportSynchronisationTask(const CMediaImport& import,
+                                  MediaImportHandlerPtr importHandler,
+                                  const ChangesetItems& items);
+  virtual ~CMediaImportSynchronisationTask() = default;
+
+  /*!
+  * \brief Get the media type being synchronised
+  */
+  MediaType GetMediaType() const { return m_importHandler->GetMediaType(); }
+
+  // implementation of IMediaImportTask
+  MediaImportTaskType GetType() const override { return MediaImportTaskType::Synchronisation; }
+  bool DoWork() override;
+
+protected:
+  MediaImportHandlerPtr m_importHandler;
+  ChangesetItems m_items;
+};
diff --git a/xbmc/media/import/jobs/tasks/MediaImportUpdateTask.cpp b/xbmc/media/import/jobs/tasks/MediaImportUpdateTask.cpp
new file mode 100644
index 000000000000..d5b855e431c8
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportUpdateTask.cpp
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportUpdateTask.h"
+
+#include "ServiceBroker.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/MediaImportManager.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CMediaImportUpdateTask::CMediaImportUpdateTask(const CMediaImport& import,
+                                               const CFileItem& item,
+                                               const IMediaImporterManager* importerManager)
+  : IMediaImportTask("CMediaImportUpdateTask", import),
+    m_importerManager(importerManager),
+    m_importer(),
+    m_item(item)
+{
+}
+
+bool CMediaImportUpdateTask::DoWork()
+{
+  if (m_importer == nullptr)
+  {
+    if (m_importerManager == nullptr)
+    {
+      m_logger->error("invalid media importer manager implementation");
+      return false;
+    }
+
+    // look for an importer than can handle the given path
+    m_importer = m_importerManager->GetImporterBySource(m_import.GetSource());
+    if (m_importer == nullptr)
+    {
+      m_logger->error("no importer capable of handling source {} found", m_import.GetSource());
+      return false;
+    }
+  }
+
+  return m_importer->UpdateOnSource(this);
+}
diff --git a/xbmc/media/import/jobs/tasks/MediaImportUpdateTask.h b/xbmc/media/import/jobs/tasks/MediaImportUpdateTask.h
new file mode 100644
index 000000000000..2adc80846096
--- /dev/null
+++ b/xbmc/media/import/jobs/tasks/MediaImportUpdateTask.h
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "FileItem.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+
+#include <memory>
+
+class IMediaImporter;
+
+class CMediaImportUpdateTask : public IMediaImportTask
+{
+public:
+  CMediaImportUpdateTask(const CMediaImport& import,
+                         const CFileItem& item,
+                         const IMediaImporterManager* importerManager);
+  virtual ~CMediaImportUpdateTask() = default;
+
+  /*!
+   * \brief Get the IMediaImporter instance used by the import job
+   */
+  const std::shared_ptr<IMediaImporter> GetImporter() const { return m_importer; }
+
+  const CFileItem& GetItem() const { return m_item; }
+
+  // implementation of IMediaImportTask
+  MediaImportTaskType GetType() const override { return MediaImportTaskType::Update; }
+  bool DoWork() override;
+
+protected:
+  const IMediaImporterManager* m_importerManager;
+  std::shared_ptr<IMediaImporter> m_importer;
+  CFileItem m_item;
+};
diff --git a/xbmc/utils/JobManager.h b/xbmc/utils/JobManager.h
index ac4aa4edc56a..9acd7eaf1bb8 100644
--- a/xbmc/utils/JobManager.h
+++ b/xbmc/utils/JobManager.h
@@ -60,7 +60,7 @@ class CLambdaJob : public CJob
 
  \sa CJob and IJobCallback
  */
-class CJobQueue: public IJobCallback
+class CJobQueue: public virtual IJobCallback
 {
   class CJobPointer
   {

From e645d66aa5ad9550e16ab1272866a9f22937c94d Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 18 Jun 2017 21:04:48 +0200
Subject: [PATCH 34/88] [utils] add CPerformanceMeasurement

---
 xbmc/utils/CMakeLists.txt           |  1 +
 xbmc/utils/PerformanceMeasurement.h | 78 +++++++++++++++++++++++++++++
 2 files changed, 79 insertions(+)
 create mode 100644 xbmc/utils/PerformanceMeasurement.h

diff --git a/xbmc/utils/CMakeLists.txt b/xbmc/utils/CMakeLists.txt
index 660f933a3e42..5df7721136ae 100644
--- a/xbmc/utils/CMakeLists.txt
+++ b/xbmc/utils/CMakeLists.txt
@@ -133,6 +133,7 @@ set(HEADERS ActorProtocol.h
             Mime.h
             Observer.h
             params_check_macros.h
+            PerformanceMeasurement.h
             POUtils.h
             ProgressJob.h
             RecentlyAddedJob.h
diff --git a/xbmc/utils/PerformanceMeasurement.h b/xbmc/utils/PerformanceMeasurement.h
new file mode 100644
index 000000000000..48746abc094f
--- /dev/null
+++ b/xbmc/utils/PerformanceMeasurement.h
@@ -0,0 +1,78 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <algorithm>
+#include <chrono>
+
+template<class TClock = std::chrono::high_resolution_clock>
+class CPerformanceMeasurement
+{
+public:
+  using Duration = typename TClock::duration;
+
+  CPerformanceMeasurement()
+  {
+    if (!m_initialized)
+    {
+      m_overhead = MeasureOverhead();
+      m_initialized = true;
+    }
+
+    Restart();
+  }
+
+  ~CPerformanceMeasurement() { Stop(); }
+
+  void Stop()
+  {
+    const auto now = TClock::now();
+    m_duration =
+        std::max(Duration(0), std::chrono::duration_cast<Duration>(now - m_start) - m_overhead);
+  }
+
+  void Restart() { m_start = TClock::now(); }
+
+  Duration GetDuration() const { return m_duration; }
+
+  double GetDurationInSeconds() const { return GetDurationInSeconds(m_duration); }
+
+private:
+  static double GetDurationInSeconds(const typename TClock::duration& duration)
+  {
+    return std::chrono::duration_cast<std::chrono::duration<double>>(duration).count();
+  }
+
+  Duration MeasureOverhead()
+  {
+    static constexpr size_t LoopCount = 1000;
+    const typename TClock::time_point overheadStart = TClock::now();
+    for (size_t i = 0; i < LoopCount; ++i)
+    {
+      Restart();
+      Stop();
+    }
+
+    const Duration overhead = std::chrono::duration_cast<Duration>(TClock::now() - overheadStart);
+    return overhead / LoopCount;
+  }
+
+  static Duration m_overhead;
+  static bool m_initialized;
+
+  typename TClock::time_point m_start;
+  Duration m_duration;
+};
+
+template<class TClock>
+typename CPerformanceMeasurement<TClock>::Duration CPerformanceMeasurement<TClock>::m_overhead =
+    typename CPerformanceMeasurement<TClock>::Duration(0);
+
+template<class TClock>
+bool CPerformanceMeasurement<TClock>::m_initialized = false;

From 9b30361b54e5aeed4896f67c7040c35408d01b88 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 18 Jun 2017 21:05:39 +0200
Subject: [PATCH 35/88] [media import] CMediaImportTaskProcessorJob: add
 performance measurements

---
 .../import/jobs/MediaImportTaskProcessorJob.cpp  | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/xbmc/media/import/jobs/MediaImportTaskProcessorJob.cpp b/xbmc/media/import/jobs/MediaImportTaskProcessorJob.cpp
index 18a7f5ddcef1..3c5056486a9b 100644
--- a/xbmc/media/import/jobs/MediaImportTaskProcessorJob.cpp
+++ b/xbmc/media/import/jobs/MediaImportTaskProcessorJob.cpp
@@ -24,6 +24,7 @@
 #include "media/import/jobs/tasks/MediaImportUpdateTask.h"
 #include "settings/Settings.h"
 #include "settings/SettingsComponent.h"
+#include "utils/PerformanceMeasurement.h"
 #include "utils/URIUtils.h"
 #include "utils/log.h"
 
@@ -415,14 +416,25 @@ bool CMediaImportTaskProcessorJob::ProcessTask(IMediaImportTask* task)
 
   SetTask(task);
 
+  const auto& import = task->GetImport();
+
+  s_logger->debug("processing {} task from {}...", MediaImportTaskTypes::ToString(task->GetType()),
+                  import);
+
+  // performance measurements
+  CPerformanceMeasurement<> perf;
+
   // let the current task do its work
-  CLog::Log(LOGDEBUG, "CMediaImportTaskProcessorJob: processing %s task",
-    MediaImportTaskTypes::ToString(task->GetType()).c_str());
   bool success = task->DoWork();
 
   // the task has been completed
   success &= OnTaskComplete(success, task);
 
+  perf.Stop();
+  s_logger->debug("processing {} task from {} took {} s",
+                  MediaImportTaskTypes::ToString(task->GetType()), import,
+                  perf.GetDurationInSeconds());
+
   ResetTask();
 
   return success;

From 1725a08e323e2369071b7a7b8086800d068ee523 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Wed, 1 Apr 2020 00:25:28 +0200
Subject: [PATCH 36/88] [guilib/guiinfo] add CMediaImportGUIInfo provider with
 ListItem.IsImported and ListItem.MediaImporter

---
 xbmc/GUIInfoManager.cpp                    |  18 ++++
 xbmc/guilib/guiinfo/CMakeLists.txt         |   2 +
 xbmc/guilib/guiinfo/GUIInfoLabels.h        |   2 +
 xbmc/guilib/guiinfo/GUIInfoProviders.cpp   |   2 +
 xbmc/guilib/guiinfo/GUIInfoProviders.h     |   2 +
 xbmc/guilib/guiinfo/MediaImportGUIInfo.cpp | 109 +++++++++++++++++++++
 xbmc/guilib/guiinfo/MediaImportGUIInfo.h   |  47 +++++++++
 7 files changed, 182 insertions(+)
 create mode 100644 xbmc/guilib/guiinfo/MediaImportGUIInfo.cpp
 create mode 100644 xbmc/guilib/guiinfo/MediaImportGUIInfo.h

diff --git a/xbmc/GUIInfoManager.cpp b/xbmc/GUIInfoManager.cpp
index 18676819285c..a6a8ce306c45 100644
--- a/xbmc/GUIInfoManager.cpp
+++ b/xbmc/GUIInfoManager.cpp
@@ -6474,6 +6474,22 @@ const infomap container_str[]  = {{ "property",         CONTAINER_PROPERTY },
 ///     @skinning_v19 **[New Infolabel]** \link ListItem_IsEnabled `ListItem.IsEnabled`\endlink
 ///     <p>
 ///   }
+///   \table_row3{   <b>`ListItem.IsImported`</b>,
+///                  \anchor ListItem_IsImported
+///                  _boolean_,
+///     @return **True** if the item has been imported from a media source.
+///     <p><hr>
+///     @skinning_v19 **[New Infolabel]** \link ListItem_IsImported `ListItem.IsImported`\endlink
+///     <p>
+///   }
+///   \table_row3{   <b>`ListItem.MediaImporter`</b>,
+///                  \anchor ListItem_MediaImporter
+///                  _string_,
+///     @return Identifier of the media importer which imported the item from a media source.
+///     <p><hr>
+///     @skinning_v19 **[New Infolabel]** \link ListItem_MediaImporter `ListItem.MediaImporter`\endlink
+///     <p>
+///   }
 /// \table_end
 ///
 /// -----------------------------------------------------------------------------
@@ -6683,6 +6699,8 @@ const infomap listitem_labels[]= {{ "thumb",            LISTITEM_THUMB },
                                   { "tvshowdbid",       LISTITEM_TVSHOWDBID },
                                   { "albumstatus",      LISTITEM_ALBUMSTATUS },
                                   { "isenabled",        LISTITEM_ISENABLED },
+                                  { "isimported",       LISTITEM_IS_IMPORTED },
+                                  { "mediaimporter",    LISTITEM_MEDIAIMPORTER },
 };
 
 /// \page modules__infolabels_boolean_conditions
diff --git a/xbmc/guilib/guiinfo/CMakeLists.txt b/xbmc/guilib/guiinfo/CMakeLists.txt
index 920351177450..4f47583af2f8 100644
--- a/xbmc/guilib/guiinfo/CMakeLists.txt
+++ b/xbmc/guilib/guiinfo/CMakeLists.txt
@@ -8,6 +8,7 @@ set(SOURCES GUIInfo.cpp
             GamesGUIInfo.cpp
             GUIControlsGUIInfo.cpp
             LibraryGUIInfo.cpp
+            MediaImportGUIInfo.cpp
             MusicGUIInfo.cpp
             PicturesGUIInfo.cpp
             PlayerGUIInfo.cpp
@@ -30,6 +31,7 @@ set(HEADERS GUIInfo.h
             GamesGUIInfo.h
             GUIControlsGUIInfo.h
             LibraryGUIInfo.h
+            MediaImportGUIInfo.h
             MusicGUIInfo.h
             PicturesGUIInfo.h
             PlayerGUIInfo.h
diff --git a/xbmc/guilib/guiinfo/GUIInfoLabels.h b/xbmc/guilib/guiinfo/GUIInfoLabels.h
index b2c14f7c08e4..ccac5bec8b91 100644
--- a/xbmc/guilib/guiinfo/GUIInfoLabels.h
+++ b/xbmc/guilib/guiinfo/GUIInfoLabels.h
@@ -922,6 +922,8 @@
 #define LISTITEM_TVSHOWDBID         (LISTITEM_START + 203)
 #define LISTITEM_ALBUMSTATUS        (LISTITEM_START + 204)
 #define LISTITEM_ISENABLED          (LISTITEM_START + 205)
+#define LISTITEM_IS_IMPORTED        (LISTITEM_START + 206)
+#define LISTITEM_MEDIAIMPORTER      (LISTITEM_START + 207)
 
 #define LISTITEM_END                (LISTITEM_START + 2500)
 
diff --git a/xbmc/guilib/guiinfo/GUIInfoProviders.cpp b/xbmc/guilib/guiinfo/GUIInfoProviders.cpp
index 5a57700a24a1..fd517637bc23 100644
--- a/xbmc/guilib/guiinfo/GUIInfoProviders.cpp
+++ b/xbmc/guilib/guiinfo/GUIInfoProviders.cpp
@@ -24,6 +24,7 @@ CGUIInfoProviders::CGUIInfoProviders()
   RegisterProvider(&m_picturesGUIInfo);
   RegisterProvider(&m_playerGUIInfo);
   RegisterProvider(&m_libraryGUIInfo);
+  RegisterProvider(&m_mediaImportGUIInfo);
   RegisterProvider(&m_addonsGUIInfo);
   RegisterProvider(&m_weatherGUIInfo);
   RegisterProvider(&m_gamesGUIInfo);
@@ -40,6 +41,7 @@ CGUIInfoProviders::~CGUIInfoProviders()
   UnregisterProvider(&m_gamesGUIInfo);
   UnregisterProvider(&m_weatherGUIInfo);
   UnregisterProvider(&m_addonsGUIInfo);
+  UnregisterProvider(&m_mediaImportGUIInfo);
   UnregisterProvider(&m_libraryGUIInfo);
   UnregisterProvider(&m_playerGUIInfo);
   UnregisterProvider(&m_picturesGUIInfo);
diff --git a/xbmc/guilib/guiinfo/GUIInfoProviders.h b/xbmc/guilib/guiinfo/GUIInfoProviders.h
index 1aed710d7107..3278381f5742 100644
--- a/xbmc/guilib/guiinfo/GUIInfoProviders.h
+++ b/xbmc/guilib/guiinfo/GUIInfoProviders.h
@@ -12,6 +12,7 @@
 #include "guilib/guiinfo/GUIControlsGUIInfo.h"
 #include "guilib/guiinfo/GamesGUIInfo.h"
 #include "guilib/guiinfo/LibraryGUIInfo.h"
+#include "guilib/guiinfo/MediaImportGUIInfo.h"
 #include "guilib/guiinfo/MusicGUIInfo.h"
 #include "guilib/guiinfo/PicturesGUIInfo.h"
 #include "guilib/guiinfo/PlayerGUIInfo.h"
@@ -142,6 +143,7 @@ class CGUIInfoProviders
   CGamesGUIInfo m_gamesGUIInfo;
   CGUIControlsGUIInfo m_guiControlsGUIInfo;
   CLibraryGUIInfo m_libraryGUIInfo;
+  CMediaImportGUIInfo m_mediaImportGUIInfo;
   CMusicGUIInfo m_musicGUIInfo;
   CPicturesGUIInfo m_picturesGUIInfo;
   CPlayerGUIInfo m_playerGUIInfo;
diff --git a/xbmc/guilib/guiinfo/MediaImportGUIInfo.cpp b/xbmc/guilib/guiinfo/MediaImportGUIInfo.cpp
new file mode 100644
index 000000000000..b4620d84b204
--- /dev/null
+++ b/xbmc/guilib/guiinfo/MediaImportGUIInfo.cpp
@@ -0,0 +1,109 @@
+/*
+ *  Copyright (C) 2020 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "guilib/guiinfo/MediaImportGUIInfo.h"
+
+#include "FileItem.h"
+#include "ServiceBroker.h"
+#include "guilib/guiinfo/GUIInfo.h"
+#include "guilib/guiinfo/GUIInfoLabels.h"
+#include "media/import/MediaImportManager.h"
+
+using namespace KODI::GUILIB;
+using namespace KODI::GUILIB::GUIINFO;
+
+bool CMediaImportGUIInfo::InitCurrentItem(CFileItem* item)
+{
+  /* TODO(Montellese)
+  if (item && item->IsVideo())
+  {
+    // special case where .strm is used to start an audio stream
+    if (item->IsInternetStream() && g_application.GetAppPlayer().IsPlayingAudio())
+      return false;
+
+    CLog::Log(LOGDEBUG,"CMediaImportGUIInfo::InitCurrentItem(%s)", CURL::GetRedacted(item->GetPath()).c_str());
+
+    // Find a thumb for this file.
+    if (!item->HasArt("thumb"))
+    {
+      CVideoThumbLoader loader;
+      loader.LoadItem(item);
+    }
+
+    // find a thumb for this stream
+    if (item->IsInternetStream())
+    {
+      if (!g_application.m_strPlayListFile.empty())
+      {
+        CLog::Log(LOGDEBUG,"Streaming media detected... using %s to find a thumb", g_application.m_strPlayListFile.c_str());
+        CFileItem thumbItem(g_application.m_strPlayListFile,false);
+
+        CVideoThumbLoader loader;
+        if (loader.FillThumb(thumbItem))
+          item->SetArt("thumb", thumbItem.GetArt("thumb"));
+      }
+    }
+    return true;
+  }
+  */
+  return false;
+}
+
+bool CMediaImportGUIInfo::GetLabel(std::string& value,
+                                   const CFileItem* item,
+                                   int contextWindow,
+                                   const CGUIInfo& info,
+                                   std::string* fallback) const
+{
+  switch (info.m_info)
+  {
+    case LISTITEM_MEDIAIMPORTER:
+    {
+      if (item->IsImported())
+      {
+        const auto& mediaImportManager = CServiceBroker::GetMediaImportManager();
+        CMediaImportSource source(item->GetSource());
+        if (!mediaImportManager.GetSource(source.GetIdentifier(), source))
+          return false;
+
+        value = source.GetImporterId();
+        return true;
+      }
+    }
+  }
+
+  return false;
+}
+
+bool CMediaImportGUIInfo::GetInt(int& value,
+                                 const CGUIListItem* gitem,
+                                 int contextWindow,
+                                 const CGUIInfo& info) const
+{
+  return false;
+}
+
+bool CMediaImportGUIInfo::GetBool(bool& value,
+                                  const CGUIListItem* gitem,
+                                  int contextWindow,
+                                  const CGUIInfo& info) const
+{
+  if (!gitem->IsFileItem())
+    return false;
+
+  const CFileItem* item = static_cast<const CFileItem*>(gitem);
+
+  switch (info.m_info)
+  {
+    case LISTITEM_IS_IMPORTED:
+      value = item->IsImported();
+      return true;
+  }
+
+  return false;
+}
diff --git a/xbmc/guilib/guiinfo/MediaImportGUIInfo.h b/xbmc/guilib/guiinfo/MediaImportGUIInfo.h
new file mode 100644
index 000000000000..59c7d37c746f
--- /dev/null
+++ b/xbmc/guilib/guiinfo/MediaImportGUIInfo.h
@@ -0,0 +1,47 @@
+/*
+ *  Copyright (C) 2020 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "guilib/guiinfo/GUIInfoProvider.h"
+
+namespace KODI
+{
+namespace GUILIB
+{
+namespace GUIINFO
+{
+
+class CGUIInfo;
+
+class CMediaImportGUIInfo : public CGUIInfoProvider
+{
+public:
+  CMediaImportGUIInfo() = default;
+  ~CMediaImportGUIInfo() override = default;
+
+  // KODI::GUILIB::GUIINFO::IGUIInfoProvider implementation
+  bool InitCurrentItem(CFileItem* item) override;
+  bool GetLabel(std::string& value,
+                const CFileItem* item,
+                int contextWindow,
+                const CGUIInfo& info,
+                std::string* fallback) const override;
+  bool GetInt(int& value,
+              const CGUIListItem* item,
+              int contextWindow,
+              const CGUIInfo& info) const override;
+  bool GetBool(bool& value,
+               const CGUIListItem* item,
+               int contextWindow,
+               const CGUIInfo& info) const override;
+};
+
+} // namespace GUIINFO
+} // namespace GUILIB
+} // namespace KODI

From 3f7911a97fe2233ec84408fce185c862cda0a86a Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Tue, 8 Apr 2014 23:44:28 +0200
Subject: [PATCH 37/88] [library] allow showing the info dialog for imported
 video items

---
 xbmc/video/windows/GUIWindowVideoBase.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/video/windows/GUIWindowVideoBase.cpp b/xbmc/video/windows/GUIWindowVideoBase.cpp
index 6664c735cc81..3e220d8de367 100644
--- a/xbmc/video/windows/GUIWindowVideoBase.cpp
+++ b/xbmc/video/windows/GUIWindowVideoBase.cpp
@@ -766,7 +766,8 @@ bool CGUIWindowVideoBase::OnItemInfo(int iItem)
     if (!scraper &&
         !(m_database.HasMovieInfo(item->GetPath()) ||
           m_database.HasTvShowInfo(strDir)           ||
-          m_database.HasEpisodeInfo(item->GetPath())))
+          m_database.HasEpisodeInfo(item->GetPath())) &&
+        !item->IsImported())
     {
       return false;
     }

From fdb1126e23e4136051d7ebbaf8b5e3e1ab56af95 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sat, 19 Apr 2014 01:48:01 +0200
Subject: [PATCH 38/88] [library] add dialog about unavailable media provider
 when trying to play an imported video item

---
 xbmc/video/windows/GUIWindowVideoNav.cpp | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/xbmc/video/windows/GUIWindowVideoNav.cpp b/xbmc/video/windows/GUIWindowVideoNav.cpp
index 555338b86676..808dcf6f657e 100644
--- a/xbmc/video/windows/GUIWindowVideoNav.cpp
+++ b/xbmc/video/windows/GUIWindowVideoNav.cpp
@@ -16,6 +16,7 @@
 #include "ServiceBroker.h"
 #include "Util.h"
 #include "dialogs/GUIDialogMediaSource.h"
+#include "dialogs/GUIDialogOK.h"
 #include "dialogs/GUIDialogYesNo.h"
 #include "filesystem/Directory.h"
 #include "filesystem/MultiPathDirectory.h"
@@ -44,6 +45,7 @@
 #include "video/VideoInfoScanner.h"
 #include "video/dialogs/GUIDialogVideoInfo.h"
 #include "view/GUIViewState.h"
+#include "media/import/MediaImportManager.h"
 
 #include <utility>
 
@@ -1115,7 +1117,17 @@ bool CGUIWindowVideoNav::OnAddMediaSource()
 bool CGUIWindowVideoNav::OnClick(int iItem, const std::string &player)
 {
   CFileItemPtr item = m_vecItems->Get(iItem);
-  if (!item->m_bIsFolder && item->IsVideoDb() && !item->Exists())
+  if (!item->m_bIsFolder && item->IsImported() && !CServiceBroker::GetMediaImportManager().IsSourceActive(item->GetSource()))
+  {
+    CMediaImportSource source(item->GetSource());
+    if (CServiceBroker::GetMediaImportManager().GetSource(source.GetIdentifier(), source))
+      KODI::MESSAGING::HELPERS::ShowOKDialogText("Media provider unavailable" /* TODO */, "The media provider " + source.GetFriendlyName() + " is currently not available." /* TODO */);
+    else
+      KODI::MESSAGING::HELPERS::ShowOKDialogText("Media provider unavailable" /* TODO */, "The media provider is currently not available." /* TODO */);
+
+    return true;
+  }
+  else if (!item->m_bIsFolder && item->IsVideoDb() && !item->Exists())
   {
     CLog::Log(LOGDEBUG, "%s called on '%s' but file doesn't exist", __FUNCTION__, item->GetPath().c_str());
 

From b38a621895097f422b641d5cd9b3a3ae3e0ddacd Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 17 Sep 2015 21:07:35 +0200
Subject: [PATCH 39/88] [library] don't show "Scan for new content" for
 imported tvshows

---
 xbmc/video/windows/GUIWindowVideoNav.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/video/windows/GUIWindowVideoNav.cpp b/xbmc/video/windows/GUIWindowVideoNav.cpp
index 808dcf6f657e..0a7feb9f7cf5 100644
--- a/xbmc/video/windows/GUIWindowVideoNav.cpp
+++ b/xbmc/video/windows/GUIWindowVideoNav.cpp
@@ -973,7 +973,7 @@ void CGUIWindowVideoNav::GetContextButtons(int itemNumber, CContextButtons &butt
         {
           buttons.Add(CONTEXT_BUTTON_EDIT, 16106);
         }
-        if (node == NODE_TYPE_TITLE_TVSHOWS)
+        if (node == NODE_TYPE_TITLE_TVSHOWS && !item->IsImported())
         {
           buttons.Add(CONTEXT_BUTTON_SCAN, 13349);
         }

From caa9e4267fe18d98f03298bb6f58acfa7f42791e Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 14 Jan 2020 23:44:07 +0100
Subject: [PATCH 40/88] [videodb] add LoadImportInfo() and overloaded version
 of LoadVideoInfo() taking a CFileItem instead of a CVideoInfoTag

---
 xbmc/video/VideoDatabase.cpp | 54 ++++++++++++++++++++++++++++++++++++
 xbmc/video/VideoDatabase.h   |  7 +++++
 2 files changed, 61 insertions(+)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 0f0954eedebb..dd91199d1f60 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -2115,6 +2115,21 @@ bool CVideoDatabase::LoadVideoInfo(const std::string& strFilenameAndPath, CVideo
   return false;
 }
 
+bool CVideoDatabase::LoadVideoInfo(const std::string& strFilenameAndPath, CFileItem& item, int getDetails /* = VideoDbDetailsAll */)
+{
+  if (!LoadVideoInfo(strFilenameAndPath, *item.GetVideoInfoTag(), getDetails))
+    return false;
+
+  // make sure the label is set
+  if (item.GetLabel().empty())
+    item.SetLabel(item.GetVideoInfoTag()->GetTitle());
+
+  // try to load media import details
+  LoadImportInfo(item);
+
+  return true;
+}
+
 bool CVideoDatabase::HasMovieInfo(const std::string& strFilenameAndPath)
 {
   try
@@ -10906,6 +10921,45 @@ int CVideoDatabase::AddImport(const CMediaImport &import)
   return -1;
 }
 
+bool CVideoDatabase::LoadImportInfo(CFileItem& item)
+{
+  if (!item.HasVideoInfoTag())
+    return false;
+
+  const auto details = item.GetVideoInfoTag();
+  if (details->m_iDbId < 0 || details->m_type.empty())
+    return false;
+
+  std::string strSQL;
+  try
+  {
+    if (m_pDB.get() == NULL || m_pDS.get() == NULL)
+      return false;
+
+    strSQL = PrepareSQL("SELECT source.identifier, path.strPath, import_link.enabled "
+                        "FROM import_link "
+                        "JOIN import ON import.import_id = import_link.import_id "
+                        "JOIN source ON source.source_id = import.source_id "
+                        "JOIN path ON path.idPath = import.idPath "
+                        "WHERE import_link.media_id = %d AND import_link.media_type = '%s'",
+      details->m_iDbId, details->m_type.c_str());
+    m_pDS->query(strSQL.c_str());
+    if (m_pDS->num_rows() == 1)
+    {
+      item.SetSource(m_pDS->fv(0).get_asString());
+      item.SetImportPath(m_pDS->fv(1).get_asString());
+      item.SetEnabled(m_pDS->fv(2).get_asBool());
+    }
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s(%d, %s) failed: %s", __FUNCTION__, details->m_iDbId, details->m_type.c_str(), strSQL.c_str());
+  }
+  return -1;
+}
+
 bool CVideoDatabase::SetDetailsForImport(const CMediaImport &import)
 {
   std::string strSQL;
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index b62a1fcaa65e..bed5867e056e 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -515,6 +515,7 @@ class CVideoDatabase : public CDatabase
   int GetSeasonForEpisode(int idEpisode);
 
   bool LoadVideoInfo(const std::string& strFilenameAndPath, CVideoInfoTag& details, int getDetails = VideoDbDetailsAll);
+  bool LoadVideoInfo(const std::string& strFilenameAndPath, CFileItem& item, int getDetails = VideoDbDetailsAll);
   bool GetMovieInfo(const std::string& strFilenameAndPath, CVideoInfoTag& details, int idMovie = -1, int getDetails = VideoDbDetailsAll);
   bool GetTvShowInfo(const std::string& strPath, CVideoInfoTag& details, int idTvShow = -1, CFileItem* item = NULL, int getDetails = VideoDbDetailsAll);
   bool GetSeasonInfo(int idSeason, CVideoInfoTag& details, bool allDetails = true);
@@ -845,6 +846,12 @@ class CVideoDatabase : public CDatabase
    */
   int AddImport(const CMediaImport &import);
 
+  /*! \brief Loads the import information of the given video item.
+   \param item Video item to store the import information in
+   \return true on success, false otherwise
+   */
+  bool LoadImportInfo(CFileItem& item);
+
   /*! \brief Updates the values of the given import.
    \param import Import with updated values
    \return True if the update was successful, false otherwise

From 72eb763d20349bba0c4ea589b20a5cb35c0e26eb Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 14 Jan 2020 23:44:40 +0100
Subject: [PATCH 41/88] use the new overload of CVideoDatabase::LoadVideoInfo()

This fixes the issue that the media import logic cannot update playback
related metadata of items played from a widget on its source because the
CFileItem is missing the information about media source and import.
---
 xbmc/Application.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 2a3a4eeef2db..3f9348416797 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2899,7 +2899,7 @@ bool CApplication::PlayFile(CFileItem item, const std::string& player, bool bRes
       std::string videoInfoTagPath(item.GetVideoInfoTag()->m_strFileNameAndPath);
       if (videoInfoTagPath.find("removable://") == 0)
         path = videoInfoTagPath;
-      dbs.LoadVideoInfo(path, *item.GetVideoInfoTag());
+      dbs.LoadVideoInfo(path, item);
 
       if (item.HasProperty("savedplayerstate"))
       {

From a5807779d45d8418e120d73bf03bf2c46573a004 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 6 Apr 2014 19:29:54 +0200
Subject: [PATCH 42/88] [library] forward updates to video
 playcount/lastplayed/resumepoint to CMediaImportManager

---
 xbmc/utils/SaveFileStateJob.cpp               | 11 ++++++++-
 .../video/jobs/VideoLibraryMarkWatchedJob.cpp | 24 +++++++++++++++++++
 .../jobs/VideoLibraryResetResumePointJob.cpp  | 11 +++++++++
 3 files changed, 45 insertions(+), 1 deletion(-)

diff --git a/xbmc/utils/SaveFileStateJob.cpp b/xbmc/utils/SaveFileStateJob.cpp
index 26b7b5c3173c..0f559bf2a6a9 100644
--- a/xbmc/utils/SaveFileStateJob.cpp
+++ b/xbmc/utils/SaveFileStateJob.cpp
@@ -21,6 +21,7 @@
 #include "guilib/GUIWindowManager.h"
 #include "interfaces/AnnouncementManager.h"
 #include "log.h"
+#include "media/import/MediaImportManager.h"
 #include "music/MusicDatabase.h"
 #include "music/tags/MusicInfoTag.h"
 #include "network/upnp/UPnP.h"
@@ -50,7 +51,8 @@ void CSaveFileState::DoWork(CFileItem& item,
   {
 #ifdef HAS_UPNP
     // checks if UPnP server of this file is available and supports updating
-    if (URIUtils::IsUPnP(progressTrackingFile)
+    if (!item.IsImported() &&
+        URIUtils::IsUPnP(progressTrackingFile)
         && UPNP::CUPnP::SaveFileState(item, bookmark, updatePlayCount))
     {
       return;
@@ -109,7 +111,11 @@ void CSaveFileState::DoWork(CFileItem& item,
             }
           }
           else
+          {
+            if (item.HasVideoInfoTag())
+              item.GetVideoInfoTag()->m_lastPlayed = CDateTime::GetCurrentDateTime();
             videodatabase.UpdateLastPlayed(item);
+          }
 
           if (!item.HasVideoInfoTag() ||
               item.GetVideoInfoTag()->GetResumePoint().timeInSeconds != bookmark.timeInSeconds)
@@ -207,5 +213,8 @@ void CSaveFileState::DoWork(CFileItem& item,
         musicdatabase.Close();
       }
     }
+
+    if (item.IsImported())
+      CServiceBroker::GetMediaImportManager().UpdateImportedItemOnSource(item);
   }
 }
diff --git a/xbmc/video/jobs/VideoLibraryMarkWatchedJob.cpp b/xbmc/video/jobs/VideoLibraryMarkWatchedJob.cpp
index a20837ac9906..fb6cd56b8d27 100644
--- a/xbmc/video/jobs/VideoLibraryMarkWatchedJob.cpp
+++ b/xbmc/video/jobs/VideoLibraryMarkWatchedJob.cpp
@@ -10,8 +10,10 @@
 
 #include "VideoLibraryMarkWatchedJob.h"
 #include "FileItem.h"
+#include "ServiceBroker.h"
 #include "Util.h"
 #include "filesystem/Directory.h"
+#include "media/import/MediaImportManager.h"
 #ifdef HAS_UPNP
 #include "network/upnp/UPnP.h"
 #endif
@@ -96,11 +98,33 @@ bool CVideoLibraryMarkWatchedJob::Work(CVideoDatabase &db)
 
     // With both mark as watched and unwatched we want the resume bookmarks to be reset
     db.ClearBookMarksOfFile(path, CBookmark::RESUME);
+    // update the item itself
+    if (item->HasVideoInfoTag())
+      item->GetVideoInfoTag()->GetResumePoint().Reset();
 
     if (m_mark)
+    {
+      db.IncrementPlayCount(*item);
+      // update the item's details in the database
+      db.ClearBookMarksOfFile(path, CBookmark::RESUME);
       db.IncrementPlayCount(*item);
+
+      // update the item itself
+      if (item->HasVideoInfoTag())
+        item->GetVideoInfoTag()->IncrementPlayCount();
+    }
     else
+    {
+      // update the item's details in the database
       db.SetPlayCount(*item, 0);
+
+      // update the item itself
+      if (item->HasVideoInfoTag())
+        item->GetVideoInfoTag()->SetPlayCount(0);
+    }
+
+    if (item->IsImported())
+      CServiceBroker::GetMediaImportManager().UpdateImportedItemOnSource(*item);
   }
 
   db.CommitTransaction();
diff --git a/xbmc/video/jobs/VideoLibraryResetResumePointJob.cpp b/xbmc/video/jobs/VideoLibraryResetResumePointJob.cpp
index d3dec075467c..5a6a93b35bd4 100644
--- a/xbmc/video/jobs/VideoLibraryResetResumePointJob.cpp
+++ b/xbmc/video/jobs/VideoLibraryResetResumePointJob.cpp
@@ -14,6 +14,7 @@
 #include "ServiceBroker.h"
 #include "Util.h"
 #include "filesystem/IDirectory.h"
+#include "media/import/MediaImportManager.h"
 #ifdef HAS_UPNP
 #include "network/upnp/UPnP.h"
 #endif
@@ -66,6 +67,16 @@ bool CVideoLibraryResetResumePointJob::Work(CVideoDatabase &db)
         CServiceBroker::GetPVRManager().Recordings()->ResetResumePoint(item->GetPVRRecordingInfoTag()))
       continue;
 
+    if (item->HasVideoInfoTag())
+    {
+      auto resumePoint = item->GetVideoInfoTag()->GetResumePoint();
+      resumePoint.timeInSeconds = 0.0;
+      item->GetVideoInfoTag()->SetResumePoint(std::move(resumePoint));
+    }
+
+    if (item->IsImported())
+      CServiceBroker::GetMediaImportManager().UpdateImportedItemOnSource(*item);
+
     resetItems.emplace_back(item);
   }
 

From 5e84a50d06a63acc51fa149c81847f210185cff1 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 15 Sep 2013 14:03:35 +0200
Subject: [PATCH 43/88] [media import] add IMediaImportHandler implementations
 for movies, sets, tvshows, seasons, episodes and musicvideos

squash! [media import] add IMediaImportHandler implementations for movies, tvshows, seasons, episodes and musicvideos
---
 .../resources/strings.po                      |   7 +-
 cmake/treedata/common/media.txt               |   1 +
 xbmc/media/import/MediaImportManager.cpp      |  12 +
 xbmc/media/import/handlers/CMakeLists.txt     |  17 +
 .../import/handlers/EpisodeImportHandler.cpp  | 238 +++++++++++
 .../import/handlers/EpisodeImportHandler.h    |  60 +++
 .../import/handlers/MovieImportHandler.cpp    |  79 ++++
 .../import/handlers/MovieImportHandler.h      |  44 ++
 .../import/handlers/MovieSetImportHandler.cpp | 123 ++++++
 .../import/handlers/MovieSetImportHandler.h   |  49 +++
 .../handlers/MusicVideoImportHandler.cpp      |  85 ++++
 .../import/handlers/MusicVideoImportHandler.h |  40 ++
 .../import/handlers/SeasonImportHandler.cpp   | 373 +++++++++++++++++
 .../import/handlers/SeasonImportHandler.h     |  66 +++
 .../import/handlers/TvShowImportHandler.cpp   | 292 +++++++++++++
 .../import/handlers/TvShowImportHandler.h     |  54 +++
 .../import/handlers/VideoImportHandler.cpp    | 392 ++++++++++++++++++
 .../import/handlers/VideoImportHandler.h      |  75 ++++
 18 files changed, 2006 insertions(+), 1 deletion(-)
 create mode 100644 xbmc/media/import/handlers/CMakeLists.txt
 create mode 100644 xbmc/media/import/handlers/EpisodeImportHandler.cpp
 create mode 100644 xbmc/media/import/handlers/EpisodeImportHandler.h
 create mode 100644 xbmc/media/import/handlers/MovieImportHandler.cpp
 create mode 100644 xbmc/media/import/handlers/MovieImportHandler.h
 create mode 100644 xbmc/media/import/handlers/MovieSetImportHandler.cpp
 create mode 100644 xbmc/media/import/handlers/MovieSetImportHandler.h
 create mode 100644 xbmc/media/import/handlers/MusicVideoImportHandler.cpp
 create mode 100644 xbmc/media/import/handlers/MusicVideoImportHandler.h
 create mode 100644 xbmc/media/import/handlers/SeasonImportHandler.cpp
 create mode 100644 xbmc/media/import/handlers/SeasonImportHandler.h
 create mode 100644 xbmc/media/import/handlers/TvShowImportHandler.cpp
 create mode 100644 xbmc/media/import/handlers/TvShowImportHandler.h
 create mode 100644 xbmc/media/import/handlers/VideoImportHandler.cpp
 create mode 100644 xbmc/media/import/handlers/VideoImportHandler.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 4fc5df140f43..a095ee32e581 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -22219,7 +22219,12 @@ msgctxt "#39564"
 msgid "Removing {:s}..."
 msgstr ""
 
-#empty string id 39565
+#. (container title): (media item title)
+#: xbmc/media/import/handler/EpisodeImportHandler.cpp
+#: xbmc/media/import/handler/SeasonImportHandler.cpp
+msgctxt "#39565"
+msgid "{:s}: {:s}"
+msgstr ""
 
 #. Removing import of (media type plural) from (media provider name)
 #: xbmc/media/import/task/MediaImportRemovalTask.cpp
diff --git a/cmake/treedata/common/media.txt b/cmake/treedata/common/media.txt
index 91b0885f4e5c..c7d66db44fd9 100644
--- a/cmake/treedata/common/media.txt
+++ b/cmake/treedata/common/media.txt
@@ -1,5 +1,6 @@
 xbmc/media                                      media
 xbmc/media/drm                                  drm
 xbmc/media/import                               media/import
+xbmc/media/import/handlers                      media/import/handlers
 xbmc/media/import/jobs                          media/import/jobs
 xbmc/media/import/jobs/tasks                    media/import/jobs/tasks
diff --git a/xbmc/media/import/MediaImportManager.cpp b/xbmc/media/import/MediaImportManager.cpp
index e6bc5ca11508..db8cdd1b7f53 100644
--- a/xbmc/media/import/MediaImportManager.cpp
+++ b/xbmc/media/import/MediaImportManager.cpp
@@ -21,6 +21,12 @@
 #include "media/import/IMediaImporter.h"
 #include "media/import/MediaImport.h"
 #include "media/import/MediaImportSource.h"
+#include "media/import/handlers/EpisodeImportHandler.h"
+#include "media/import/handlers/MovieImportHandler.h"
+#include "media/import/handlers/MovieSetImportHandler.h"
+#include "media/import/handlers/MusicVideoImportHandler.h"
+#include "media/import/handlers/SeasonImportHandler.h"
+#include "media/import/handlers/TvShowImportHandler.h"
 #include "media/import/jobs/MediaImportSourceActivationJob.h"
 #include "media/import/jobs/MediaImportSourceJobBase.h"
 #include "media/import/jobs/MediaImportSourceReadyJob.h"
@@ -64,6 +70,12 @@ void CMediaImportManager::Initialize()
     return;
 
   // register media handlers
+  RegisterMediaImportHandler(std::make_shared<CMovieImportHandler>(this));
+  RegisterMediaImportHandler(std::make_shared<CMovieSetImportHandler>(this));
+  RegisterMediaImportHandler(std::make_shared<CTvShowImportHandler>(this));
+  RegisterMediaImportHandler(std::make_shared<CSeasonImportHandler>(this));
+  RegisterMediaImportHandler(std::make_shared<CEpisodeImportHandler>(this));
+  RegisterMediaImportHandler(std::make_shared<CMusicVideoImportHandler>(this));
 
   // start all registered importers
   {
diff --git a/xbmc/media/import/handlers/CMakeLists.txt b/xbmc/media/import/handlers/CMakeLists.txt
new file mode 100644
index 000000000000..585dcec34354
--- /dev/null
+++ b/xbmc/media/import/handlers/CMakeLists.txt
@@ -0,0 +1,17 @@
+set(SOURCES EpisodeImportHandler.cpp
+            MovieImportHandler.cpp
+            MovieSetImportHandler.cpp
+            MusicVideoImportHandler.cpp
+            SeasonImportHandler.cpp
+            TvShowImportHandler.cpp
+            VideoImportHandler.cpp)
+
+set(HEADERS EpisodeImportHandler.h
+            MovieImportHandler.h
+            MovieSetImportHandler.h
+            MusicVideoImportHandler.h
+            SeasonImportHandler.h
+            TvShowImportHandler.h
+            VideoImportHandler.h)
+
+core_add_library(media_import_handlers)
diff --git a/xbmc/media/import/handlers/EpisodeImportHandler.cpp b/xbmc/media/import/handlers/EpisodeImportHandler.cpp
new file mode 100644
index 000000000000..ec48f6d51fa0
--- /dev/null
+++ b/xbmc/media/import/handlers/EpisodeImportHandler.cpp
@@ -0,0 +1,238 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "EpisodeImportHandler.h"
+
+#include "FileItem.h"
+#include "guilib/LocalizeStrings.h"
+#include "media/import/IMediaImportHandlerManager.h"
+#include "media/import/MediaImport.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+
+std::string CEpisodeImportHandler::GetItemLabel(const CFileItem* item) const
+{
+  if (item != nullptr && item->HasVideoInfoTag() &&
+      !item->GetVideoInfoTag()->m_strShowTitle.empty())
+  {
+    return StringUtils::Format(g_localizeStrings.Get(39565),
+                               item->GetVideoInfoTag()->m_strShowTitle,
+                               item->GetVideoInfoTag()->m_strTitle);
+  }
+
+  return CVideoImportHandler::GetItemLabel(item);
+}
+
+bool CEpisodeImportHandler::StartSynchronisation(const CMediaImport& import)
+{
+  if (!CVideoImportHandler::StartSynchronisation(import))
+    return false;
+
+  // create a map of tvshows imported from the same source
+  CFileItemList tvshows;
+  if (!m_db.GetTvShowsByWhere("videodb://tvshows/titles/?imported", CDatabase::Filter(), tvshows))
+    return false;
+
+  m_tvshows.clear();
+
+  TvShowsMap::iterator tvshowsIter;
+  for (int tvshowsIndex = 0; tvshowsIndex < tvshows.Size(); tvshowsIndex++)
+  {
+    CFileItemPtr tvshow = tvshows.Get(tvshowsIndex);
+    if (!tvshow->HasVideoInfoTag() || tvshow->GetVideoInfoTag()->m_strTitle.empty())
+      continue;
+
+    tvshowsIter = m_tvshows.find(tvshow->GetVideoInfoTag()->m_strTitle);
+    if (tvshowsIter == m_tvshows.end())
+    {
+      TvShowsSet tvshowsSet;
+      tvshowsSet.insert(tvshow);
+      m_tvshows.insert(make_pair(tvshow->GetVideoInfoTag()->m_strTitle, tvshowsSet));
+    }
+    else
+      tvshowsIter->second.insert(tvshow);
+  }
+
+  return true;
+}
+
+bool CEpisodeImportHandler::AddImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr)
+    return false;
+
+  PrepareItem(import, item);
+
+  CVideoInfoTag* episode = item->GetVideoInfoTag();
+
+  // try to find an existing tvshow that the episode belongs to
+  episode->m_iIdShow = FindTvShowId(item);
+
+  // if the tvshow doesn't exist, create a very basic version of it with the info we got from the episode
+  if (episode->m_iIdShow <= 0)
+  {
+    CVideoInfoTag tvshow;
+    tvshow.m_basePath = episode->m_basePath;
+    tvshow.m_cast = episode->m_cast;
+    tvshow.m_country = episode->m_country;
+    tvshow.m_director = episode->m_director;
+    tvshow.m_genre = episode->m_genre;
+    tvshow.SetYear(episode->GetYear());
+    tvshow.m_parentPathID = episode->m_parentPathID;
+    tvshow.m_premiered = episode->m_premiered;
+    tvshow.m_strMPAARating = episode->m_strMPAARating;
+    tvshow.m_strTitle = tvshow.m_strShowTitle = episode->m_strShowTitle;
+    tvshow.m_studio = episode->m_studio;
+    tvshow.m_type = MediaTypeTvShow;
+    tvshow.m_writingCredits = episode->m_writingCredits;
+
+    // try to find a proper path by going up in the path hierarchy twice
+    // (once for season and once for tvshow)
+    std::string showPath, testPath;
+    showPath = tvshow.m_basePath;
+    testPath = URIUtils::GetParentPath(episode->GetPath());
+    if (testPath != tvshow.m_basePath)
+    {
+      showPath = testPath;
+      testPath = URIUtils::GetParentPath(showPath);
+      if (testPath != tvshow.m_basePath)
+        showPath = testPath;
+    }
+    tvshow.m_strPath = showPath;
+
+    CFileItemPtr tvshowItem(new CFileItem(tvshow));
+    tvshowItem->SetPath(tvshow.m_strPath);
+    tvshowItem->SetSource(item->GetSource());
+    tvshowItem->SetImportPath(item->GetImportPath());
+
+    // try to use a tvshow-specific import handler
+    bool tvshowImported = false;
+    if (m_importHandlerManager != nullptr)
+    {
+      MediaImportHandlerConstPtr tvshowHandlerCreator =
+          m_importHandlerManager->GetImportHandler(MediaTypeTvShow);
+      if (tvshowHandlerCreator != nullptr)
+      {
+        MediaImportHandlerPtr tvshowHandler(tvshowHandlerCreator->Create());
+        tvshowImported = tvshowHandler->AddImportedItem(import, tvshowItem.get());
+      }
+    }
+
+    // fall back to direct database access
+    if (!tvshowImported)
+    {
+      std::vector<std::pair<std::string, std::string>> tvshowPaths;
+      tvshowPaths.push_back(std::make_pair(tvshow.m_strPath, tvshow.m_basePath));
+      tvshow.m_iDbId = tvshow.m_iIdShow =
+          m_db.SetDetailsForTvShow(tvshowPaths, tvshow, CGUIListItem::ArtMap(),
+                                   std::map<int, std::map<std::string, std::string>>());
+    }
+
+    // store the tvshow's database ID in the episode
+    episode->m_iIdShow = tvshow.m_iDbId;
+
+    // add the tvshow to the tvshow map
+    auto&& tvshowsIter = m_tvshows.find(tvshow.m_strTitle);
+    if (tvshowsIter == m_tvshows.end())
+    {
+      TvShowsSet tvshowsSet;
+      tvshowsSet.insert(tvshowItem);
+      m_tvshows.insert(make_pair(tvshow.m_strTitle, tvshowsSet));
+    }
+    else
+      tvshowsIter->second.insert(tvshowItem);
+  }
+
+  episode->m_iDbId =
+      m_db.SetDetailsForEpisode(item->GetPath(), *episode, item->GetArt(), episode->m_iIdShow);
+  if (episode->m_iDbId <= 0)
+    return false;
+
+  SetDetailsForFile(item, false);
+  return SetImportForItem(item, import);
+}
+
+bool CEpisodeImportHandler::UpdateImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag() || item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  if (m_db.SetDetailsForEpisode(item->GetPath(), *(item->GetVideoInfoTag()), item->GetArt(),
+                                item->GetVideoInfoTag()->m_iIdShow,
+                                item->GetVideoInfoTag()->m_iDbId) <= 0)
+    return false;
+
+  if (import.Settings()->UpdatePlaybackMetadataFromSource())
+    SetDetailsForFile(item, true);
+
+  return true;
+}
+
+bool CEpisodeImportHandler::RemoveImportedItem(const CMediaImport& import, const CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return false;
+
+  m_db.DeleteEpisode(item->GetVideoInfoTag()->m_iDbId);
+  RemoveFile(m_db, item);
+
+  return true;
+}
+
+bool CEpisodeImportHandler::GetLocalItems(CVideoDatabase& videodb,
+                                          const CMediaImport& import,
+                                          std::vector<CFileItemPtr>& items) const
+{
+  CFileItemList episodes;
+  if (!videodb.GetEpisodesByWhere(
+          "videodb://tvshows/titles/-1/-1/?imported&import=" + CURL::Encode(import.GetPath()),
+          CDatabase::Filter(), episodes, false, SortDescription(),
+          import.Settings()->UpdateImportedMediaItems() ? VideoDbDetailsAll : VideoDbDetailsNone))
+    return false;
+
+  items.insert(items.begin(), episodes.cbegin(), episodes.cend());
+
+  return true;
+}
+
+std::set<Field> CEpisodeImportHandler::IgnoreDifferences() const
+{
+  return {FieldActor,        FieldAlbum,       FieldArtist, FieldCountry,     FieldGenre,
+          FieldMPAA,         FieldPlotOutline, FieldSet,    FieldSortTitle,   FieldStudio,
+          FieldTag,          FieldTagline,     FieldTop250, FieldTrackNumber, FieldTrailer,
+          FieldTvShowStatus, FieldTvShowTitle};
+}
+
+int CEpisodeImportHandler::FindTvShowId(const CFileItem* episodeItem)
+{
+  if (episodeItem == nullptr || !episodeItem->HasVideoInfoTag())
+    return -1;
+
+  // no comparison possible without a title
+  if (episodeItem->GetVideoInfoTag()->m_strShowTitle.empty())
+    return -1;
+
+  // check if there is a tvshow with a matching title
+  const auto& tvshowsIter = m_tvshows.find(episodeItem->GetVideoInfoTag()->m_strShowTitle);
+  if (tvshowsIter == m_tvshows.end() || tvshowsIter->second.size() <= 0)
+    return -1;
+
+  // if there is only one matching tvshow, we can go with that one
+  if (tvshowsIter->second.size() == 1)
+    return tvshowsIter->second.begin()->get()->GetVideoInfoTag()->m_iDbId;
+
+  // use the path of the episode and tvshow to find the right tvshow
+  for (const auto& it : tvshowsIter->second)
+  {
+    if (URIUtils::PathHasParent(episodeItem->GetVideoInfoTag()->GetPath(),
+                                it->GetVideoInfoTag()->GetPath()))
+      return it->GetVideoInfoTag()->m_iDbId;
+  }
+
+  return -1;
+}
diff --git a/xbmc/media/import/handlers/EpisodeImportHandler.h b/xbmc/media/import/handlers/EpisodeImportHandler.h
new file mode 100644
index 000000000000..21b133658416
--- /dev/null
+++ b/xbmc/media/import/handlers/EpisodeImportHandler.h
@@ -0,0 +1,60 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/handlers/VideoImportHandler.h"
+
+#include <map>
+#include <set>
+#include <string>
+
+class CEpisodeImportHandler : public CVideoImportHandler
+{
+public:
+  CEpisodeImportHandler(const IMediaImportHandlerManager* importHandlerManager)
+    : CVideoImportHandler(importHandlerManager)
+  {
+  }
+  virtual ~CEpisodeImportHandler() = default;
+
+  CEpisodeImportHandler* Create() const override
+  {
+    return new CEpisodeImportHandler(m_importHandlerManager);
+  }
+
+  MediaType GetMediaType() const override { return MediaTypeEpisode; }
+  GroupedMediaTypes GetGroupedMediaTypes() const override
+  {
+    return {MediaTypeTvShow, MediaTypeSeason, MediaTypeEpisode};
+  }
+
+  std::string GetItemLabel(const CFileItem* item) const override;
+
+  bool StartSynchronisation(const CMediaImport& import) override;
+
+  bool AddImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool UpdateImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool RemoveImportedItem(const CMediaImport& import, const CFileItem* item) override;
+  bool CleanupImportedItems(const CMediaImport& import) override { return true; }
+
+protected:
+  bool GetLocalItems(CVideoDatabase& videodb,
+                     const CMediaImport& import,
+                     std::vector<CFileItemPtr>& items) const override;
+
+  std::set<Field> IgnoreDifferences() const override;
+
+private:
+  int FindTvShowId(const CFileItem* episodeItem);
+
+  typedef std::set<CFileItemPtr> TvShowsSet;
+  typedef std::map<std::string, TvShowsSet> TvShowsMap;
+
+  TvShowsMap m_tvshows;
+};
diff --git a/xbmc/media/import/handlers/MovieImportHandler.cpp b/xbmc/media/import/handlers/MovieImportHandler.cpp
new file mode 100644
index 000000000000..401cf7534779
--- /dev/null
+++ b/xbmc/media/import/handlers/MovieImportHandler.cpp
@@ -0,0 +1,79 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MovieImportHandler.h"
+
+#include "FileItem.h"
+#include "media/import/MediaImport.h"
+#include "video/VideoDatabase.h"
+
+bool CMovieImportHandler::AddImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr)
+    return false;
+
+  PrepareItem(import, item);
+
+  item->GetVideoInfoTag()->m_iDbId =
+      m_db.SetDetailsForMovie(item->GetPath(), *(item->GetVideoInfoTag()), item->GetArt());
+  if (item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  SetDetailsForFile(item, false);
+  return SetImportForItem(item, import);
+}
+
+bool CMovieImportHandler::UpdateImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag() || item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  if (m_db.SetDetailsForMovie(item->GetPath(), *(item->GetVideoInfoTag()), item->GetArt(),
+                              item->GetVideoInfoTag()->m_iDbId) <= 0)
+    return false;
+
+  if (import.Settings()->UpdatePlaybackMetadataFromSource())
+    SetDetailsForFile(item, true);
+
+  return true;
+}
+
+bool CMovieImportHandler::RemoveImportedItem(const CMediaImport& import, const CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return false;
+
+  m_db.DeleteMovie(item->GetVideoInfoTag()->m_iDbId);
+  RemoveFile(m_db, item);
+
+  return true;
+}
+
+bool CMovieImportHandler::GetLocalItems(CVideoDatabase& videodb,
+                                        const CMediaImport& import,
+                                        std::vector<CFileItemPtr>& items) const
+{
+  CFileItemList movies;
+  if (!videodb.GetMoviesByWhere(
+          "videodb://movies/titles/?imported&import=" + CURL::Encode(import.GetPath()),
+          CDatabase::Filter(), movies, SortDescription(),
+          import.Settings()->UpdateImportedMediaItems() ? VideoDbDetailsAll : VideoDbDetailsNone))
+    return false;
+
+  items.insert(items.begin(), movies.cbegin(), movies.cend());
+
+  return true;
+}
+
+std::set<Field> CMovieImportHandler::IgnoreDifferences() const
+{
+  return {
+      FieldAlbum,          FieldArtist,     FieldEpisodeNumber,     FieldEpisodeNumberSpecialSort,
+      FieldProductionCode, FieldSeason,     FieldSeasonSpecialSort, FieldTrackNumber,
+      FieldTvShowStatus,   FieldTvShowTitle};
+}
diff --git a/xbmc/media/import/handlers/MovieImportHandler.h b/xbmc/media/import/handlers/MovieImportHandler.h
new file mode 100644
index 000000000000..97e811048eb6
--- /dev/null
+++ b/xbmc/media/import/handlers/MovieImportHandler.h
@@ -0,0 +1,44 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/handlers/VideoImportHandler.h"
+
+class CMovieImportHandler : public CVideoImportHandler
+{
+public:
+  CMovieImportHandler(const IMediaImportHandlerManager* importHandlerManager)
+    : CVideoImportHandler(importHandlerManager)
+  {
+  }
+  virtual ~CMovieImportHandler() = default;
+
+  CMovieImportHandler* Create() const override
+  {
+    return new CMovieImportHandler(m_importHandlerManager);
+  }
+
+  MediaType GetMediaType() const override { return MediaTypeMovie; }
+  GroupedMediaTypes GetGroupedMediaTypes() const override
+  {
+    return {MediaTypeMovie, MediaTypeVideoCollection};
+  }
+
+  bool AddImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool UpdateImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool RemoveImportedItem(const CMediaImport& import, const CFileItem* item) override;
+  bool CleanupImportedItems(const CMediaImport& import) override { return true; }
+
+protected:
+  bool GetLocalItems(CVideoDatabase& videodb,
+                     const CMediaImport& import,
+                     std::vector<CFileItemPtr>& items) const override;
+
+  std::set<Field> IgnoreDifferences() const override;
+};
diff --git a/xbmc/media/import/handlers/MovieSetImportHandler.cpp b/xbmc/media/import/handlers/MovieSetImportHandler.cpp
new file mode 100644
index 000000000000..864c2aab9cb4
--- /dev/null
+++ b/xbmc/media/import/handlers/MovieSetImportHandler.cpp
@@ -0,0 +1,123 @@
+/*MovieSetImportHandler
+ *  Copyright (C) 2020 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MovieSetImportHandler.h"
+
+#include "FileItem.h"
+#include "media/import/MediaImport.h"
+#include "video/VideoDatabase.h"
+
+CFileItemPtr CMovieSetImportHandler::FindMatchingLocalItem(
+    const CMediaImport& import,
+    const CFileItem* item,
+    const std::vector<CFileItemPtr>& localItems) const
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return nullptr;
+
+  const auto& localItem =
+      std::find_if(localItems.cbegin(), localItems.cend(), [&item](const CFileItemPtr& localItem) {
+        return item->GetVideoInfoTag()->m_strTitle == localItem->GetVideoInfoTag()->m_strTitle;
+      });
+
+  if (localItem != localItems.cend())
+    return *localItem;
+
+  return nullptr;
+}
+
+bool CMovieSetImportHandler::AddImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr)
+    return false;
+
+  PrepareItem(import, item);
+
+  item->GetVideoInfoTag()->m_iDbId =
+      m_db.SetDetailsForMovieSet(*(item->GetVideoInfoTag()), item->GetArt());
+  if (item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  return SetImportForItem(item, import);
+}
+
+bool CMovieSetImportHandler::UpdateImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag() || item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  if (m_db.SetDetailsForMovieSet(*(item->GetVideoInfoTag()), item->GetArt(),
+                                 item->GetVideoInfoTag()->m_iDbId) <= 0)
+    return false;
+
+  return true;
+}
+
+bool CMovieSetImportHandler::RemoveImportedItem(const CMediaImport& import, const CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return false;
+
+  m_db.DeleteSet(item->GetVideoInfoTag()->m_iDbId);
+
+  return true;
+}
+
+bool CMovieSetImportHandler::GetLocalItems(CVideoDatabase& videodb,
+                                           const CMediaImport& import,
+                                           std::vector<CFileItemPtr>& items) const
+{
+  CFileItemList movieSets;
+  if (!videodb.GetSetsByWhere("videodb://movies/sets/?imported&import=" +
+                                  CURL::Encode(import.GetPath()),
+                              CDatabase::Filter(), movieSets, false))
+    return false;
+
+  items.insert(items.begin(), movieSets.cbegin(), movieSets.cend());
+
+  return true;
+}
+
+std::set<Field> CMovieSetImportHandler::IgnoreDifferences() const
+{
+  return {FieldActor,
+          FieldAirDate,
+          FieldAlbum,
+          FieldArtist,
+          FieldCountry,
+          FieldDirector,
+          FieldEpisodeNumber,
+          FieldEpisodeNumberSpecialSort,
+          FieldFilename,
+          FieldGenre,
+          FieldInProgress,
+          FieldLastPlayed,
+          FieldMPAA,
+          FieldOriginalTitle,
+          FieldPath,
+          FieldPlaycount,
+          FieldPlotOutline,
+          FieldProductionCode,
+          FieldRating,
+          FieldSeason,
+          FieldSeasonSpecialSort,
+          FieldSet,
+          FieldSortTitle,
+          FieldStudio,
+          FieldTag,
+          FieldTagline,
+          FieldTime,
+          FieldTop250,
+          FieldTrackNumber,
+          FieldTrailer,
+          FieldTvShowStatus,
+          FieldTvShowTitle,
+          FieldUniqueId,
+          FieldUserRating,
+          FieldWriter};
+}
diff --git a/xbmc/media/import/handlers/MovieSetImportHandler.h b/xbmc/media/import/handlers/MovieSetImportHandler.h
new file mode 100644
index 000000000000..141f88ba2430
--- /dev/null
+++ b/xbmc/media/import/handlers/MovieSetImportHandler.h
@@ -0,0 +1,49 @@
+/*
+ *  Copyright (C) 2020 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/handlers/VideoImportHandler.h"
+
+class CMovieSetImportHandler : public CVideoImportHandler
+{
+public:
+  CMovieSetImportHandler(const IMediaImportHandlerManager* importHandlerManager)
+    : CVideoImportHandler(importHandlerManager)
+  {
+  }
+  virtual ~CMovieSetImportHandler() = default;
+
+  CMovieSetImportHandler* Create() const override
+  {
+    return new CMovieSetImportHandler(m_importHandlerManager);
+  }
+
+  MediaType GetMediaType() const override { return MediaTypeVideoCollection; }
+  MediaTypes GetRequiredMediaTypes() const override { return {MediaTypeMovie}; }
+  GroupedMediaTypes GetGroupedMediaTypes() const override
+  {
+    return {MediaTypeMovie, MediaTypeVideoCollection};
+  }
+
+  CFileItemPtr FindMatchingLocalItem(const CMediaImport& import,
+                                     const CFileItem* item,
+                                     const std::vector<CFileItemPtr>& localItems) const override;
+
+  bool AddImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool UpdateImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool RemoveImportedItem(const CMediaImport& import, const CFileItem* item) override;
+  bool CleanupImportedItems(const CMediaImport& import) override { return true; }
+
+protected:
+  bool GetLocalItems(CVideoDatabase& videodb,
+                     const CMediaImport& import,
+                     std::vector<CFileItemPtr>& items) const override;
+
+  std::set<Field> IgnoreDifferences() const override;
+};
diff --git a/xbmc/media/import/handlers/MusicVideoImportHandler.cpp b/xbmc/media/import/handlers/MusicVideoImportHandler.cpp
new file mode 100644
index 000000000000..e48cb9b49339
--- /dev/null
+++ b/xbmc/media/import/handlers/MusicVideoImportHandler.cpp
@@ -0,0 +1,85 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MusicVideoImportHandler.h"
+
+#include "FileItem.h"
+#include "media/import/MediaImport.h"
+#include "video/VideoDatabase.h"
+
+bool CMusicVideoImportHandler::AddImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr)
+    return false;
+
+  PrepareItem(import, item);
+
+  item->GetVideoInfoTag()->m_iDbId =
+      m_db.SetDetailsForMusicVideo(item->GetPath(), *(item->GetVideoInfoTag()), item->GetArt());
+  if (item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  SetDetailsForFile(item, false);
+  return SetImportForItem(item, import);
+}
+
+bool CMusicVideoImportHandler::UpdateImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag() || item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  if (m_db.SetDetailsForMusicVideo(item->GetPath(), *(item->GetVideoInfoTag()), item->GetArt(),
+                                   item->GetVideoInfoTag()->m_iDbId) <= 0)
+    return false;
+
+  if (import.Settings()->UpdatePlaybackMetadataFromSource())
+    SetDetailsForFile(item, true);
+
+  return true;
+}
+
+bool CMusicVideoImportHandler::RemoveImportedItem(const CMediaImport& import, const CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return false;
+
+  m_db.DeleteMusicVideo(item->GetVideoInfoTag()->m_iDbId);
+  RemoveFile(m_db, item);
+
+  return true;
+}
+
+bool CMusicVideoImportHandler::GetLocalItems(CVideoDatabase& videodb,
+                                             const CMediaImport& import,
+                                             std::vector<CFileItemPtr>& items) const
+{
+  CFileItemList musicvideos;
+  if (!videodb.GetMusicVideosByWhere(
+          "videodb://musicvideos/titles/?imported&import=" + CURL::Encode(import.GetPath()),
+          CDatabase::Filter(), musicvideos, true, SortDescription(),
+          import.Settings()->UpdateImportedMediaItems() ? VideoDbDetailsAll : VideoDbDetailsNone))
+    return false;
+
+  items.insert(items.begin(), musicvideos.cbegin(), musicvideos.cend());
+
+  return true;
+}
+
+std::set<Field> CMusicVideoImportHandler::IgnoreDifferences() const
+{
+  return {FieldActor,         FieldCountry,
+          FieldEpisodeNumber, FieldEpisodeNumberSpecialSort,
+          FieldMPAA,          FieldOriginalTitle,
+          FieldPlotOutline,   FieldProductionCode,
+          FieldSeason,        FieldSeasonSpecialSort,
+          FieldSet,           FieldSortTitle,
+          FieldTagline,       FieldTop250,
+          FieldTrackNumber,   FieldTrailer,
+          FieldTvShowStatus,  FieldTvShowTitle,
+          FieldWriter};
+}
diff --git a/xbmc/media/import/handlers/MusicVideoImportHandler.h b/xbmc/media/import/handlers/MusicVideoImportHandler.h
new file mode 100644
index 000000000000..d31985dd8347
--- /dev/null
+++ b/xbmc/media/import/handlers/MusicVideoImportHandler.h
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/handlers/VideoImportHandler.h"
+
+class CMusicVideoImportHandler : public CVideoImportHandler
+{
+public:
+  CMusicVideoImportHandler(const IMediaImportHandlerManager* importHandlerManager)
+    : CVideoImportHandler(importHandlerManager)
+  {
+  }
+  virtual ~CMusicVideoImportHandler() = default;
+
+  CMusicVideoImportHandler* Create() const override
+  {
+    return new CMusicVideoImportHandler(m_importHandlerManager);
+  }
+
+  MediaType GetMediaType() const override { return MediaTypeMusicVideo; }
+
+  bool AddImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool UpdateImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool RemoveImportedItem(const CMediaImport& import, const CFileItem* item) override;
+  bool CleanupImportedItems(const CMediaImport& import) override { return true; }
+
+protected:
+  virtual bool GetLocalItems(CVideoDatabase& videodb,
+                             const CMediaImport& import,
+                             std::vector<CFileItemPtr>& items) const override;
+
+  virtual std::set<Field> IgnoreDifferences() const override;
+};
diff --git a/xbmc/media/import/handlers/SeasonImportHandler.cpp b/xbmc/media/import/handlers/SeasonImportHandler.cpp
new file mode 100644
index 000000000000..94666cef7f24
--- /dev/null
+++ b/xbmc/media/import/handlers/SeasonImportHandler.cpp
@@ -0,0 +1,373 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "SeasonImportHandler.h"
+
+#include "FileItem.h"
+#include "guilib/LocalizeStrings.h"
+#include "media/import/IMediaImportHandlerManager.h"
+#include "media/import/MediaImport.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "video/VideoDatabase.h"
+
+#include <algorithm>
+
+typedef std::set<CFileItemPtr> TvShowsSet;
+typedef std::map<std::string, TvShowsSet> TvShowsMap;
+
+/*!
+ * Checks whether two seasons are the same by comparing them by title and year
+ */
+static bool IsSameSeason(const CVideoInfoTag& left, const CVideoInfoTag& right)
+{
+  return left.m_strShowTitle == right.m_strShowTitle &&
+         (!left.HasYear() || !right.HasYear() || left.GetYear() == right.GetYear()) &&
+         left.m_iSeason == right.m_iSeason;
+}
+
+std::string CSeasonImportHandler::GetItemLabel(const CFileItem* item) const
+{
+  if (item != nullptr && item->HasVideoInfoTag() &&
+      !item->GetVideoInfoTag()->m_strShowTitle.empty())
+  {
+    return StringUtils::Format(g_localizeStrings.Get(39565),
+                               item->GetVideoInfoTag()->m_strShowTitle,
+                               item->GetVideoInfoTag()->m_strTitle);
+  }
+
+  return CVideoImportHandler::GetItemLabel(item);
+}
+
+CFileItemPtr CSeasonImportHandler::FindMatchingLocalItem(
+    const CMediaImport& import,
+    const CFileItem* item,
+    const std::vector<CFileItemPtr>& localItems) const
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return nullptr;
+
+  const auto& localItem =
+      std::find_if(localItems.cbegin(), localItems.cend(), [&item](const CFileItemPtr& localItem) {
+        return IsSameSeason(*item->GetVideoInfoTag(), *localItem->GetVideoInfoTag());
+      });
+
+  if (localItem != localItems.cend())
+    return *localItem;
+
+  return nullptr;
+}
+
+bool CSeasonImportHandler::StartSynchronisation(const CMediaImport& import)
+{
+  if (!CVideoImportHandler::StartSynchronisation(import))
+    return false;
+
+  // create a map of tvshows imported from the same source
+  CFileItemList tvshows;
+  if (!m_db.GetTvShowsByWhere("videodb://tvshows/titles/?imported", CDatabase::Filter(), tvshows))
+    return false;
+
+  m_tvshows.clear();
+
+  TvShowsMap::iterator tvshowsIter;
+  for (int tvshowsIndex = 0; tvshowsIndex < tvshows.Size(); tvshowsIndex++)
+  {
+    CFileItemPtr tvshow = tvshows.Get(tvshowsIndex);
+    if (!tvshow->HasVideoInfoTag() || tvshow->GetVideoInfoTag()->m_strTitle.empty())
+      continue;
+
+    tvshowsIter = m_tvshows.find(tvshow->GetVideoInfoTag()->m_strTitle);
+    if (tvshowsIter == m_tvshows.end())
+    {
+      TvShowsSet tvshowsSet;
+      tvshowsSet.insert(tvshow);
+      m_tvshows.insert(make_pair(tvshow->GetVideoInfoTag()->m_strTitle, tvshowsSet));
+    }
+    else
+      tvshowsIter->second.insert(tvshow);
+  }
+
+  return true;
+}
+
+bool CSeasonImportHandler::AddImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr)
+    return false;
+
+  PrepareItem(import, item);
+
+  CVideoInfoTag* season = item->GetVideoInfoTag();
+
+  // try to find an existing tvshow that the season belongs to
+  season->m_iIdShow = FindTvShowId(item);
+
+  // if the tvshow doesn't exist, create a very basic version of it with the info we got from the season
+  if (season->m_iIdShow <= 0)
+  {
+    CVideoInfoTag tvshow;
+    tvshow.m_basePath = season->m_basePath;
+    tvshow.m_cast = season->m_cast;
+    tvshow.m_country = season->m_country;
+    tvshow.m_director = season->m_director;
+    tvshow.m_genre = season->m_genre;
+    tvshow.SetYear(season->GetYear());
+    tvshow.m_parentPathID = season->m_parentPathID;
+    tvshow.m_premiered = season->m_premiered;
+    tvshow.m_strMPAARating = season->m_strMPAARating;
+    tvshow.m_strPlot = season->m_strPlot;
+    tvshow.m_strTitle = tvshow.m_strShowTitle = season->m_strShowTitle;
+    tvshow.m_studio = season->m_studio;
+    tvshow.m_type = MediaTypeTvShow;
+    tvshow.m_writingCredits = season->m_writingCredits;
+
+    // try to find a proper path by going up in the path hierarchy once
+    tvshow.m_strPath = URIUtils::GetParentPath(season->GetPath());
+
+    // create an item for the tvshow
+    CFileItemPtr tvshowItem(new CFileItem(tvshow));
+    tvshowItem->SetPath(tvshow.m_strPath);
+    tvshowItem->SetSource(item->GetSource());
+    tvshowItem->SetImportPath(item->GetImportPath());
+
+    // try to use a tvshow-specific import handler
+    bool tvshowImported = false;
+    if (m_importHandlerManager != nullptr)
+    {
+      MediaImportHandlerConstPtr tvshowHandlerCreator =
+          m_importHandlerManager->GetImportHandler(MediaTypeTvShow);
+      if (tvshowHandlerCreator != nullptr)
+      {
+        MediaImportHandlerPtr tvshowHandler(tvshowHandlerCreator->Create());
+        tvshowImported = tvshowHandler->AddImportedItem(import, tvshowItem.get());
+      }
+    }
+
+    // fall back to direct database access
+    if (!tvshowImported)
+    {
+      // add the basic tvshow to the database
+      std::vector<std::pair<std::string, std::string>> tvshowPaths;
+      tvshowPaths.push_back(std::make_pair(tvshow.m_strPath, tvshow.m_basePath));
+      tvshow.m_iDbId = tvshow.m_iIdShow =
+          m_db.SetDetailsForTvShow(tvshowPaths, tvshow, CGUIListItem::ArtMap(),
+                                   std::map<int, std::map<std::string, std::string>>());
+    }
+
+    // store the tvshow's database ID in the season
+    season->m_iIdShow = tvshow.m_iDbId;
+
+    // add the tvshow to the tvshow map
+    auto&& tvshowsIter = m_tvshows.find(tvshow.m_strTitle);
+    if (tvshowsIter == m_tvshows.end())
+    {
+      TvShowsSet tvshowsSet;
+      tvshowsSet.insert(tvshowItem);
+      m_tvshows.insert(make_pair(tvshow.m_strTitle, tvshowsSet));
+    }
+    else
+      tvshowsIter->second.insert(tvshowItem);
+  }
+
+  // check if the season already exists locally
+  season->m_iDbId = m_db.GetSeasonId(season->m_iIdShow, season->m_iSeason);
+
+  // no need to add the season again if it already exists locally
+  if (season->m_iDbId <= 0)
+  {
+    season->m_iDbId = m_db.SetDetailsForSeason(*season, item->GetArt(), season->m_iIdShow);
+    if (season->m_iDbId <= 0)
+      return false;
+  }
+
+  return SetImportForItem(item, import);
+}
+
+bool CSeasonImportHandler::UpdateImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag() || item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  return m_db.SetDetailsForSeason(*(item->GetVideoInfoTag()), item->GetArt(),
+                                  item->GetVideoInfoTag()->m_iIdShow,
+                                  item->GetVideoInfoTag()->m_iDbId) > 0;
+}
+
+bool CSeasonImportHandler::RemoveImportedItem(const CMediaImport& import, const CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return false;
+
+  // We don't delete seasons here because part of the season might be local
+  // or imported from another source. This will be handled in the cleanup task.
+  return true;
+}
+
+bool CSeasonImportHandler::CleanupImportedItems(const CMediaImport& import)
+{
+  if (!m_db.Open())
+    return false;
+
+  std::vector<CFileItemPtr> importedSeasons;
+  if (!GetLocalItems(m_db, import, importedSeasons))
+    return false;
+
+  m_db.BeginTransaction();
+
+  for (const auto& importedSeason : importedSeasons)
+  {
+    if (!importedSeason->HasVideoInfoTag() || importedSeason->GetVideoInfoTag()->m_iIdShow <= 0)
+      continue;
+
+    // get all episodes of the season of the tvshow
+    CVideoDbUrl videoUrl;
+    if (!videoUrl.FromString(StringUtils::Format("videodb://tvshows/titles/{}/{}/",
+                                                 importedSeason->GetVideoInfoTag()->m_iIdShow,
+                                                 importedSeason->GetVideoInfoTag()->m_iSeason)))
+      continue;
+    videoUrl.AddOption("tvshowid", importedSeason->GetVideoInfoTag()->m_iIdShow);
+    if (importedSeason->GetVideoInfoTag()->m_iSeason >= -1)
+      videoUrl.AddOption("season", importedSeason->GetVideoInfoTag()->m_iSeason);
+
+    CFileItemList episodes;
+    if (!m_db.GetEpisodesByWhere(videoUrl.ToString(), CDatabase::Filter(), episodes, true,
+                                 SortDescription(), false))
+      continue;
+
+    // loop through all episodes and count the imported ones
+    bool hasImportedEpisodes = false;
+    for (int i = 0; i < episodes.Size(); ++i)
+    {
+      if (episodes.Get(i)->IsImported())
+      {
+        hasImportedEpisodes = true;
+        break;
+      }
+    }
+
+    // if there no imported episodes we can remove the tvshow
+    if (!hasImportedEpisodes)
+      RemoveImportedItem(m_db, import, importedSeason.get());
+  }
+
+  m_db.CommitTransaction();
+
+  return true;
+}
+
+bool CSeasonImportHandler::GetLocalItems(CVideoDatabase& videodb,
+                                         const CMediaImport& import,
+                                         std::vector<CFileItemPtr>& items) const
+{
+  CFileItemList seasons;
+  if (!videodb.GetSeasonsByWhere("videodb://tvshows/titles/-1/?imported&showempty=true&import=" +
+                                     CURL::Encode(import.GetPath()),
+                                 CDatabase::Filter(), seasons, true))
+    return false;
+
+  items.insert(items.begin(), seasons.cbegin(), seasons.cend());
+
+  return true;
+}
+
+std::set<Field> CSeasonImportHandler::IgnoreDifferences() const
+{
+  return {FieldActor,
+          FieldAirDate,
+          FieldAlbum,
+          FieldArtist,
+          FieldCountry,
+          FieldDirector,
+          FieldEpisodeNumber,
+          FieldEpisodeNumberSpecialSort,
+          FieldFilename,
+          FieldGenre,
+          FieldInProgress,
+          FieldLastPlayed,
+          FieldMPAA,
+          FieldOriginalTitle,
+          FieldPath,
+          FieldPlaycount,
+          FieldPlot,
+          FieldPlotOutline,
+          FieldProductionCode,
+          FieldRating,
+          FieldSeasonSpecialSort,
+          FieldSet,
+          FieldSortTitle,
+          FieldStudio,
+          FieldTag,
+          FieldTagline,
+          FieldTime,
+          FieldTitle,
+          FieldTop250,
+          FieldTrackNumber,
+          FieldTrailer,
+          FieldTvShowStatus,
+          FieldUniqueId,
+          FieldUserRating,
+          FieldWriter};
+}
+
+bool CSeasonImportHandler::RemoveImportedItems(CVideoDatabase& videodb,
+                                               const CMediaImport& import) const
+{
+  std::vector<CFileItemPtr> items;
+  if (!GetLocalItems(videodb, import, items))
+    return false;
+
+  for (const auto& item : items)
+    RemoveImportedItem(videodb, import, item.get());
+
+  return true;
+}
+
+void CSeasonImportHandler::RemoveImportedItem(CVideoDatabase& videodb,
+                                              const CMediaImport& import,
+                                              const CFileItem* item) const
+{
+  // check if the season still has episodes or not
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return;
+
+  // if there are other episodes only remove the import link to the season and not the whole season
+  if (item->GetVideoInfoTag()->m_iEpisode > 0)
+    videodb.RemoveImportFromItem(item->GetVideoInfoTag()->m_iDbId, GetMediaType(), import);
+  else
+    videodb.DeleteSeason(item->GetVideoInfoTag()->m_iDbId, false, false);
+}
+
+int CSeasonImportHandler::FindTvShowId(const CFileItem* seasonItem)
+{
+  if (seasonItem == nullptr || !seasonItem->HasVideoInfoTag())
+    return -1;
+
+  // no comparison possible without a title
+  if (seasonItem->GetVideoInfoTag()->m_strShowTitle.empty())
+    return -1;
+
+  // check if there is a tvshow with a matching title
+  const auto& tvshowsIter = m_tvshows.find(seasonItem->GetVideoInfoTag()->m_strShowTitle);
+  if (tvshowsIter == m_tvshows.end() || tvshowsIter->second.size() <= 0)
+    return -1;
+
+  // if there is only one matching tvshow, we can go with that one
+  if (tvshowsIter->second.size() == 1)
+    return tvshowsIter->second.begin()->get()->GetVideoInfoTag()->m_iDbId;
+
+  // use the path of the episode and tvshow to find the right tvshow
+  for (const auto& it : tvshowsIter->second)
+  {
+    if (URIUtils::PathHasParent(seasonItem->GetVideoInfoTag()->GetPath(),
+                                it->GetVideoInfoTag()->GetPath()))
+      return it->GetVideoInfoTag()->m_iDbId;
+  }
+
+  return -1;
+}
diff --git a/xbmc/media/import/handlers/SeasonImportHandler.h b/xbmc/media/import/handlers/SeasonImportHandler.h
new file mode 100644
index 000000000000..89f2f69076ef
--- /dev/null
+++ b/xbmc/media/import/handlers/SeasonImportHandler.h
@@ -0,0 +1,66 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/handlers/VideoImportHandler.h"
+
+class CSeasonImportHandler : public CVideoImportHandler
+{
+public:
+  CSeasonImportHandler(const IMediaImportHandlerManager* importHandlerManager)
+    : CVideoImportHandler(importHandlerManager)
+  {
+  }
+  virtual ~CSeasonImportHandler() = default;
+
+  CSeasonImportHandler* Create() const override
+  {
+    return new CSeasonImportHandler(m_importHandlerManager);
+  }
+
+  MediaType GetMediaType() const override { return MediaTypeSeason; }
+  MediaTypes GetRequiredMediaTypes() const override { return {MediaTypeEpisode}; }
+  GroupedMediaTypes GetGroupedMediaTypes() const override
+  {
+    return {MediaTypeTvShow, MediaTypeSeason, MediaTypeEpisode};
+  }
+
+  std::string GetItemLabel(const CFileItem* item) const override;
+
+  CFileItemPtr FindMatchingLocalItem(const CMediaImport& import,
+                                     const CFileItem* item,
+                                     const std::vector<CFileItemPtr>& localItems) const override;
+
+  bool StartSynchronisation(const CMediaImport& import) override;
+
+  bool AddImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool UpdateImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool RemoveImportedItem(const CMediaImport& import, const CFileItem* item) override;
+  bool CleanupImportedItems(const CMediaImport& import) override;
+
+protected:
+  bool GetLocalItems(CVideoDatabase& videodb,
+                     const CMediaImport& import,
+                     std::vector<CFileItemPtr>& items) const override;
+
+  std::set<Field> IgnoreDifferences() const override;
+
+  bool RemoveImportedItems(CVideoDatabase& videodb, const CMediaImport& import) const override;
+  void RemoveImportedItem(CVideoDatabase& videodb,
+                          const CMediaImport& import,
+                          const CFileItem* item) const;
+
+private:
+  int FindTvShowId(const CFileItem* episodeItem);
+
+  typedef std::set<CFileItemPtr> TvShowsSet;
+  typedef std::map<std::string, TvShowsSet> TvShowsMap;
+
+  TvShowsMap m_tvshows;
+};
diff --git a/xbmc/media/import/handlers/TvShowImportHandler.cpp b/xbmc/media/import/handlers/TvShowImportHandler.cpp
new file mode 100644
index 000000000000..9dffd5b0dc5c
--- /dev/null
+++ b/xbmc/media/import/handlers/TvShowImportHandler.cpp
@@ -0,0 +1,292 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "TvShowImportHandler.h"
+
+#include "FileItem.h"
+#include "media/import/MediaImport.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "video/VideoDatabase.h"
+
+#include <algorithm>
+
+/*!
+ * Checks whether two tvshows are the same by comparing them by title and year
+ */
+static bool IsSameTVShow(const CVideoInfoTag& left, const CVideoInfoTag& right)
+{
+  return left.m_strTitle == right.m_strTitle && left.GetYear() == right.GetYear();
+}
+
+CFileItemPtr CTvShowImportHandler::FindMatchingLocalItem(
+    const CMediaImport& import,
+    const CFileItem* item,
+    const std::vector<CFileItemPtr>& localItems) const
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return nullptr;
+
+  const auto& localItem =
+      std::find_if(localItems.cbegin(), localItems.cend(), [&item](const CFileItemPtr& localItem) {
+        return IsSameTVShow(*item->GetVideoInfoTag(), *localItem->GetVideoInfoTag());
+      });
+
+  if (localItem != localItems.cend())
+    return *localItem;
+
+  return nullptr;
+}
+
+bool CTvShowImportHandler::AddImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr)
+    return false;
+
+  // make sure that the source and import path are set
+  PrepareItem(import, item);
+
+  // and prepare the tvshow paths
+  std::vector<std::pair<std::string, std::string>> tvshowPaths;
+  tvshowPaths.push_back(std::make_pair(item->GetPath(), item->GetVideoInfoTag()->m_basePath));
+  // we don't know the season art yet
+  std::map<int, std::map<std::string, std::string>> seasonArt;
+
+  const CVideoInfoTag* info = item->GetVideoInfoTag();
+
+  // check if there already is a local tvshow with the same name
+  CFileItemList tvshows;
+  m_db.GetTvShowsByName(info->m_strTitle, tvshows);
+  bool exists = false;
+  if (!tvshows.IsEmpty())
+  {
+    CFileItemPtr tvshow;
+    for (int i = 0; i < tvshows.Size();)
+    {
+      tvshow = tvshows.Get(i);
+      // remove tvshows without a CVideoInfoTag
+      if (!tvshow->HasVideoInfoTag())
+      {
+        tvshows.Remove(i);
+        continue;
+      }
+
+      CVideoInfoTag* tvshowInfo = tvshow->GetVideoInfoTag();
+      if (!m_db.GetTvShowInfo(tvshowInfo->GetPath(), *tvshowInfo, tvshowInfo->m_iDbId,
+                              tvshow.get()))
+      {
+        tvshows.Remove(i);
+        continue;
+      }
+
+      // check if the scraper identifier or the title and year match
+      if ((tvshowInfo->HasUniqueID() && tvshowInfo->GetUniqueID() == info->GetUniqueID()) ||
+          (tvshowInfo->HasYear() && tvshowInfo->GetYear() == info->GetYear() &&
+           tvshowInfo->m_strTitle == info->m_strTitle))
+      {
+        exists = true;
+        break;
+      }
+      // remove tvshows that don't even match in title
+      else if (tvshowInfo->m_strTitle != info->m_strTitle)
+      {
+        tvshows.Remove(i);
+        continue;
+      }
+
+      ++i;
+    }
+
+    // if there was no exact match and there are still tvshows left that match in title
+    // and the new item doesn't have a scraper identifier and no year
+    // we take the first match
+    if (!exists && !tvshows.IsEmpty() && !info->HasUniqueID() && !info->HasYear())
+    {
+      tvshow = tvshows.Get(0);
+      exists = true;
+    }
+
+    // simply add the path of the imported tvshow to the tvshow's paths
+    if (exists && tvshow != nullptr)
+      item->GetVideoInfoTag()->m_iDbId =
+          m_db.SetDetailsForTvShow(tvshowPaths, *(tvshow->GetVideoInfoTag()), tvshow->GetArt(),
+                                   seasonArt, tvshow->GetVideoInfoTag()->m_iDbId);
+  }
+
+  // couldn't find a matching local tvshow so add the newly imported one
+  if (!exists)
+    item->GetVideoInfoTag()->m_iDbId = m_db.SetDetailsForTvShow(
+        tvshowPaths, *(item->GetVideoInfoTag()), item->GetArt(), seasonArt);
+
+  // make sure that the tvshow was properly added
+  if (item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  return SetImportForItem(item, import);
+}
+
+bool CTvShowImportHandler::UpdateImportedItem(const CMediaImport& import, CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag() || item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  std::vector<std::pair<std::string, std::string>> tvshowPaths;
+  tvshowPaths.push_back(std::make_pair(item->GetPath(), item->GetVideoInfoTag()->m_basePath));
+  std::map<int, std::map<std::string, std::string>> seasonArt;
+  return m_db.SetDetailsForTvShow(tvshowPaths, *(item->GetVideoInfoTag()), item->GetArt(),
+                                  seasonArt, item->GetVideoInfoTag()->m_iDbId) > 0;
+}
+
+bool CTvShowImportHandler::RemoveImportedItem(const CMediaImport& import, const CFileItem* item)
+{
+  if (item == nullptr || !item->HasVideoInfoTag() || item->GetVideoInfoTag()->m_iDbId <= 0)
+    return false;
+
+  // get all paths belonging to the tvshow
+  std::map<int, std::string> tvshowPaths;
+  if (!m_db.GetPathsForTvShow(item->GetVideoInfoTag()->m_iDbId, tvshowPaths))
+    return false;
+
+  // something is wrong as the tvshow doesn't have any paths
+  if (tvshowPaths.empty())
+    return false;
+
+  // we only handle the case where more than one path belongs to the tvshow because
+  // we can't delete the tvshow completely before not having synced the episodes
+  if (tvshowPaths.size() == 1)
+    return true;
+
+  for (const auto& tvshowPath : tvshowPaths)
+  {
+    // check if the tvshow path is a sub-path of the media import
+    if (URIUtils::PathHasParent(tvshowPath.second, import.GetPath().c_str()))
+    {
+      // remove the path from the tvshow
+      m_db.RemovePathFromTvShow(item->GetVideoInfoTag()->m_iDbId, tvshowPath.first);
+      m_db.RemoveImportFromItem(item->GetVideoInfoTag()->m_iDbId, GetMediaType(), import);
+      break;
+    }
+  }
+
+  return true;
+}
+
+bool CTvShowImportHandler::CleanupImportedItems(const CMediaImport& import)
+{
+  if (!m_db.Open())
+    return false;
+
+  std::vector<CFileItemPtr> importedTvShows;
+  if (!GetLocalItems(m_db, import, importedTvShows))
+    return false;
+
+  m_db.BeginTransaction();
+
+  for (const auto& importedTvShow : importedTvShows)
+  {
+    if (!importedTvShow->HasVideoInfoTag() || importedTvShow->GetVideoInfoTag()->m_iDbId <= 0)
+      continue;
+
+    // get all episodes of the tvshow
+    CVideoDbUrl videoUrl;
+    if (!videoUrl.FromString(StringUtils::Format("videodb://tvshows/titles/{}/-1/",
+                                                 importedTvShow->GetVideoInfoTag()->m_iDbId)))
+      continue;
+    videoUrl.AddOption("tvshowid", importedTvShow->GetVideoInfoTag()->m_iDbId);
+
+    CFileItemList episodes;
+    if (!m_db.GetEpisodesByWhere(videoUrl.ToString(), CDatabase::Filter(), episodes, true,
+                                 SortDescription(), false))
+      continue;
+
+    // loop through all episodes and count the imported ones
+    bool hasImportedEpisodes = false;
+    for (int i = 0; i < episodes.Size(); ++i)
+    {
+      if (episodes.Get(i)->IsImported())
+      {
+        hasImportedEpisodes = true;
+        break;
+      }
+    }
+
+    // if there are no imported episodes we can remove the tvshow
+    if (!hasImportedEpisodes)
+      RemoveImportedItem(m_db, import, importedTvShow.get());
+  }
+
+  m_db.CommitTransaction();
+
+  return true;
+}
+
+bool CTvShowImportHandler::GetLocalItems(CVideoDatabase& videodb,
+                                         const CMediaImport& import,
+                                         std::vector<CFileItemPtr>& items) const
+{
+  CFileItemList tvshows;
+  if (!videodb.GetTvShowsByWhere(
+          "videodb://tvshows/titles/?imported&import=" + CURL::Encode(import.GetPath()),
+          CDatabase::Filter(), tvshows, SortDescription(),
+          import.Settings()->UpdateImportedMediaItems() ? VideoDbDetailsAll : VideoDbDetailsNone))
+    return false;
+
+  items.insert(items.begin(), tvshows.cbegin(), tvshows.cend());
+
+  return true;
+}
+
+std::set<Field> CTvShowImportHandler::IgnoreDifferences() const
+{
+  return {FieldAlbum,         FieldArtist,
+          FieldCountry,       FieldDirector,
+          FieldEpisodeNumber, FieldEpisodeNumberSpecialSort,
+          FieldFilename,      FieldInProgress,
+          FieldLastPlayed,    FieldPlaycount,
+          FieldPlotOutline,   FieldProductionCode,
+          FieldSeason,        FieldSeasonSpecialSort,
+          FieldSet,           FieldTagline,
+          FieldTime,          FieldTop250,
+          FieldTrackNumber,   FieldTvShowTitle,
+          FieldWriter};
+}
+
+bool CTvShowImportHandler::RemoveImportedItems(CVideoDatabase& videodb,
+                                               const CMediaImport& import) const
+{
+  std::vector<CFileItemPtr> items;
+  if (!GetLocalItems(videodb, import, items))
+    return false;
+
+  for (const auto& item : items)
+    RemoveImportedItem(videodb, import, item.get());
+
+  return true;
+}
+
+void CTvShowImportHandler::RemoveImportedItem(CVideoDatabase& videodb,
+                                              const CMediaImport& import,
+                                              const CFileItem* item) const
+{
+  // check if the tvshow still has episodes or not
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return;
+
+  // if there are other episodes only remove the path and the import link to the tvshow and not the whole tvshow
+  if (item->GetVideoInfoTag()->m_iEpisode > 0)
+  {
+    videodb.RemovePathFromTvShow(item->GetVideoInfoTag()->m_iDbId,
+                                 item->GetVideoInfoTag()->GetPath());
+    videodb.RemoveImportFromItem(item->GetVideoInfoTag()->m_iDbId, GetMediaType(), import);
+  }
+  else
+    videodb.DeleteTvShow(item->GetVideoInfoTag()->m_iDbId, false, false);
+
+  // either way remove the path
+  videodb.DeletePath(-1, item->GetVideoInfoTag()->m_strPath);
+}
diff --git a/xbmc/media/import/handlers/TvShowImportHandler.h b/xbmc/media/import/handlers/TvShowImportHandler.h
new file mode 100644
index 000000000000..1fd521ded487
--- /dev/null
+++ b/xbmc/media/import/handlers/TvShowImportHandler.h
@@ -0,0 +1,54 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/handlers/VideoImportHandler.h"
+
+class CTvShowImportHandler : public CVideoImportHandler
+{
+public:
+  CTvShowImportHandler(const IMediaImportHandlerManager* importHandlerManager)
+    : CVideoImportHandler(importHandlerManager)
+  {
+  }
+  virtual ~CTvShowImportHandler() = default;
+
+  CTvShowImportHandler* Create() const override
+  {
+    return new CTvShowImportHandler(m_importHandlerManager);
+  }
+
+  MediaType GetMediaType() const override { return MediaTypeTvShow; }
+  MediaTypes GetRequiredMediaTypes() const override { return {MediaTypeEpisode}; }
+  GroupedMediaTypes GetGroupedMediaTypes() const override
+  {
+    return {MediaTypeTvShow, MediaTypeSeason, MediaTypeEpisode};
+  }
+
+  CFileItemPtr FindMatchingLocalItem(const CMediaImport& import,
+                                     const CFileItem* item,
+                                     const std::vector<CFileItemPtr>& localItems) const override;
+
+  bool AddImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool UpdateImportedItem(const CMediaImport& import, CFileItem* item) override;
+  bool RemoveImportedItem(const CMediaImport& import, const CFileItem* item) override;
+  bool CleanupImportedItems(const CMediaImport& import) override;
+
+protected:
+  bool GetLocalItems(CVideoDatabase& videodb,
+                     const CMediaImport& import,
+                     std::vector<CFileItemPtr>& items) const override;
+
+  std::set<Field> IgnoreDifferences() const override;
+
+  bool RemoveImportedItems(CVideoDatabase& videodb, const CMediaImport& import) const override;
+  void RemoveImportedItem(CVideoDatabase& videodb,
+                          const CMediaImport& import,
+                          const CFileItem* item) const;
+};
diff --git a/xbmc/media/import/handlers/VideoImportHandler.cpp b/xbmc/media/import/handlers/VideoImportHandler.cpp
new file mode 100644
index 000000000000..4cbff77eced8
--- /dev/null
+++ b/xbmc/media/import/handlers/VideoImportHandler.cpp
@@ -0,0 +1,392 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "VideoImportHandler.h"
+
+#include "FileItem.h"
+#include "media/import/MediaImport.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/log.h"
+#include "video/VideoDatabase.h"
+
+#include <algorithm>
+
+CVideoImportHandler::CVideoImportHandler(const IMediaImportHandlerManager* importHandlerManager)
+  : IMediaImportHandler(importHandlerManager), CStaticLoggerBase("CVideoImportHandler")
+{
+}
+
+std::string CVideoImportHandler::GetItemLabel(const CFileItem* item) const
+{
+  if (item == nullptr)
+    return "";
+
+  if (item->HasVideoInfoTag() && !item->GetVideoInfoTag()->m_strTitle.empty())
+    return item->GetVideoInfoTag()->m_strTitle;
+
+  return item->GetLabel();
+}
+
+bool CVideoImportHandler::GetLocalItems(const CMediaImport& import,
+                                        std::vector<CFileItemPtr>& items) const
+{
+  if (!m_db.Open())
+    return false;
+
+  bool result = GetLocalItems(m_db, import, items);
+
+  m_db.Close();
+  return result;
+}
+
+bool CVideoImportHandler::StartChangeset(const CMediaImport& import)
+{
+  // start the background loader if necessary
+  if (import.Settings()->UpdateImportedMediaItems())
+    m_thumbLoader.OnLoaderStart();
+
+  return true;
+}
+
+bool CVideoImportHandler::FinishChangeset(const CMediaImport& import)
+{
+  // stop the background loader if necessary
+  if (import.Settings()->UpdateImportedMediaItems())
+    m_thumbLoader.OnLoaderFinish();
+
+  return true;
+}
+
+CFileItemPtr CVideoImportHandler::FindMatchingLocalItem(
+    const CMediaImport& import,
+    const CFileItem* item,
+    const std::vector<CFileItemPtr>& localItems) const
+{
+  if (item == nullptr || !item->HasVideoInfoTag())
+    return nullptr;
+
+  const auto& localItem =
+      std::find_if(localItems.cbegin(), localItems.cend(), [item](const CFileItemPtr localItem) {
+        return localItem->HasVideoInfoTag() &&
+               localItem->GetVideoInfoTag()->GetPath() == item->GetVideoInfoTag()->GetPath();
+      });
+  if (localItem != localItems.cend())
+    return *localItem;
+
+  return nullptr;
+}
+
+MediaImportChangesetType CVideoImportHandler::DetermineChangeset(const CMediaImport& import,
+                                                                 const CFileItem* item,
+                                                                 const CFileItemPtr& localItem)
+{
+  if (item == nullptr || localItem == nullptr || !item->HasVideoInfoTag() ||
+      !localItem->HasVideoInfoTag())
+    return MediaImportChangesetType::None;
+
+  const auto& settings = import.Settings();
+
+  // retrieve all details for the previously imported item
+  if (!m_thumbLoader.LoadItem(localItem.get()))
+  {
+    s_logger->warn("failed to retrieve details for local item {} during media importing",
+                   localItem->GetVideoInfoTag()->GetPath());
+  }
+
+  // compare the previously imported item with the newly imported item
+  if (Compare(localItem.get(), item, settings->UpdateImportedMediaItems(),
+              settings->UpdatePlaybackMetadataFromSource()))
+    return MediaImportChangesetType::None;
+
+  return MediaImportChangesetType::Changed;
+}
+
+void CVideoImportHandler::PrepareImportedItem(const CMediaImport& import,
+                                              CFileItem* item,
+                                              const CFileItemPtr& localItem) const
+{
+  if (item == nullptr || localItem == nullptr || !localItem->HasVideoInfoTag() ||
+      !localItem->HasVideoInfoTag())
+    return;
+
+  auto itemVideoInfoTag = item->GetVideoInfoTag();
+  const auto localItemVideoInfoTag = localItem->GetVideoInfoTag();
+
+  itemVideoInfoTag->m_iDbId = localItemVideoInfoTag->m_iDbId;
+  itemVideoInfoTag->m_iFileId = localItemVideoInfoTag->m_iFileId;
+  itemVideoInfoTag->m_iIdShow = localItemVideoInfoTag->m_iIdShow;
+  itemVideoInfoTag->m_iIdSeason = localItemVideoInfoTag->m_iIdSeason;
+
+  item->SetSource(localItem->GetSource());
+  item->SetImportPath(localItem->GetImportPath());
+  itemVideoInfoTag->m_basePath = localItemVideoInfoTag->m_basePath;
+  itemVideoInfoTag->m_parentPathID = localItemVideoInfoTag->m_parentPathID;
+}
+
+bool CVideoImportHandler::StartSynchronisation(const CMediaImport& import)
+{
+  m_sourcePaths.clear();
+  m_importPathIds.clear();
+
+  if (!m_db.Open())
+    return false;
+
+  // TODO(Montellese): is a transaction really needed?
+  m_db.BeginTransaction();
+  return true;
+}
+
+bool CVideoImportHandler::FinishSynchronisation(const CMediaImport& import)
+{
+  if (!m_db.IsOpen())
+    return false;
+
+  // now make sure the items are enabled
+  SetImportedItemsEnabled(import, true);
+
+  // TODO(Montellese): is a transaction really needed?
+  m_db.CommitTransaction();
+  m_db.Close();
+
+  m_sourcePaths.clear();
+  m_importPathIds.clear();
+
+  return true;
+}
+
+bool CVideoImportHandler::RemoveImportedItems(const CMediaImport& import)
+{
+  if (!m_db.Open())
+    return false;
+
+  m_db.BeginTransaction();
+
+  bool success = RemoveImportedItems(m_db, import);
+
+  if (success)
+    m_db.CommitTransaction();
+  else
+    m_db.RollbackTransaction();
+
+  m_db.Close();
+  return success;
+}
+
+void CVideoImportHandler::SetImportedItemsEnabled(const CMediaImport& import, bool enable)
+{
+  if (!m_db.Open())
+    return;
+
+  m_db.SetImportItemsEnabled(enable, GetMediaType(), import);
+  m_db.Close();
+}
+
+bool CVideoImportHandler::RemoveImportedItems(CVideoDatabase& videodb,
+                                              const CMediaImport& import) const
+{
+  return videodb.DeleteItemsFromImport(import);
+}
+
+void CVideoImportHandler::PrepareItem(const CMediaImport& import, CFileItem* pItem)
+{
+  if (pItem == nullptr || !pItem->HasVideoInfoTag() || import.GetPath().empty() ||
+      import.GetSource().GetIdentifier().empty())
+    return;
+
+  const std::string& sourcePath = import.GetSource().GetBasePath();
+  const std::string& importPath = import.GetPath();
+
+  // only add the source path to the database if it isn't already known
+  if (m_sourcePaths.find(sourcePath) == m_sourcePaths.end())
+  {
+    m_db.AddPath(sourcePath);
+    m_sourcePaths.insert(sourcePath);
+  }
+
+  // only add the import path to the database if it isn't already known
+  int idPath = -1;
+  const auto& importPathId = m_importPathIds.find(importPath);
+  if (importPathId == m_importPathIds.end())
+  {
+    idPath = m_db.AddPath(importPath, sourcePath);
+    m_importPathIds.emplace(importPath, idPath);
+  }
+  else
+    idPath = importPathId->second;
+
+  // set the proper source
+  pItem->SetSource(import.GetSource().GetIdentifier());
+  pItem->SetImportPath(importPath);
+
+  auto videoInfoTag = pItem->GetVideoInfoTag();
+
+  // set the proper base and parent path
+  videoInfoTag->m_basePath = sourcePath;
+  videoInfoTag->m_parentPathID = idPath;
+
+  if (!pItem->m_bIsFolder)
+    videoInfoTag->m_iFileId = m_db.AddFile(
+        pItem->GetPath(), importPath, videoInfoTag->GetPlayCount(), videoInfoTag->m_lastPlayed);
+}
+
+void CVideoImportHandler::SetDetailsForFile(const CFileItem* pItem, bool reset)
+{
+  const auto videoInfoTag = pItem->GetVideoInfoTag();
+
+  // update playcount and lastplayed
+  m_db.SetPlayCount(*pItem, videoInfoTag->GetPlayCount(), videoInfoTag->m_lastPlayed);
+
+  // clean resume bookmark
+  if (reset)
+    m_db.DeleteResumeBookMark(*pItem, false);
+
+  if (videoInfoTag->GetResumePoint().IsPartWay())
+    m_db.AddBookMarkToFile(pItem->GetPath(), videoInfoTag->GetResumePoint(), CBookmark::RESUME);
+}
+
+bool CVideoImportHandler::SetImportForItem(const CFileItem* pItem, const CMediaImport& import)
+{
+  return m_db.SetImportForItem(pItem->GetVideoInfoTag()->m_iDbId, GetMediaType(), import);
+}
+
+void CVideoImportHandler::RemoveFile(CVideoDatabase& videodb, const CFileItem* item) const
+{
+  if (!videodb.IsOpen() || item == nullptr || !item->HasVideoInfoTag())
+    return;
+
+  videodb.DeleteFile(item->GetVideoInfoTag()->m_iFileId, item->GetVideoInfoTag()->GetPath());
+}
+
+bool CVideoImportHandler::Compare(const CFileItem* originalItem,
+                                  const CFileItem* newItem,
+                                  bool allMetadata /* = true */,
+                                  bool playbackMetadata /* = true */) const
+{
+  if (originalItem == nullptr || !originalItem->HasVideoInfoTag() || newItem == nullptr ||
+      !newItem->HasVideoInfoTag())
+    return false;
+
+  const auto originalItemVideoInfoTag = originalItem->GetVideoInfoTag();
+  const auto newItemVideoInfoTag = newItem->GetVideoInfoTag();
+
+  if (!allMetadata)
+  {
+    return originalItemVideoInfoTag->GetPlayCount() == newItemVideoInfoTag->GetPlayCount() &&
+           originalItemVideoInfoTag->m_lastPlayed == newItemVideoInfoTag->m_lastPlayed &&
+           originalItemVideoInfoTag->GetResumePoint().timeInSeconds ==
+               newItemVideoInfoTag->GetResumePoint().timeInSeconds;
+  }
+
+  auto originalArt = originalItem->GetArt();
+  const auto& newArt = newItem->GetArt();
+  if (originalArt != newArt)
+  {
+    // if the number of artwork is identical something must have changed in the URLs
+    if (originalArt.size() == newArt.size())
+      return false;
+
+    // remove any artwork Kodi automatically adds
+    std::set<std::string> parentPrefixes;
+    if (originalItemVideoInfoTag->m_type == MediaTypeMovie)
+      parentPrefixes = {"set"};
+    else if (originalItemVideoInfoTag->m_type == MediaTypeSeason ||
+             originalItemVideoInfoTag->m_type == MediaTypeEpisode)
+      parentPrefixes = {"tvshow", "season"};
+    RemoveAutoArtwork(originalArt, parentPrefixes);
+
+    if (originalArt != newArt)
+      return false;
+  }
+
+  if (originalItemVideoInfoTag->Equals(*newItemVideoInfoTag, true))
+    return true;
+
+  std::set<Field> differences;
+  if (!originalItemVideoInfoTag->GetDifferences(*newItemVideoInfoTag, differences, true))
+    return true;
+
+  // if playback metadata shouldn't be compared simply remove them from the list of differences
+  if (!playbackMetadata)
+  {
+    differences.erase(FieldPlaycount); // playcount
+    differences.erase(FieldLastPlayed); // lastplayed
+    differences.erase(FieldInProgress); // resume point
+  }
+
+  // check and remove any media type specific ignored properties
+  const auto ignoredDifferences = IgnoreDifferences();
+  for (const auto& difference : ignoredDifferences)
+    differences.erase(difference);
+
+  // special handling for actors without artwork
+  const auto& it = differences.find(FieldActor);
+  if (it != differences.end())
+  {
+    bool equal = false;
+    const std::vector<SActorInfo>& originalCast = originalItemVideoInfoTag->m_cast;
+    const std::vector<SActorInfo>& newCast = newItemVideoInfoTag->m_cast;
+    // ignore differences in cast if the imported item doesn't provide a cast at all
+    if (newCast.empty())
+      equal = true;
+    else if (originalCast.size() == newCast.size())
+    {
+      equal = true;
+      for (size_t index = 0; index < originalCast.size(); ++index)
+      {
+        const SActorInfo& originalActor = originalCast.at(index);
+        const SActorInfo& newActor = newCast.at(index);
+
+        if (originalActor.strName != newActor.strName ||
+            originalActor.strRole != newActor.strRole ||
+            (!newActor.thumb.empty() && originalActor.thumb != newActor.thumb) ||
+            (!newActor.thumbUrl.m_data.empty() &&
+             originalActor.thumbUrl.m_data != newActor.thumbUrl.m_data))
+        {
+          equal = false;
+          break;
+        }
+      }
+    }
+
+    if (equal)
+      differences.erase(it);
+  }
+
+  if (!differences.empty())
+    return false;
+
+  return true;
+}
+
+void CVideoImportHandler::RemoveAutoArtwork(CGUIListItem::ArtMap& artwork,
+                                            const std::set<std::string>& parentPrefixes)
+{
+  for (auto art = artwork.begin(); art != artwork.end();)
+  {
+    bool remove = false;
+    // check for default artwork
+    if (art->second == "DefaultVideo.png" || art->second == "DefaultFolder.png")
+      remove = true;
+    // check for image:// artwork
+    else if (StringUtils::StartsWith(art->second, "image://"))
+      remove = true;
+    // check for parent artwork
+    else if (!parentPrefixes.empty() &&
+             std::any_of(parentPrefixes.begin(), parentPrefixes.end(),
+                         [art](const std::string& parentPrefix) {
+                           return StringUtils::StartsWith(art->first, parentPrefix + ".");
+                         }))
+      remove = true;
+
+    if (remove)
+      art = artwork.erase(art);
+    else
+      ++art;
+  }
+}
diff --git a/xbmc/media/import/handlers/VideoImportHandler.h b/xbmc/media/import/handlers/VideoImportHandler.h
new file mode 100644
index 000000000000..5d174949378a
--- /dev/null
+++ b/xbmc/media/import/handlers/VideoImportHandler.h
@@ -0,0 +1,75 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "dbwrappers/Database.h"
+#include "media/import/IMediaImportHandler.h"
+#include "utils/StaticLoggerBase.h"
+#include "video/VideoDatabase.h"
+#include "video/VideoThumbLoader.h"
+
+class CFileItem;
+
+class CVideoImportHandler : public IMediaImportHandler, protected CStaticLoggerBase
+{
+public:
+  virtual ~CVideoImportHandler() = default;
+
+  std::string GetItemLabel(const CFileItem* item) const override;
+
+  bool GetLocalItems(const CMediaImport& import, std::vector<CFileItemPtr>& items) const override;
+
+  bool StartChangeset(const CMediaImport& import) override;
+  bool FinishChangeset(const CMediaImport& import) override;
+  CFileItemPtr FindMatchingLocalItem(const CMediaImport& import,
+                                     const CFileItem* item,
+                                     const std::vector<CFileItemPtr>& localItems) const override;
+  MediaImportChangesetType DetermineChangeset(const CMediaImport& import,
+                                              const CFileItem* item,
+                                              const CFileItemPtr& localItem) override;
+  void PrepareImportedItem(const CMediaImport& import,
+                           CFileItem* item,
+                           const CFileItemPtr& localItem) const override;
+
+  bool StartSynchronisation(const CMediaImport& import) override;
+  bool FinishSynchronisation(const CMediaImport& import) override;
+
+  bool RemoveImportedItems(const CMediaImport& import) override;
+
+  void SetImportedItemsEnabled(const CMediaImport& import, bool enable) override;
+
+protected:
+  CVideoImportHandler(const IMediaImportHandlerManager* importHandlerManager);
+
+  virtual bool GetLocalItems(CVideoDatabase& videodb,
+                             const CMediaImport& import,
+                             std::vector<CFileItemPtr>& items) const = 0;
+
+  virtual std::set<Field> IgnoreDifferences() const { return std::set<Field>(); }
+
+  virtual bool RemoveImportedItems(CVideoDatabase& videodb, const CMediaImport& import) const;
+
+  void PrepareItem(const CMediaImport& import, CFileItem* pItem);
+  void SetDetailsForFile(const CFileItem* pItem, bool reset);
+  bool SetImportForItem(const CFileItem* pItem, const CMediaImport& import);
+  void RemoveFile(CVideoDatabase& videodb, const CFileItem* item) const;
+
+  bool Compare(const CFileItem* originalItem,
+               const CFileItem* newItem,
+               bool allMetadata = true,
+               bool playbackMetadata = true) const;
+
+  static void RemoveAutoArtwork(CGUIListItem::ArtMap& artwork,
+                                const std::set<std::string>& parentPrefixes);
+
+  mutable CVideoDatabase m_db;
+  CVideoThumbLoader m_thumbLoader;
+  std::set<std::string> m_sourcePaths;
+  std::map<std::string, int> m_importPathIds;
+};

From 4404592ff1c427275fddb952c7173bd704c6e895 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 13 Oct 2019 00:07:10 +0200
Subject: [PATCH 44/88] [media import] add video implementation of
 IMediaImportRepository

---
 cmake/treedata/common/media.txt               |   1 +
 .../import/handlers/VideoImportHandler.cpp    |  10 +-
 xbmc/media/import/repositories/CMakeLists.txt |   7 +
 .../GenericMediaImportRepository.cpp          | 461 ++++++++++++++++++
 .../GenericMediaImportRepository.h            |  80 +++
 .../repositories/VideoImportRepository.cpp    |  69 +++
 .../repositories/VideoImportRepository.h      |  40 ++
 7 files changed, 667 insertions(+), 1 deletion(-)
 create mode 100644 xbmc/media/import/repositories/CMakeLists.txt
 create mode 100644 xbmc/media/import/repositories/GenericMediaImportRepository.cpp
 create mode 100644 xbmc/media/import/repositories/GenericMediaImportRepository.h
 create mode 100644 xbmc/media/import/repositories/VideoImportRepository.cpp
 create mode 100644 xbmc/media/import/repositories/VideoImportRepository.h

diff --git a/cmake/treedata/common/media.txt b/cmake/treedata/common/media.txt
index c7d66db44fd9..ef3ac76ed4ac 100644
--- a/cmake/treedata/common/media.txt
+++ b/cmake/treedata/common/media.txt
@@ -4,3 +4,4 @@ xbmc/media/import                               media/import
 xbmc/media/import/handlers                      media/import/handlers
 xbmc/media/import/jobs                          media/import/jobs
 xbmc/media/import/jobs/tasks                    media/import/jobs/tasks
+xbmc/media/import/repositories                  media/import/repositories
diff --git a/xbmc/media/import/handlers/VideoImportHandler.cpp b/xbmc/media/import/handlers/VideoImportHandler.cpp
index 4cbff77eced8..2c186e0e7058 100644
--- a/xbmc/media/import/handlers/VideoImportHandler.cpp
+++ b/xbmc/media/import/handlers/VideoImportHandler.cpp
@@ -9,6 +9,8 @@
 #include "VideoImportHandler.h"
 
 #include "FileItem.h"
+#include "ServiceBroker.h"
+#include "interfaces/AnnouncementManager.h"
 #include "media/import/MediaImport.h"
 #include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
@@ -139,6 +141,9 @@ bool CVideoImportHandler::StartSynchronisation(const CMediaImport& import)
 
   // TODO(Montellese): is a transaction really needed?
   m_db.BeginTransaction();
+
+  CServiceBroker::GetAnnouncementManager()->Announce(ANNOUNCEMENT::VideoLibrary, "xbmc",
+                                                     "OnScanStarted");
   return true;
 }
 
@@ -157,6 +162,9 @@ bool CVideoImportHandler::FinishSynchronisation(const CMediaImport& import)
   m_sourcePaths.clear();
   m_importPathIds.clear();
 
+  CServiceBroker::GetAnnouncementManager()->Announce(ANNOUNCEMENT::VideoLibrary, "xbmc",
+                                                     "OnScanFinished");
+
   return true;
 }
 
@@ -240,7 +248,7 @@ void CVideoImportHandler::SetDetailsForFile(const CFileItem* pItem, bool reset)
   const auto videoInfoTag = pItem->GetVideoInfoTag();
 
   // update playcount and lastplayed
-  m_db.SetPlayCount(*pItem, videoInfoTag->GetPlayCount(), videoInfoTag->m_lastPlayed);
+  m_db.SetPlayCount(*pItem, videoInfoTag->GetPlayCount(), videoInfoTag->m_lastPlayed, false);
 
   // clean resume bookmark
   if (reset)
diff --git a/xbmc/media/import/repositories/CMakeLists.txt b/xbmc/media/import/repositories/CMakeLists.txt
new file mode 100644
index 000000000000..30e6befb354a
--- /dev/null
+++ b/xbmc/media/import/repositories/CMakeLists.txt
@@ -0,0 +1,7 @@
+set(SOURCES GenericMediaImportRepository.cpp
+            VideoImportRepository.cpp)
+
+set(HEADERS GenericMediaImportRepository.h
+            VideoImportRepository.h)
+
+core_add_library(media_import_repositories)
diff --git a/xbmc/media/import/repositories/GenericMediaImportRepository.cpp b/xbmc/media/import/repositories/GenericMediaImportRepository.cpp
new file mode 100644
index 000000000000..c1803cedb0a5
--- /dev/null
+++ b/xbmc/media/import/repositories/GenericMediaImportRepository.cpp
@@ -0,0 +1,461 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "GenericMediaImportRepository.h"
+
+#include "FileItem.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "guilib/LocalizeStrings.h"
+#include "threads/SingleLock.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+
+CGenericMediaImportRepository::~CGenericMediaImportRepository()
+{
+  if (!m_loaded)
+    return;
+
+  m_sources.clear();
+  m_imports.clear();
+}
+
+bool CGenericMediaImportRepository::Initialize()
+{
+  if (m_loaded)
+    return true;
+
+  if (!openRepository())
+    return false;
+
+  std::vector<CMediaImportSource> sources = getSources();
+  std::vector<CMediaImport> imports = getImports();
+  closeRepository();
+
+  CSingleLock sourcesLock(m_sourcesLock);
+  for (const auto& it : sources)
+    m_sources.insert(std::make_pair(it.GetIdentifier(), it));
+
+  {
+    CSingleLock importsLock(m_importsLock);
+    for (auto& it : imports)
+    {
+      if (it.GetSource().GetIdentifier().empty())
+        continue;
+
+      const auto& itSource = m_sources.find(it.GetSource().GetIdentifier());
+      if (itSource == m_sources.end())
+        continue;
+
+      it.SetSource(itSource->second);
+      m_imports.insert(std::make_pair(GetMediaImportIdentifier(it), it));
+    }
+  }
+
+  m_loaded = true;
+  return true;
+}
+
+std::vector<CMediaImport> CGenericMediaImportRepository::GetImports() const
+{
+  std::vector<CMediaImport> imports;
+
+  if (!m_loaded)
+    return imports;
+
+  CSingleLock importsLock(m_importsLock);
+  for (const auto& it : m_imports)
+    imports.emplace_back(it.second.Clone());
+
+  return imports;
+}
+
+std::vector<CMediaImport> CGenericMediaImportRepository::GetImportsBySource(
+    const std::string& sourceIdentifier) const
+{
+  std::vector<CMediaImport> imports;
+
+  if (!m_loaded || sourceIdentifier.empty())
+    return imports;
+
+  CSingleLock importsLock(m_importsLock);
+  for (const auto& it : m_imports)
+  {
+    if (it.second.GetSource().GetIdentifier().compare(sourceIdentifier) == 0)
+      imports.emplace_back(it.second.Clone());
+  }
+
+  return imports;
+}
+
+std::vector<CMediaImport> CGenericMediaImportRepository::GetImportsByMediaType(
+    const GroupedMediaTypes& mediaTypes) const
+{
+  std::vector<CMediaImport> imports;
+
+  if (!m_loaded || mediaTypes.empty())
+    return imports;
+
+  MediaTypes supportedMediaTypes = getSupportedMediaTypes();
+  if (!ContainsAllMediaTypes(supportedMediaTypes, mediaTypes))
+    return imports;
+
+  CSingleLock importsLock(m_importsLock);
+  for (const auto& it : m_imports)
+  {
+    if (it.first.second == mediaTypes)
+      imports.emplace_back(it.second.Clone());
+  }
+
+  return imports;
+}
+
+std::vector<CMediaImport> CGenericMediaImportRepository::GetImportsByPath(
+    const std::string& path, bool includeSubDirectories /* = false */) const
+{
+  std::vector<CMediaImport> imports;
+
+  if (!m_loaded || path.empty())
+    return imports;
+
+  CSingleLock importsLock(m_importsLock);
+  for (const auto& it : m_imports)
+  {
+    if (it.second.GetPath() == path ||
+        (includeSubDirectories && URIUtils::PathHasParent(it.second.GetPath(), path.c_str())))
+      imports.emplace_back(it.second.Clone());
+  }
+
+  return imports;
+}
+
+bool CGenericMediaImportRepository::GetImport(const std::string& path,
+                                              const GroupedMediaTypes& mediaTypes,
+                                              CMediaImport& import) const
+{
+  if (!m_loaded || path.empty() || mediaTypes.empty())
+    return false;
+
+  CSingleLock importsLock(m_importsLock);
+  const auto& it = m_imports.find(MediaImportIdentifier(path, mediaTypes));
+  if (it == m_imports.end())
+    return false;
+
+  // explicitly create a copy of the import object
+  import = it->second.Clone();
+
+  return true;
+}
+
+bool CGenericMediaImportRepository::AddImport(const CMediaImport& import, bool& added)
+{
+  added = false;
+  if (!m_loaded || import.GetSource().GetIdentifier().empty() || import.GetPath().empty() ||
+      import.GetMediaTypes().empty())
+    return false;
+
+  MediaTypes supportedMediaTypes = getSupportedMediaTypes();
+  if (!ContainsAllMediaTypes(supportedMediaTypes, import.GetMediaTypes()))
+    return false;
+
+  MediaImportIdentifier importIdentifier = GetMediaImportIdentifier(import);
+
+  CSingleLock importsLock(m_importsLock);
+  auto&& itImport = m_imports.find(importIdentifier);
+  if (itImport != m_imports.end() && itImport->second == import)
+    return true;
+
+  if (!openRepository())
+    return false;
+
+  if (itImport == m_imports.end())
+  {
+    int idImport = addImport(import);
+    closeRepository();
+
+    if (idImport < 0)
+      return false;
+
+    m_imports.insert(std::make_pair(importIdentifier, import));
+  }
+  else
+  {
+    bool ret = updateImport(import);
+    closeRepository();
+
+    if (!ret)
+      return false;
+
+    itImport->second = import.Clone();
+  }
+
+  added = true;
+  return true;
+}
+
+bool CGenericMediaImportRepository::UpdateImport(const CMediaImport& import, bool& updated)
+{
+  updated = false;
+  if (!m_loaded || import.GetSource().GetIdentifier().empty() || import.GetPath().empty() ||
+      import.GetMediaTypes().empty())
+    return false;
+
+  CSingleLock importsLock(m_importsLock);
+  auto&& itImport = m_imports.find(GetMediaImportIdentifier(import));
+  if (itImport == m_imports.end())
+    return false;
+
+  if (!openRepository())
+    return false;
+
+  bool ret = updateImport(import);
+  closeRepository();
+
+  if (!ret)
+    return false;
+
+  itImport->second = import.Clone();
+
+  updated = true;
+  return true;
+}
+
+bool CGenericMediaImportRepository::RemoveImport(const CMediaImport& import)
+{
+  if (!m_loaded || import.GetPath().empty() || import.GetMediaTypes().empty())
+    return false;
+
+  CSingleLock importsLock(m_importsLock);
+  auto&& itImport = m_imports.find(GetMediaImportIdentifier(import));
+  if (itImport == m_imports.end())
+    return false;
+
+  if (!openRepository())
+    return false;
+
+  removeImport(import);
+  closeRepository();
+
+  m_imports.erase(itImport);
+
+  return true;
+}
+
+bool CGenericMediaImportRepository::UpdateLastSync(CMediaImport& import)
+{
+  if (!m_loaded || import.GetPath().empty() || import.GetMediaTypes().empty())
+    return false;
+
+  CSingleLock importsLock(m_importsLock);
+  auto&& itImport = m_imports.find(GetMediaImportIdentifier(import));
+  if (itImport == m_imports.end())
+    return false;
+
+  if (!openRepository())
+    return false;
+
+  CDateTime lastSynced = CDateTime::GetCurrentDateTime();
+  updateLastSync(import, lastSynced);
+  closeRepository();
+
+  // update the cached copy of the import
+  itImport->second.SetLastSynced(lastSynced);
+  importsLock.Leave();
+
+  // update the cached copy of the import's source
+  CSingleLock sourcesLock(m_sourcesLock);
+  auto&& itSource = m_sources.find(import.GetSource().GetIdentifier());
+  if (itSource != m_sources.end())
+    itSource->second.SetLastSynced(lastSynced);
+
+  // update the local copy of the import and the source
+  import.SetLastSynced(lastSynced);
+
+  return true;
+}
+
+std::vector<CMediaImportSource> CGenericMediaImportRepository::GetSources(
+    const GroupedMediaTypes& mediaTypes /* = GroupedMediaTypes() */) const
+{
+  std::vector<CMediaImportSource> sources;
+
+  if (!m_loaded)
+    return sources;
+
+  if (!mediaTypes.empty())
+  {
+    MediaTypes supportedMediaTypes = getSupportedMediaTypes();
+    if (!ContainsAllMediaTypes(supportedMediaTypes, mediaTypes))
+      return sources;
+  }
+
+  CSingleLock sourcesLock(m_sourcesLock);
+  for (const auto& it : m_sources)
+  {
+    if (mediaTypes.empty() || ContainsAllMediaTypes(it.second.GetAvailableMediaTypes(), mediaTypes))
+      sources.emplace_back(it.second.Clone());
+  }
+
+  return sources;
+}
+
+bool CGenericMediaImportRepository::GetSource(const std::string& identifier,
+                                              CMediaImportSource& source) const
+{
+  if (!m_loaded || identifier.empty())
+    return false;
+
+  CSingleLock sourcesLock(m_sourcesLock);
+  const auto& it = m_sources.find(identifier);
+  if (it == m_sources.end())
+    return false;
+
+  // explicitly create a copy of the import source object
+  source = it->second.Clone();
+
+  return true;
+}
+
+bool CGenericMediaImportRepository::AddSource(const CMediaImportSource& source, bool& added)
+{
+  added = false;
+  if (!m_loaded || source.GetIdentifier().empty() || source.GetFriendlyName().empty())
+    return false;
+
+  MediaTypes supportedMediaTypes = getSupportedMediaTypes();
+  bool supported = false;
+  const MediaTypes availableMediaTypes = source.GetAvailableMediaTypes();
+  for (const auto& mediaType : availableMediaTypes)
+  {
+    if (supportedMediaTypes.find(mediaType) != supportedMediaTypes.end())
+    {
+      supported = true;
+      break;
+    }
+  }
+
+  if (!supported)
+    return false;
+
+  CSingleLock sourcesLock(m_sourcesLock);
+  auto&& itSource = m_sources.find(source.GetIdentifier());
+  if (itSource != m_sources.end() && itSource->second == source)
+    return true;
+
+  if (!openRepository())
+    return false;
+
+  if (itSource == m_sources.end())
+  {
+    int idSource = addSource(source);
+    closeRepository();
+
+    if (idSource < 0)
+      return false;
+
+    m_sources.insert(std::make_pair(source.GetIdentifier(), source.Clone()));
+  }
+  else
+  {
+    bool ret = updateSource(source);
+    closeRepository();
+
+    if (!ret)
+      return false;
+
+    itSource->second = source.Clone();
+  }
+
+  added = true;
+  return true;
+}
+
+bool CGenericMediaImportRepository::UpdateSource(const CMediaImportSource& source, bool& updated)
+{
+  updated = false;
+  if (!m_loaded || source.GetIdentifier().empty() || source.GetFriendlyName().empty())
+    return false;
+
+  CSingleLock sourcesLock(m_sourcesLock);
+  auto&& itSource = m_sources.find(source.GetIdentifier());
+  if (itSource == m_sources.end())
+    return false;
+
+  // no need to update the source if it hasn't changed
+  if (itSource->second == source)
+    return true;
+
+  if (!openRepository())
+    return false;
+
+  // store the updated source in the repository
+  bool ret = updateSource(source);
+  closeRepository();
+
+  if (!ret)
+    return false;
+
+  // update the cached source
+  itSource->second = source.Clone();
+  sourcesLock.Leave();
+
+  // update any cached imports belonging to this source
+  CSingleLock importsLock(m_importsLock);
+  for (auto&& import : m_imports)
+  {
+    if (import.second.GetSource().GetIdentifier() == source.GetIdentifier())
+      import.second.SetSource(source.Clone());
+  }
+
+  updated = true;
+  return true;
+}
+
+bool CGenericMediaImportRepository::RemoveSource(const std::string& identifier)
+{
+  if (!m_loaded || identifier.empty())
+    return false;
+
+  CSingleLock sourcesLock(m_sourcesLock);
+  auto&& it = m_sources.find(identifier);
+  if (it == m_sources.end())
+    return false;
+
+  if (!openRepository())
+    return false;
+
+  removeSource(it->second);
+  closeRepository();
+
+  m_sources.erase(it);
+
+  CSingleLock importsLock(m_importsLock);
+  for (MediaImportMap::iterator it = m_imports.begin(); it != m_imports.end();)
+  {
+    if (it->second.GetSource().GetIdentifier().compare(identifier) == 0)
+      m_imports.erase(it++);
+    else
+      ++it;
+  }
+
+  return true;
+}
+
+CGenericMediaImportRepository::MediaImportIdentifier CGenericMediaImportRepository::
+    GetMediaImportIdentifier(const CMediaImport& import)
+{
+  return MediaImportIdentifier(import.GetPath(), import.GetMediaTypes());
+}
+
+bool CGenericMediaImportRepository::ContainsAllMediaTypes(
+    const MediaTypes& mediaTypes, const GroupedMediaTypes& groupedMediaTypes)
+{
+  return std::all_of(groupedMediaTypes.begin(), groupedMediaTypes.end(),
+                     [&mediaTypes](const MediaType& mediaType) {
+                       return mediaTypes.find(mediaType) != mediaTypes.end();
+                     });
+}
diff --git a/xbmc/media/import/repositories/GenericMediaImportRepository.h b/xbmc/media/import/repositories/GenericMediaImportRepository.h
new file mode 100644
index 000000000000..c93030a37283
--- /dev/null
+++ b/xbmc/media/import/repositories/GenericMediaImportRepository.h
@@ -0,0 +1,80 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/IMediaImportRepository.h"
+#include "threads/CriticalSection.h"
+
+#include <map>
+#include <set>
+
+class CGenericMediaImportRepository : public IMediaImportRepository
+{
+public:
+  CGenericMediaImportRepository() : m_loaded(false) {}
+  virtual ~CGenericMediaImportRepository();
+
+  bool Initialize() override;
+
+  std::vector<CMediaImport> GetImports() const override;
+  std::vector<CMediaImport> GetImportsBySource(const std::string& sourceIdentifier) const override;
+  std::vector<CMediaImport> GetImportsByMediaType(
+      const GroupedMediaTypes& mediaTypes) const override;
+  std::vector<CMediaImport> GetImportsByPath(const std::string& path,
+                                             bool includeSubDirectories = false) const override;
+  bool GetImport(const std::string& path,
+                 const GroupedMediaTypes& mediaTypes,
+                 CMediaImport& import) const override;
+
+  bool AddImport(const CMediaImport& import, bool& added) override;
+  bool UpdateImport(const CMediaImport& import, bool& updated) override;
+  bool RemoveImport(const CMediaImport& import) override;
+
+  bool UpdateLastSync(CMediaImport& import) override;
+
+  std::vector<CMediaImportSource> GetSources(
+      const GroupedMediaTypes& mediaTypes = GroupedMediaTypes()) const override;
+  bool GetSource(const std::string& identifier, CMediaImportSource& source) const override;
+
+  bool AddSource(const CMediaImportSource& source, bool& added) override;
+  bool UpdateSource(const CMediaImportSource& source, bool& updated) override;
+  bool RemoveSource(const std::string& identifier) override;
+
+protected:
+  virtual MediaTypes getSupportedMediaTypes() const = 0;
+
+  virtual bool openRepository() = 0;
+  virtual void closeRepository() = 0;
+
+  virtual std::vector<CMediaImportSource> getSources() const = 0;
+  virtual int addSource(const CMediaImportSource& source) = 0;
+  virtual bool updateSource(const CMediaImportSource& source) = 0;
+  virtual void removeSource(const CMediaImportSource& source) = 0;
+  virtual std::vector<CMediaImport> getImports() const = 0;
+  virtual int addImport(const CMediaImport& import) = 0;
+  virtual bool updateImport(const CMediaImport& import) = 0;
+  virtual void removeImport(const CMediaImport& import) = 0;
+  virtual void updateLastSync(const CMediaImport& import, const CDateTime& lastSync) = 0;
+
+  typedef std::pair<std::string, GroupedMediaTypes> MediaImportIdentifier;
+  static MediaImportIdentifier GetMediaImportIdentifier(const CMediaImport& import);
+
+  static bool ContainsAllMediaTypes(const MediaTypes& mediaTypes,
+                                    const GroupedMediaTypes& groupedMediaTypes);
+
+  bool m_loaded;
+
+  typedef std::map<MediaImportIdentifier, CMediaImport> MediaImportMap;
+  mutable CCriticalSection m_importsLock;
+  MediaImportMap m_imports;
+
+  typedef std::map<std::string, CMediaImportSource> MediaImportSourceMap;
+  mutable CCriticalSection m_sourcesLock;
+  MediaImportSourceMap m_sources;
+};
diff --git a/xbmc/media/import/repositories/VideoImportRepository.cpp b/xbmc/media/import/repositories/VideoImportRepository.cpp
new file mode 100644
index 000000000000..2a6e67aac12b
--- /dev/null
+++ b/xbmc/media/import/repositories/VideoImportRepository.cpp
@@ -0,0 +1,69 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "VideoImportRepository.h"
+
+#include "FileItem.h"
+#include "video/VideoInfoTag.h"
+
+MediaTypes CVideoImportRepository::getSupportedMediaTypes() const
+{
+  MediaTypes supportedMediaTypes;
+  supportedMediaTypes.insert(MediaTypeMovie);
+  supportedMediaTypes.insert(MediaTypeVideoCollection);
+  supportedMediaTypes.insert(MediaTypeTvShow);
+  supportedMediaTypes.insert(MediaTypeSeason);
+  supportedMediaTypes.insert(MediaTypeEpisode);
+  supportedMediaTypes.insert(MediaTypeMusicVideo);
+  return supportedMediaTypes;
+}
+
+std::vector<CMediaImportSource> CVideoImportRepository::getSources() const
+{
+  return m_db.GetSources();
+}
+
+int CVideoImportRepository::addSource(const CMediaImportSource& source)
+{
+  return m_db.AddSource(source);
+}
+
+bool CVideoImportRepository::updateSource(const CMediaImportSource& source)
+{
+  return m_db.SetDetailsForSource(source);
+}
+
+void CVideoImportRepository::removeSource(const CMediaImportSource& source)
+{
+  m_db.RemoveSource(source.GetIdentifier());
+}
+
+std::vector<CMediaImport> CVideoImportRepository::getImports() const
+{
+  return m_db.GetImports();
+}
+
+int CVideoImportRepository::addImport(const CMediaImport& import)
+{
+  return m_db.AddImport(import);
+}
+
+bool CVideoImportRepository::updateImport(const CMediaImport& import)
+{
+  return m_db.SetDetailsForImport(import);
+}
+
+void CVideoImportRepository::removeImport(const CMediaImport& import)
+{
+  m_db.RemoveImport(import);
+}
+
+void CVideoImportRepository::updateLastSync(const CMediaImport& import, const CDateTime& lastSync)
+{
+  m_db.UpdateImportLastSynced(import, lastSync);
+}
diff --git a/xbmc/media/import/repositories/VideoImportRepository.h b/xbmc/media/import/repositories/VideoImportRepository.h
new file mode 100644
index 000000000000..775644262f6f
--- /dev/null
+++ b/xbmc/media/import/repositories/VideoImportRepository.h
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/repositories/GenericMediaImportRepository.h"
+#include "threads/CriticalSection.h"
+#include "video/VideoDatabase.h"
+
+#include <map>
+
+class CVideoImportRepository : public CGenericMediaImportRepository
+{
+public:
+  CVideoImportRepository() = default;
+  virtual ~CVideoImportRepository() = default;
+
+protected:
+  MediaTypes getSupportedMediaTypes() const override;
+
+  bool openRepository() override { return m_db.Open(); }
+  void closeRepository() override { m_db.Close(); }
+
+  std::vector<CMediaImportSource> getSources() const override;
+  int addSource(const CMediaImportSource& source) override;
+  bool updateSource(const CMediaImportSource& source) override;
+  void removeSource(const CMediaImportSource& source) override;
+  std::vector<CMediaImport> getImports() const override;
+  int addImport(const CMediaImport& import) override;
+  bool updateImport(const CMediaImport& import) override;
+  void removeImport(const CMediaImport& import) override;
+  void updateLastSync(const CMediaImport& import, const CDateTime& lastSync) override;
+
+  mutable CVideoDatabase m_db;
+};

From 5ea2a2a9c2ba825132b496ac83d27cf4f4d16a70 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sun, 14 Dec 2014 23:27:23 +0100
Subject: [PATCH 45/88] [database] register CVideoImportRepository and
 deinitialize databases on application exit to disable remote items

---
 xbmc/Application.cpp     |  2 ++
 xbmc/DatabaseManager.cpp | 24 ++++++++++++++++++++++--
 xbmc/DatabaseManager.h   |  7 +++++++
 3 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 3f9348416797..a019be50aa89 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2508,6 +2508,8 @@ bool CApplication::Cleanup()
     if (m_pGUI)
       m_pGUI->GetWindowManager().DestroyWindows();
 
+    CServiceBroker::GetDatabaseManager().Deinitialize();
+
     CLog::Log(LOGINFO, "unload sections");
 
     //  Shutdown as much as possible of the
diff --git a/xbmc/DatabaseManager.cpp b/xbmc/DatabaseManager.cpp
index a16deb7c9daa..7a3b147aad8a 100644
--- a/xbmc/DatabaseManager.cpp
+++ b/xbmc/DatabaseManager.cpp
@@ -11,6 +11,9 @@
 #include "ServiceBroker.h"
 #include "TextureDatabase.h"
 #include "addons/AddonDatabase.h"
+#include "media/import/MediaImportManager.h"
+#include "media/import/MediaImportSource.h"
+#include "media/import/repositories/VideoImportRepository.h"
 #include "music/MusicDatabase.h"
 #include "pvr/PVRDatabase.h"
 #include "pvr/epg/EpgDatabase.h"
@@ -23,7 +26,8 @@
 using namespace PVR;
 
 CDatabaseManager::CDatabaseManager() :
-  m_bIsUpgrading(false)
+  m_bIsUpgrading(false),
+  m_videoImportRepository(new CVideoImportRepository())
 {
   // Initialize the addon database (must be before the addon manager is init'd)
   CAddonDatabase db;
@@ -48,7 +52,12 @@ void CDatabaseManager::Initialize()
   { CViewDatabase db; UpdateDatabase(db); }
   { CTextureDatabase db; UpdateDatabase(db); }
   { CMusicDatabase db; UpdateDatabase(db, &advancedSettings->m_databaseMusic); }
-  { CVideoDatabase db; UpdateDatabase(db, &advancedSettings->m_databaseVideo); }
+  {
+    CVideoDatabase db;
+    UpdateDatabase(db, &advancedSettings->m_databaseVideo);
+    db.SetImportItemsEnabled(false);
+    CServiceBroker::GetMediaImportManager().RegisterImportRepository(m_videoImportRepository);
+  }
   { CPVRDatabase db; UpdateDatabase(db, &advancedSettings->m_databaseTV); }
   { CPVREpgDatabase db; UpdateDatabase(db, &advancedSettings->m_databaseEpg); }
 
@@ -57,6 +66,17 @@ void CDatabaseManager::Initialize()
   m_bIsUpgrading = false;
 }
 
+void CDatabaseManager::Deinitialize()
+{
+  CVideoDatabase videodb;
+  if (videodb.Open())
+    videodb.SetImportItemsEnabled(false);
+  CServiceBroker::GetMediaImportManager().UnregisterImportRepository(m_videoImportRepository);
+
+  CSingleLock lock(m_section);
+  m_dbStatus.clear();
+}
+
 bool CDatabaseManager::CanOpen(const std::string &name)
 {
   CSingleLock lock(m_section);
diff --git a/xbmc/DatabaseManager.h b/xbmc/DatabaseManager.h
index 0fb10d24487c..d504d33011df 100644
--- a/xbmc/DatabaseManager.h
+++ b/xbmc/DatabaseManager.h
@@ -8,6 +8,7 @@
 
 #pragma once
 
+#include "media/import/IMediaImportRepository.h"
 #include "threads/CriticalSection.h"
 
 #include <atomic>
@@ -38,6 +39,10 @@ class CDatabaseManager
    */
   void Initialize();
 
+  /*! \brief Deinitialize the database manager
+   */
+  void Deinitialize();
+
   /*! \brief Check whether we can open a database.
 
    Checks whether the database has been updated correctly, if so returns true.
@@ -62,4 +67,6 @@ class CDatabaseManager
 
   CCriticalSection            m_section;     ///< Critical section protecting m_dbStatus.
   std::map<std::string, DB_STATUS> m_dbStatus;    ///< Our database status map.
+
+  MediaImportRepositoryPtr m_videoImportRepository;
 };

From 4ff524bfa68bd92377905da1761ca0d5a626e4a6 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Tue, 17 Dec 2013 09:47:11 +0100
Subject: [PATCH 46/88] [filesystem] add CMediaImportDirectory for import://
 paths

---
 .../resources/strings.po                      |  40 +++
 xbmc/filesystem/CMakeLists.txt                |   2 +
 xbmc/filesystem/DirectoryFactory.cpp          |   2 +
 xbmc/filesystem/MediaImportDirectory.cpp      | 228 ++++++++++++++++++
 xbmc/filesystem/MediaImportDirectory.h        |  63 +++++
 5 files changed, 335 insertions(+)
 create mode 100644 xbmc/filesystem/MediaImportDirectory.cpp
 create mode 100644 xbmc/filesystem/MediaImportDirectory.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index a095ee32e581..82dd9c3e65a8 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -22220,6 +22220,7 @@ msgid "Removing {:s}..."
 msgstr ""
 
 #. (container title): (media item title)
+#: xbmc/filesystem/MediaImportDirectory.cpp
 #: xbmc/media/import/handler/EpisodeImportHandler.cpp
 #: xbmc/media/import/handler/SeasonImportHandler.cpp
 msgctxt "#39565"
@@ -22239,3 +22240,42 @@ msgstr ""
 msgctxt "#39569"
 msgid "Cleaning up {:s} from {:s}..."
 msgstr ""
+
+# empty strings from id 39570 to 39572
+
+#. Title of the node showing all available media providers
+#: xbmc/filesystem/MediaImportDirectory.cpp
+msgctxt "#39573"
+msgid "All media providers"
+msgstr ""
+
+#. Title of the node showing all active media providers
+#: xbmc/filesystem/MediaImportDirectory.cpp
+msgctxt "#39574"
+msgid "Active media providers"
+msgstr ""
+
+#. Title of the node showing all inactive media providers
+#: xbmc/filesystem/MediaImportDirectory.cpp
+msgctxt "#39575"
+msgid "Inactive media providers"
+msgstr ""
+
+#. Label of the state of an active media provider
+#: xbmc/filesystem/MediaImportDirectory.cpp
+msgctxt "#39576"
+msgid "Active"
+msgstr ""
+
+#. Label of the state of an inactive media provider
+#: xbmc/filesystem/MediaImportDirectory.cpp
+msgctxt "#39577"
+msgid "Inactive"
+msgstr ""
+
+# strings from id 39578 to 39599 reserved for media import
+
+#: xbmc/filesystem/MediaImportDirectory.cpp
+msgctxt "#39600"
+msgid "Media providers"
+msgstr ""
diff --git a/xbmc/filesystem/CMakeLists.txt b/xbmc/filesystem/CMakeLists.txt
index 78aa59b298fd..4afff1c9de92 100644
--- a/xbmc/filesystem/CMakeLists.txt
+++ b/xbmc/filesystem/CMakeLists.txt
@@ -24,6 +24,7 @@ set(SOURCES AddonsDirectory.cpp
             IFile.cpp
             ImageFile.cpp
             LibraryDirectory.cpp
+            MediaImportDirectory.cpp
             MultiPathDirectory.cpp
             MultiPathFile.cpp
             MusicDatabaseDirectory.cpp
@@ -88,6 +89,7 @@ set(HEADERS AddonsDirectory.h
             IFileTypes.h
             ImageFile.h
             LibraryDirectory.h
+            MediaImportDirectory.h
             MultiPathDirectory.h
             MultiPathFile.h
             MusicDatabaseDirectory.h
diff --git a/xbmc/filesystem/DirectoryFactory.cpp b/xbmc/filesystem/DirectoryFactory.cpp
index 4e5d373964fe..92a72d4fc336 100644
--- a/xbmc/filesystem/DirectoryFactory.cpp
+++ b/xbmc/filesystem/DirectoryFactory.cpp
@@ -18,6 +18,7 @@
 #include "MusicSearchDirectory.h"
 #include "VideoDatabaseDirectory.h"
 #include "FavouritesDirectory.h"
+#include "MediaImportDirectory.h"
 #include "LibraryDirectory.h"
 #include "EventsDirectory.h"
 #include "AddonsDirectory.h"
@@ -152,6 +153,7 @@ IDirectory* CDirectoryFactory::Create(const CURL& url)
   if (url.IsProtocol("musicsearch")) return new CMusicSearchDirectory();
   if (url.IsProtocol("videodb")) return new CVideoDatabaseDirectory();
   if (url.IsProtocol("library")) return new CLibraryDirectory();
+  if (url.IsProtocol("import")) return new CMediaImportDirectory();
   if (url.IsProtocol("favourites")) return new CFavouritesDirectory();
 #if defined(TARGET_ANDROID)
   if (url.IsProtocol("androidapp")) return new CAndroidAppDirectory();
diff --git a/xbmc/filesystem/MediaImportDirectory.cpp b/xbmc/filesystem/MediaImportDirectory.cpp
new file mode 100644
index 000000000000..b2eb448c054a
--- /dev/null
+++ b/xbmc/filesystem/MediaImportDirectory.cpp
@@ -0,0 +1,228 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportDirectory.h"
+
+#include "DatabaseManager.h"
+#include "DbUrl.h"
+#include "FileItem.h"
+#include "ServiceBroker.h"
+#include "filesystem/Directory.h"
+#include "guilib/LocalizeStrings.h"
+#include "media/MediaType.h"
+#include "media/import/IMediaImportRepository.h"
+#include "media/import/MediaImportManager.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "video/VideoDbUrl.h"
+
+using namespace std;
+using namespace XFILE;
+
+CMediaImportDirectory::CMediaImportDirectory(void)
+{
+}
+
+CMediaImportDirectory::~CMediaImportDirectory(void)
+{
+}
+
+bool CMediaImportDirectory::GetDirectory(const CURL& url, CFileItemList& items)
+{
+  const std::string& strPath = url.Get();
+  const auto& hostname = url.GetHostName();
+  if (hostname.empty())
+  {
+    // All
+    if (CServiceBroker::GetMediaImportManager().HasSources())
+    {
+      {
+        CFileItemPtr item(new CFileItem(URIUtils::AddFileToFolder(strPath, "all"), true));
+        item->SetLabel(g_localizeStrings.Get(39573));
+        item->SetSpecialSort(SortSpecialOnTop);
+        items.Add(item);
+      }
+
+      // Active
+      if (CServiceBroker::GetMediaImportManager().HasSources(true))
+      {
+        CFileItemPtr item(new CFileItem(URIUtils::AddFileToFolder(strPath, "active"), true));
+        item->SetLabel(g_localizeStrings.Get(39574));
+        items.Add(item);
+      }
+
+      // Inactive
+      if (CServiceBroker::GetMediaImportManager().HasSources(false))
+      {
+        CFileItemPtr item(new CFileItem(URIUtils::AddFileToFolder(strPath, "inactive"), true));
+        item->SetLabel(g_localizeStrings.Get(39575));
+        items.Add(item);
+      }
+    }
+
+    items.SetLabel(g_localizeStrings.Get(39600));
+    return true;
+  }
+  else
+  {
+    std::string sourceID;
+    if (hostname == "all" || hostname == "active" || hostname == "inactive")
+    {
+      std::string filename = url.GetFileName();
+      URIUtils::RemoveSlashAtEnd(filename);
+      if (filename.empty())
+      {
+        std::vector<CMediaImportSource> sources;
+        if (hostname == "all")
+        {
+          items.SetLabel(g_localizeStrings.Get(39573));
+          sources = CServiceBroker::GetMediaImportManager().GetSources();
+        }
+        else
+        {
+          bool activeOnly = hostname == "active";
+          if (activeOnly)
+            items.SetLabel(g_localizeStrings.Get(39574));
+          else
+            items.SetLabel(g_localizeStrings.Get(39575));
+
+          sources = CServiceBroker::GetMediaImportManager().GetSources(activeOnly);
+        }
+
+        HandleSources(strPath, sources, items);
+        return true;
+      }
+      else
+        sourceID = filename;
+    }
+    else
+      sourceID = hostname;
+
+    if (sourceID.empty())
+      return false;
+
+    URIUtils::RemoveSlashAtEnd(sourceID);
+    if (sourceID.find('/') != std::string::npos)
+      return false;
+
+    sourceID = CURL::Decode(sourceID);
+    CMediaImportSource source(sourceID);
+    if (!CServiceBroker::GetMediaImportManager().GetSource(sourceID, source))
+      return false;
+
+    items.SetLabel(source.GetFriendlyName());
+    const auto imports = CServiceBroker::GetMediaImportManager().GetImportsBySource(sourceID);
+    HandleImports(strPath, imports, items);
+    return true;
+  }
+
+  return false;
+}
+
+void CMediaImportDirectory::HandleSources(const std::string& strPath,
+                                          const std::vector<CMediaImportSource>& sources,
+                                          CFileItemList& items)
+{
+  for (std::vector<CMediaImportSource>::const_iterator itSource = sources.begin();
+       itSource != sources.end(); ++itSource)
+  {
+    CFileItemPtr item = FileItemFromMediaImportSource(*itSource, strPath);
+    if (item != NULL)
+      items.Add(item);
+  }
+
+  items.SetContent("sources");
+}
+
+CFileItemPtr CMediaImportDirectory::FileItemFromMediaImportSource(const CMediaImportSource& source,
+                                                                  const std::string& basePath)
+{
+  if (source.GetIdentifier().empty() || source.GetFriendlyName().empty())
+    return CFileItemPtr();
+
+  // prepare the path
+  std::string path = basePath + CURL::Encode(source.GetIdentifier());
+  URIUtils::AddSlashAtEnd(path);
+
+  CFileItemPtr item(new CFileItem(path, true));
+  item->SetLabel(source.GetFriendlyName());
+  item->m_dateTime = source.GetLastSynced();
+
+  if (!source.GetIconUrl().empty())
+    item->SetArt("thumb", source.GetIconUrl());
+
+  item->SetProperty(PROPERTY_SOURCE_IDENTIFIER, source.GetIdentifier());
+  item->SetProperty(PROPERTY_SOURCE_NAME, source.GetFriendlyName());
+  item->SetProperty(PROPERTY_SOURCE_BASEPATH, source.GetBasePath());
+  item->SetProperty(PROPERTY_SOURCE_ISACTIVE, source.IsActive());
+  item->SetProperty(PROPERTY_SOURCE_ISACTIVE_LABEL, source.IsActive()
+                                                        ? g_localizeStrings.Get(39576)
+                                                        : g_localizeStrings.Get(39577));
+  item->SetProperty(PROPERTY_SOURCE_ISREADY, source.IsReady());
+
+  return item;
+}
+
+void CMediaImportDirectory::HandleImports(const std::string& strPath,
+                                          const std::vector<CMediaImport>& imports,
+                                          CFileItemList& items,
+                                          bool bySource /* = false */)
+{
+  for (std::vector<CMediaImport>::const_iterator itImport = imports.begin();
+       itImport != imports.end(); ++itImport)
+  {
+    CFileItemPtr item = FileItemFromMediaImport(*itImport, strPath, bySource);
+    if (item != NULL)
+      items.Add(item);
+  }
+
+  items.SetContent("imports");
+}
+
+CFileItemPtr CMediaImportDirectory::FileItemFromMediaImport(const CMediaImport& import,
+                                                            const std::string& basePath,
+                                                            bool bySource /* = false */)
+{
+  if (import.GetPath().empty() || import.GetMediaTypes().empty())
+    return CFileItemPtr();
+
+  const CMediaImportSource& source = import.GetSource();
+
+  CURL url(URIUtils::AddFileToFolder(basePath, CURL::Encode(import.GetPath())));
+  std::string mediaTypes = CMediaTypes::Join(import.GetMediaTypes());
+  url.SetOption("mediatypes", mediaTypes);
+  std::string path = url.Get();
+  std::string mediaTypesLabel = CMediaTypes::ToLabel(import.GetMediaTypes());
+  std::string label = mediaTypesLabel;
+  if (!bySource)
+    label = StringUtils::Format(g_localizeStrings.Get(39565).c_str(),
+                                source.GetFriendlyName().c_str(), label.c_str());
+
+  CFileItemPtr item(new CFileItem(path, false));
+  item->SetLabel(label);
+  item->m_dateTime = import.GetLastSynced();
+
+  if (!source.GetIconUrl().empty())
+    item->SetArt("thumb", source.GetIconUrl());
+
+  item->SetProperty(PROPERTY_IMPORT_PATH, import.GetPath());
+  item->SetProperty(PROPERTY_IMPORT_MEDIATYPES, mediaTypes);
+  item->SetProperty(PROPERTY_IMPORT_NAME,
+                    StringUtils::Format(g_localizeStrings.Get(39565).c_str(),
+                                        source.GetFriendlyName().c_str(), mediaTypesLabel.c_str()));
+  item->SetProperty(PROPERTY_SOURCE_IDENTIFIER, source.GetIdentifier());
+  item->SetProperty(PROPERTY_SOURCE_NAME, source.GetFriendlyName());
+  item->SetProperty(PROPERTY_SOURCE_BASEPATH, source.GetBasePath());
+  item->SetProperty(PROPERTY_SOURCE_ISACTIVE, source.IsActive());
+  item->SetProperty(PROPERTY_SOURCE_ISACTIVE_LABEL, source.IsActive()
+                                                        ? g_localizeStrings.Get(39576)
+                                                        : g_localizeStrings.Get(39577));
+  item->SetProperty(PROPERTY_SOURCE_ISREADY, source.IsReady());
+
+  return item;
+}
diff --git a/xbmc/filesystem/MediaImportDirectory.h b/xbmc/filesystem/MediaImportDirectory.h
new file mode 100644
index 000000000000..5e472ce11b2a
--- /dev/null
+++ b/xbmc/filesystem/MediaImportDirectory.h
@@ -0,0 +1,63 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "FileItem.h"
+#include "filesystem/IDirectory.h"
+#include "media/MediaType.h"
+
+#include <string>
+#include <vector>
+
+const std::string PROPERTY_SOURCE_IDENTIFIER = "Source.ID";
+const std::string PROPERTY_SOURCE_NAME = "Source.Name";
+const std::string PROPERTY_SOURCE_PROTOCOL = "Source.Protocol";
+const std::string PROPERTY_SOURCE_BASEPATH = "Source.BasePath";
+const std::string PROPERTY_SOURCE_MEDIATYPES_LABEL = "Source.MediaTypesLabel";
+const std::string PROPERTY_SOURCE_ISACTIVE = "Source.Active";
+const std::string PROPERTY_SOURCE_ISACTIVE_LABEL = "Source.ActiveLabel";
+const std::string PROPERTY_SOURCE_ISREADY = "Source.Ready";
+const std::string PROPERTY_IMPORT_PATH = "Import.Path";
+const std::string PROPERTY_IMPORT_NAME = "Import.Name";
+const std::string PROPERTY_IMPORT_MEDIATYPES = "Import.MediaTypes";
+
+class CMediaImport;
+class CMediaImportSource;
+class IMediaImportRepository;
+
+namespace XFILE
+{
+class CMediaImportDirectory : public IDirectory
+{
+public:
+  CMediaImportDirectory();
+  virtual ~CMediaImportDirectory();
+
+  virtual bool GetDirectory(const CURL& url, CFileItemList& items);
+  virtual bool Create(const CURL& url) { return true; }
+  virtual bool Exists(const CURL& url) { return true; }
+  virtual bool IsAllowed(const CURL& url) const { return true; };
+
+  static CFileItemPtr FileItemFromMediaImportSource(const CMediaImportSource& source,
+                                                    const std::string& basePath);
+  static CFileItemPtr FileItemFromMediaImport(const CMediaImport& import,
+                                              const std::string& basePath,
+                                              bool bySource = false);
+
+private:
+  static void HandleSources(const std::string& strPath,
+                            const std::vector<CMediaImportSource>& sources,
+                            CFileItemList& items);
+
+  static void HandleImports(const std::string& strPath,
+                            const std::vector<CMediaImport>& imports,
+                            CFileItemList& items,
+                            bool bySource = false);
+};
+} // namespace XFILE

From b56487b88155de316ed5dcf5890f4a2211bb17d3 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 30 Oct 2016 13:15:55 +0100
Subject: [PATCH 47/88] [events] CGUIWindowEventLog: add context menu button
 for executing an event's associated action

---
 xbmc/dialogs/GUIDialogContextMenu.h       | 1 +
 xbmc/events/windows/GUIWindowEventLog.cpp | 6 ++++++
 2 files changed, 7 insertions(+)

diff --git a/xbmc/dialogs/GUIDialogContextMenu.h b/xbmc/dialogs/GUIDialogContextMenu.h
index f6bac6328d4c..c57cf134a259 100644
--- a/xbmc/dialogs/GUIDialogContextMenu.h
+++ b/xbmc/dialogs/GUIDialogContextMenu.h
@@ -91,6 +91,7 @@ enum CONTEXT_BUTTON { CONTEXT_BUTTON_CANCELLED = 0,
                       CONTEXT_BUTTON_HELP,
                       CONTEXT_BUTTON_PLAY_NEXT,
                       CONTEXT_BUTTON_NAVIGATE,
+                      CONTEXT_BUTTON_EXECUTE,
                     };
 
 class CContextButtons : public std::vector< std::pair<size_t, std::string> >
diff --git a/xbmc/events/windows/GUIWindowEventLog.cpp b/xbmc/events/windows/GUIWindowEventLog.cpp
index 01f95a2fe847..75cfa72e9c48 100644
--- a/xbmc/events/windows/GUIWindowEventLog.cpp
+++ b/xbmc/events/windows/GUIWindowEventLog.cpp
@@ -146,6 +146,9 @@ void CGUIWindowEventLog::GetContextButtons(int itemNumber, CContextButtons &butt
   if (eventPtr == nullptr)
     return;
 
+  if (eventPtr->CanExecute())
+    buttons.Add(CONTEXT_BUTTON_EXECUTE, eventPtr->GetExecutionLabel());
+
   buttons.Add(CONTEXT_BUTTON_DELETE, g_localizeStrings.Get(1210));
 }
 
@@ -163,6 +166,9 @@ bool CGUIWindowEventLog::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
   case CONTEXT_BUTTON_DELETE:
     return OnDelete(item);
 
+  case CONTEXT_BUTTON_EXECUTE:
+    return OnExecute(item);
+
   default:
     break;
   }

From 50131959fca39916e63bd0f4404847a0890760d6 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Mon, 14 Sep 2015 10:33:48 +0200
Subject: [PATCH 48/88] [events] add CMediaImportEvent and use it for
 added/removed media providers, media imports and synchronisations

---
 .../resources/strings.po                      |  55 ++++++++-
 xbmc/events/CMakeLists.txt                    |   2 +
 xbmc/events/MediaImportEvent.cpp              | 107 ++++++++++++++++++
 xbmc/events/MediaImportEvent.h                |  57 ++++++++++
 xbmc/media/import/MediaImportManager.cpp      |  33 +++++-
 5 files changed, 246 insertions(+), 8 deletions(-)
 create mode 100644 xbmc/events/MediaImportEvent.cpp
 create mode 100644 xbmc/events/MediaImportEvent.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 82dd9c3e65a8..ea6c244dbdc2 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -22176,6 +22176,33 @@ msgstr ""
 
 # empty strings from id 39537 to 39549 are reserved for media import settings
 
+#: xbmc/media/import/MediaImportManager.cpp
+msgctxt "#39550"
+msgid "New media provider detected"
+msgstr ""
+
+#: xbmc/media/import/MediaImportManager.cpp
+msgctxt "#39551"
+msgid "Media provider removed"
+msgstr ""
+
+#: xbmc/events/MediaImportEvent.cpp
+msgctxt "#39552"
+msgid "Add imports"
+msgstr ""
+
+#: xbmc/media/import/MediaImportManager.cpp
+msgctxt "#39553"
+msgid "Synchronisation failed"
+msgstr ""
+
+#: xbmc/media/import/MediaImportManager.cpp
+msgctxt "#39554"
+msgid "Synchronisation successful"
+msgstr ""
+
+# empty strings from id 39555 to 39557
+
 #. Retrieving media items from (media provider name)
 #: xbmc/media/import/task/MediaImportImportItemsRetrievalTask.cpp
 #: xbmc/media/import/task/MediaImportLocalItemsRetrievalTask.cpp
@@ -22220,6 +22247,7 @@ msgid "Removing {:s}..."
 msgstr ""
 
 #. (container title): (media item title)
+#: xbmc/events/MediaImportEvent.cpp
 #: xbmc/filesystem/MediaImportDirectory.cpp
 #: xbmc/media/import/handler/EpisodeImportHandler.cpp
 #: xbmc/media/import/handler/SeasonImportHandler.cpp
@@ -22233,7 +22261,12 @@ msgctxt "#39566"
 msgid "Removing import of {:s} from {:s}..."
 msgstr ""
 
-# empty strings from id 39567 to 39568
+#: xbmc/media/import/MediaImportManager.cpp
+msgctxt "#39567"
+msgid "New import added"
+msgstr ""
+
+# empty string id 39568
 
 #. Cleaning up (media type plural) from (media provider name)...
 #: xbmc/media/import/task/MediaImportCleanupTask.cpp
@@ -22273,9 +22306,27 @@ msgctxt "#39577"
 msgid "Inactive"
 msgstr ""
 
-# strings from id 39578 to 39599 reserved for media import
+#: xbmc/media/import/MediaImportManager.cpp
+msgctxt "#39578"
+msgid "Removal failed"
+msgstr ""
+
+#: xbmc/media/import/MediaImportManager.cpp
+msgctxt "#39579"
+msgid "Removal successful"
+msgstr ""
+
+# strings from id 39580 to 39599 reserved for media import
 
 #: xbmc/filesystem/MediaImportDirectory.cpp
 msgctxt "#39600"
 msgid "Media providers"
 msgstr ""
+
+# empty string ids from 39601 to 39606
+
+#. Context button label to synchronise a media provider/import
+#: xbmc/events/MediaImportEvent.cpp
+msgctxt "#39607"
+msgid "Synchronise"
+msgstr ""
diff --git a/xbmc/events/CMakeLists.txt b/xbmc/events/CMakeLists.txt
index 1a490e0254bd..e1a7bdfb3d84 100644
--- a/xbmc/events/CMakeLists.txt
+++ b/xbmc/events/CMakeLists.txt
@@ -3,6 +3,7 @@ set(SOURCES AddonEvent.cpp
             BaseEvent.cpp
             EventLog.cpp
             EventLogManager.cpp
+            MediaImportEvent.cpp
             MediaLibraryEvent.cpp)
 
 set(HEADERS AddonEvent.h
@@ -11,6 +12,7 @@ set(HEADERS AddonEvent.h
             EventLog.h
             EventLogManager.h
             IEvent.h
+            MediaImportEvent.h
             MediaLibraryEvent.h
             NotificationEvent.h
             UniqueEvent.h)
diff --git a/xbmc/events/MediaImportEvent.cpp b/xbmc/events/MediaImportEvent.cpp
new file mode 100644
index 000000000000..b8e4b8e52700
--- /dev/null
+++ b/xbmc/events/MediaImportEvent.cpp
@@ -0,0 +1,107 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImportEvent.h"
+
+#include "ServiceBroker.h"
+#include "URL.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "guilib/WindowIDs.h"
+#include "media/import/MediaImportManager.h"
+#include "utils/StringUtils.h"
+
+CMediaImportSourceEvent::CMediaImportSourceEvent(const CMediaImportSource& source,
+                                                 const CVariant& description,
+                                                 EventLevel level /* = EventLevel::Information */)
+  : CMediaImportSourceEvent(source, description, false, level)
+{
+}
+
+CMediaImportSourceEvent::CMediaImportSourceEvent(const CMediaImportSource& source,
+                                                 const CVariant& description,
+                                                 bool removed,
+                                                 EventLevel level /* = EventLevel::Information */)
+  : CUniqueEvent(
+        source.GetFriendlyName(), description, source.GetIconUrl(), CVariant{removed}, level),
+    m_source(source)
+{
+}
+
+std::string CMediaImportSourceEvent::GetExecutionLabel() const
+{
+  std::string executionLabel = CUniqueEvent::GetExecutionLabel();
+  if (!executionLabel.empty())
+    return executionLabel;
+
+  return g_localizeStrings.Get(39552);
+}
+
+bool CMediaImportSourceEvent::CanExecute() const
+{
+  return !m_details.isBoolean() || !m_details.asBoolean();
+}
+
+bool CMediaImportSourceEvent::Execute() const
+{
+  if (!CanExecute())
+    return false;
+
+  std::vector<std::string> params;
+  params.push_back(
+      StringUtils::Format("import://%s/", CURL::Encode(m_source.GetIdentifier()).c_str()));
+  params.push_back("return");
+  CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(WINDOW_MEDIASOURCE_BROWSER, params);
+  return true;
+}
+
+CMediaImportEvent::CMediaImportEvent(const CMediaImport& import,
+                                     const CVariant& description,
+                                     EventLevel level /* = EventLevel::Information */)
+  : CMediaImportEvent(import, description, false, level)
+{
+}
+
+CMediaImportEvent::CMediaImportEvent(const CMediaImport& import,
+                                     const CVariant& description,
+                                     bool removed,
+                                     EventLevel level /* = EventLevel::Information */)
+  : CUniqueEvent(StringUtils::Format(g_localizeStrings.Get(39565).c_str(),
+                                     import.GetSource().GetFriendlyName().c_str(),
+                                     CMediaTypes::ToLabel(import.GetMediaTypes()).c_str()),
+                 description,
+                 import.GetSource().GetIconUrl(),
+                 CVariant{removed},
+                 level),
+    m_import(import)
+{
+}
+
+std::string CMediaImportEvent::GetExecutionLabel() const
+{
+  std::string executionLabel = CUniqueEvent::GetExecutionLabel();
+  if (!executionLabel.empty())
+    return executionLabel;
+
+  return g_localizeStrings.Get(39607);
+}
+
+bool CMediaImportEvent::CanExecute() const
+{
+  return !m_details.isBoolean() || !m_details.asBoolean();
+}
+
+bool CMediaImportEvent::Execute() const
+{
+  if (!CanExecute())
+    return false;
+
+  return CServiceBroker::GetMediaImportManager().Import(m_import.GetPath(),
+                                                        m_import.GetMediaTypes());
+}
diff --git a/xbmc/events/MediaImportEvent.h b/xbmc/events/MediaImportEvent.h
new file mode 100644
index 000000000000..9ae96c7163f5
--- /dev/null
+++ b/xbmc/events/MediaImportEvent.h
@@ -0,0 +1,57 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "events/UniqueEvent.h"
+#include "media/import/MediaImport.h"
+#include "media/import/MediaImportSource.h"
+
+class CMediaImportSourceEvent : public CUniqueEvent
+{
+public:
+  CMediaImportSourceEvent(const CMediaImportSource& source,
+                          const CVariant& description,
+                          EventLevel level = EventLevel::Information);
+  CMediaImportSourceEvent(const CMediaImportSource& source,
+                          const CVariant& description,
+                          bool removed,
+                          EventLevel level = EventLevel::Information);
+  virtual ~CMediaImportSourceEvent() {}
+
+  virtual const char* GetType() const override { return "MediaImportSourceEvent"; }
+  virtual std::string GetExecutionLabel() const override;
+
+  virtual bool CanExecute() const override;
+  virtual bool Execute() const override;
+
+protected:
+  CMediaImportSource m_source;
+};
+
+class CMediaImportEvent : public CUniqueEvent
+{
+public:
+  CMediaImportEvent(const CMediaImport& import,
+                    const CVariant& description,
+                    EventLevel level = EventLevel::Information);
+  CMediaImportEvent(const CMediaImport& import,
+                    const CVariant& description,
+                    bool removed,
+                    EventLevel level = EventLevel::Information);
+  virtual ~CMediaImportEvent() {}
+
+  virtual const char* GetType() const override { return "MediaImportEvent"; }
+  virtual std::string GetExecutionLabel() const override;
+
+  virtual bool CanExecute() const override;
+  virtual bool Execute() const override;
+
+protected:
+  CMediaImport m_import;
+};
diff --git a/xbmc/media/import/MediaImportManager.cpp b/xbmc/media/import/MediaImportManager.cpp
index db8cdd1b7f53..bc9db5d43203 100644
--- a/xbmc/media/import/MediaImportManager.cpp
+++ b/xbmc/media/import/MediaImportManager.cpp
@@ -13,6 +13,8 @@
 #include "LibraryQueue.h"
 #include "ServiceBroker.h"
 #include "dialogs/GUIDialogProgress.h"
+#include "events/EventLog.h"
+#include "events/MediaImportEvent.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIWindowManager.h"
 #include "interfaces/AnnouncementManager.h"
@@ -1611,6 +1613,9 @@ bool CMediaImportManager::AddImport(const CMediaImport& import)
   if (!success)
     return false;
 
+  if (added)
+    CServiceBroker::GetEventLog().Add(EventPtr(new CMediaImportEvent(import, 39567)));
+
   return true;
 }
 
@@ -2011,6 +2016,9 @@ void CMediaImportManager::OnSourceJobComplete(const CMediaImportSourceJobBase* s
     }
     OnSourceAdded(source);
 
+    CServiceBroker::GetEventLog().AddWithNotification(
+        EventPtr(new CMediaImportSourceEvent(source, 39550)));
+
     // check if the source should also be activated
     if (sourceRegistrationTask->ActivateSource())
     {
@@ -2126,6 +2134,9 @@ void CMediaImportManager::OnJobComplete(unsigned int jobID, bool success, CJob*
 
         OnSourceRemoved(source);
         m_logger->debug("source {} removed", source);
+
+        CServiceBroker::GetEventLog().Add(
+            EventPtr(new CMediaImportSourceEvent(source, 39551, true)));
       }
     }
   }
@@ -2178,14 +2189,18 @@ bool CMediaImportManager::OnTaskComplete(bool success, const IMediaImportTask* t
   }
   else if (taskType == MediaImportTaskType::Synchronisation)
   {
-    if (!success)
-      return false;
-
     const auto* synchronisationTask = dynamic_cast<const CMediaImportSynchronisationTask*>(task);
     if (synchronisationTask == nullptr)
       return false;
 
     auto import = synchronisationTask->GetImport();
+    if (!success)
+    {
+      CServiceBroker::GetEventLog().Add(
+          EventPtr(new CMediaImportEvent(import, 39553, EventLevel::Error)));
+      return false;
+    }
+
     // early return here if this is not the last media type to be synchronised to avoid multiple updates
     if (synchronisationTask->GetMediaType() != import.GetMediaTypes().back())
       return true;
@@ -2203,18 +2218,22 @@ bool CMediaImportManager::OnTaskComplete(bool success, const IMediaImportTask* t
     {
       OnSourceUpdated(import.GetSource());
       OnImportUpdated(import);
+      CServiceBroker::GetEventLog().Add(EventPtr(new CMediaImportEvent(import, 39554)));
     }
   }
   else if (taskType == MediaImportTaskType::Removal)
   {
-    if (!success)
-      return false;
-
     const auto* removalTask = dynamic_cast<const CMediaImportRemovalTask*>(task);
     if (removalTask == nullptr)
       return false;
 
     const auto& import = removalTask->GetImport();
+    if (!success)
+    {
+      CServiceBroker::GetEventLog().Add(
+          EventPtr(new CMediaImportEvent(import, 39578, true, EventLevel::Error)));
+      return false;
+    }
 
     // remove the import from the import repositories
     {
@@ -2225,6 +2244,8 @@ bool CMediaImportManager::OnTaskComplete(bool success, const IMediaImportTask* t
 
     // let everyone know that the import has been removed
     OnImportRemoved(import);
+
+    CServiceBroker::GetEventLog().Add(EventPtr(new CMediaImportEvent(import, 39579, true)));
   }
   else if (taskType == MediaImportTaskType::Update)
   {

From 71aa88b814ade2a11b1a1dcdb507f671d92971ea Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 30 Oct 2016 11:53:06 +0100
Subject: [PATCH 49/88] [network] upnp: improve metadata reading/writing and
 add support for tvshows, seasons and musicvideos

---
 xbmc/filesystem/UPnPDirectory.cpp  |  27 ++--
 xbmc/network/upnp/UPnPInternal.cpp | 150 +++++++++++++-------
 xbmc/network/upnp/UPnPServer.cpp   | 221 +++++++++++++++++++----------
 xbmc/network/upnp/UPnPServer.h     |   2 +
 4 files changed, 258 insertions(+), 142 deletions(-)

diff --git a/xbmc/filesystem/UPnPDirectory.cpp b/xbmc/filesystem/UPnPDirectory.cpp
index 9dc8ff72e332..230a812c79bb 100644
--- a/xbmc/filesystem/UPnPDirectory.cpp
+++ b/xbmc/filesystem/UPnPDirectory.cpp
@@ -41,19 +41,20 @@ static std::string GetContentMapping(NPT_String& objectClass)
         const char* Content;
     };
     static const SClassMapping mapping[] = {
-          { "object.item.videoItem.videoBroadcast", "episodes"      }
-        , { "object.item.videoItem.musicVideoClip", "musicvideos"  }
-        , { "object.item.videoItem"               , "movies"       }
-        , { "object.item.audioItem.musicTrack"    , "songs"        }
-        , { "object.item.audioItem"               , "songs"        }
-        , { "object.item.imageItem.photo"         , "photos"       }
-        , { "object.item.imageItem"               , "photos"       }
-        , { "object.container.album.videoAlbum"   , "tvshows"      }
-        , { "object.container.album.musicAlbum"   , "albums"       }
-        , { "object.container.album.photoAlbum"   , "photos"       }
-        , { "object.container.album"              , "albums"       }
-        , { "object.container.person"             , "artists"      }
-        , { NULL                                  , NULL           }
+          { "object.item.videoItem.videoBroadcast"                  , "episodes"      }
+        , { "object.item.videoItem.musicVideoClip"                  , "musicvideos"  }
+        , { "object.item.videoItem"                                 , "movies"       }
+        , { "object.item.audioItem.musicTrack"                      , "songs"        }
+        , { "object.item.audioItem"                                 , "songs"        }
+        , { "object.item.imageItem.photo"                           , "photos"       }
+        , { "object.item.imageItem"                                 , "photos"       }
+        , { "object.container.album.videoAlbum.videoBroadcastShow"  , "tvshows"      }
+        , { "object.container.album.videoAlbum.videoBroadcastSeason", "seasons"      }
+        , { "object.container.album.musicAlbum"                     , "albums"       }
+        , { "object.container.album.photoAlbum"                     , "photos"       }
+        , { "object.container.album"                                , "albums"       }
+        , { "object.container.person"                               , "artists"      }
+        , { NULL                                                    , NULL           }
     };
     for(const SClassMapping* map = mapping; map->ObjectClass; map++)
     {
diff --git a/xbmc/network/upnp/UPnPInternal.cpp b/xbmc/network/upnp/UPnPInternal.cpp
index 7fef33cda15d..3843bb7b6eca 100644
--- a/xbmc/network/upnp/UPnPInternal.cpp
+++ b/xbmc/network/upnp/UPnPInternal.cpp
@@ -279,17 +279,39 @@ PopulateObjectFromTag(CVideoInfoTag&         tag,
           object.m_Date = tag.GetPremiered().GetAsW3CDate().c_str();
           object.m_ReferenceID = NPT_String::Format("videodb://movies/titles/%i", tag.m_iDbId);
         } else {
-          object.m_ObjectClass.type = "object.item.videoItem.videoBroadcast";
-          object.m_Recorded.program_title  = "S" + ("0" + NPT_String::FromInteger(tag.m_iSeason)).Right(2);
-          object.m_Recorded.program_title += "E" + ("0" + NPT_String::FromInteger(tag.m_iEpisode)).Right(2);
-          object.m_Recorded.program_title += (" : " + tag.m_strTitle).c_str();
           object.m_Recorded.series_title = tag.m_strShowTitle.c_str();
-          int season = tag.m_iSeason > 1 ? tag.m_iSeason : 1;
-          object.m_Recorded.episode_number = season * 100 + tag.m_iEpisode;
-          object.m_Title = object.m_Recorded.series_title + " - " + object.m_Recorded.program_title;
-          object.m_Date = tag.m_firstAired.GetAsW3CDate().c_str();
-          if(tag.m_iSeason != -1)
-              object.m_ReferenceID = NPT_String::Format("videodb://tvshows/0/%i", tag.m_iDbId);
+
+          if (tag.m_type == MediaTypeTvShow) {
+              object.m_ObjectClass.type = "object.container.album.videoAlbum.videoBroadcastShow";
+              object.m_Title = tag.m_strTitle.c_str();
+              object.m_Recorded.episode_number = tag.m_iEpisode;
+              object.m_Recorded.episode_count = tag.m_iEpisode;
+              if (!tag.m_premiered.IsValid() && tag.GetYear() > 0)
+                  object.m_Date = CDateTime(tag.GetYear(), 1, 1, 0, 0, 0).GetAsW3CDate().c_str();
+              else
+                  object.m_Date = tag.m_premiered.GetAsW3CDate().c_str();
+              object.m_ReferenceID = NPT_String::Format("videodb://tvshows/titles/%i", tag.m_iDbId);
+          } else if (tag.m_type == MediaTypeSeason) {
+              object.m_ObjectClass.type = "object.container.album.videoAlbum.videoBroadcastSeason";
+              object.m_Title = tag.m_strTitle.c_str();
+              object.m_Recorded.episode_season = tag.m_iSeason;
+              object.m_Recorded.episode_count = tag.m_iEpisode;
+              if (!tag.m_premiered.IsValid() && tag.GetYear() > 0)
+                  object.m_Date = CDateTime(tag.GetYear(), 1, 1, 0, 0, 0).GetAsW3CDate().c_str();
+              else
+                  object.m_Date = tag.m_premiered.GetAsW3CDate().c_str();
+              object.m_ReferenceID = NPT_String::Format("videodb://tvshows/titles/%i/%i", tag.m_iIdShow, tag.m_iSeason);
+          } else {
+              object.m_ObjectClass.type = "object.item.videoItem.videoBroadcast";
+              object.m_Recorded.program_title  = "S" + ("0" + NPT_String::FromInteger(tag.m_iSeason)).Right(2);
+              object.m_Recorded.program_title += "E" + ("0" + NPT_String::FromInteger(tag.m_iEpisode)).Right(2);
+              object.m_Recorded.program_title += (" : " + tag.m_strTitle).c_str();
+              object.m_Recorded.episode_number = tag.m_iEpisode;
+              object.m_Recorded.episode_season = tag.m_iSeason;
+              object.m_Title = object.m_Recorded.series_title + " - " + object.m_Recorded.program_title;
+              object.m_ReferenceID = NPT_String::Format("videodb://tvshows/titles/%i/%i/%i", tag.m_iIdShow, tag.m_iSeason, tag.m_iDbId);
+              object.m_Date = tag.m_firstAired.GetAsW3CDate().c_str();
+          }
         }
     }
 
@@ -516,29 +538,18 @@ BuildObject(CFileItem&                    item,
                   container->m_Title   = tag.m_strTitle.c_str();
                   break;
                 case VIDEODATABASEDIRECTORY::NODE_TYPE_SEASONS:
+                  container->m_ObjectClass.type += ".album.videoAlbum.videoBroadcastSeason";
+                  if (item.HasVideoInfoTag()) {
+                      CVideoInfoTag *tag = (CVideoInfoTag*)item.GetVideoInfoTag();
+                      PopulateObjectFromTag(*tag, *container, &file_path, &resource, quirks);
+                  }
+                  break;
                 case VIDEODATABASEDIRECTORY::NODE_TYPE_TITLE_TVSHOWS:
-                  container->m_ObjectClass.type += ".album.videoAlbum";
-                  container->m_Recorded.series_title = tag.m_strShowTitle.c_str();
-                  container->m_Recorded.episode_number = tag.m_iEpisode;
-                  container->m_MiscInfo.play_count = tag.GetPlayCount();
-                  container->m_Title = tag.m_strTitle.c_str();
-                  container->m_Date = tag.GetPremiered().GetAsW3CDate().c_str();
-
-                  for (unsigned int index = 0; index < tag.m_genre.size(); index++)
-                    container->m_Affiliation.genres.Add(tag.m_genre.at(index).c_str());
-
-                  for(CVideoInfoTag::iCast it = tag.m_cast.begin();it != tag.m_cast.end();it++) {
-                      container->m_People.actors.Add(it->strName.c_str(), it->strRole.c_str());
+                  container->m_ObjectClass.type += ".album.videoAlbum.videoBroadcastShow";
+                  if (item.HasVideoInfoTag()) {
+                      CVideoInfoTag *tag = (CVideoInfoTag*)item.GetVideoInfoTag();
+                      PopulateObjectFromTag(*tag, *container, &file_path, &resource, quirks);
                   }
-
-                  for (unsigned int index = 0; index < tag.m_director.size(); index++)
-                    container->m_People.directors.Add(tag.m_director[index].c_str());
-                  for (unsigned int index = 0; index < tag.m_writingCredits.size(); index++)
-                    container->m_People.authors.Add(tag.m_writingCredits[index].c_str());
-
-                  container->m_Description.description = tag.m_strTagLine.c_str();
-                  container->m_Description.long_description = tag.m_strPlot.c_str();
-
                   break;
                 default:
                   container->m_ObjectClass.type += ".storageFolder";
@@ -781,41 +792,70 @@ PopulateTagFromObject(CVideoInfoTag&         tag,
     CDateTime date;
     date.SetFromW3CDate((const char*)object.m_Date);
 
-    if(!object.m_Recorded.program_title.IsEmpty())
+    if(!object.m_Recorded.program_title.IsEmpty() || object.m_ObjectClass.type == "object.item.videoItem.videoBroadcast")
     {
         tag.m_type = MediaTypeEpisode;
-        int episode;
-        int season;
+        tag.m_strShowTitle = object.m_Recorded.series_title;
+        if (date.IsValid())
+            tag.m_firstAired = date;
+
         int title = object.m_Recorded.program_title.Find(" : ");
-        if(sscanf(object.m_Recorded.program_title, "S%2dE%2d", &season, &episode) == 2 && title >= 0) {
+        if (title >= 0)
             tag.m_strTitle = object.m_Recorded.program_title.SubString(title + 3);
+        else
+            tag.m_strTitle = object.m_Recorded.program_title;
+
+        int episode;
+        int season;
+        if (object.m_Recorded.episode_number >= 0 && object.m_Recorded.episode_season < (NPT_UInt32)-1) {
+            tag.m_iEpisode = object.m_Recorded.episode_number;
+            tag.m_iSeason = object.m_Recorded.episode_season;
+        } else if(sscanf(object.m_Recorded.program_title, "S%2dE%2d", &season, &episode) == 2 && title >= 0) {
             tag.m_iEpisode = episode;
             tag.m_iSeason  = season;
         } else {
-            tag.m_strTitle = object.m_Recorded.program_title;
             tag.m_iSeason  = object.m_Recorded.episode_number / 100;
             tag.m_iEpisode = object.m_Recorded.episode_number % 100;
         }
-        tag.m_firstAired = date;
-    }
-    else if (!object.m_Recorded.series_title.IsEmpty()) {
-        tag.m_type= MediaTypeSeason;
-        tag.m_strTitle = object.m_Title; // because could be TV show Title, or Season 1 etc
-        tag.m_iSeason  = object.m_Recorded.episode_number / 100;
-        tag.m_iEpisode = object.m_Recorded.episode_number % 100;
-        tag.SetPremiered(date);
     }
-    else if(object.m_ObjectClass.type == "object.item.videoItem.musicVideoClip") {
-        tag.m_type = MediaTypeMusicVideo;
-        for (unsigned int index = 0; index < object.m_People.artists.GetItemCount(); index++)
-          tag.m_artist.emplace_back(object.m_People.artists.GetItem(index)->name.GetChars());
-        tag.m_strAlbum = object.m_Affiliation.album;
-    }
-    else
-    {
-        tag.m_type         = MediaTypeMovie;
-        tag.m_strTitle     = object.m_Title;
-        tag.SetPremiered(date);
+    else {
+        tag.m_strTitle = object.m_Title;
+        if (date.IsValid())
+            tag.m_premiered = date;
+
+        if (!object.m_Recorded.series_title.IsEmpty()) {
+            if (object.m_ObjectClass.type == "object.container.album.videoAlbum.videoBroadcastSeason") {
+                tag.m_type = MediaTypeSeason;
+                tag.m_iSeason = object.m_Recorded.episode_season;
+                tag.m_strShowTitle = object.m_Recorded.series_title;
+            }
+            else {
+                tag.m_type = MediaTypeTvShow;
+                tag.m_strShowTitle = object.m_Title;
+            }
+
+            if (object.m_Recorded.episode_count > 0)
+                tag.m_iEpisode = object.m_Recorded.episode_count;
+            else
+                tag.m_iEpisode = object.m_Recorded.episode_number;
+        }
+        else if(object.m_ObjectClass.type == "object.item.videoItem.musicVideoClip") {
+            tag.m_type = MediaTypeMusicVideo;
+
+            if (object.m_People.artists.GetItemCount() > 0) {
+                for (unsigned int index = 0; index < object.m_People.artists.GetItemCount(); index++)
+                    tag.m_artist.emplace_back(object.m_People.artists.GetItem(index)->name.GetChars());
+            }
+            else if (!object.m_Creator.IsEmpty() && object.m_Creator != "Unknown")
+                tag.m_artist = StringUtils::Split(object.m_Creator.GetChars(), CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_videoItemSeparator);
+            tag.m_strAlbum = object.m_Affiliation.album;
+        }
+        else
+            tag.m_type = MediaTypeMovie;
+
+        tag.m_strTitle = object.m_Title;
+        if (date.IsValid())
+            tag.SetPremiered(date);
     }
 
     for (unsigned int index = 0; index < object.m_People.publisher.GetItemCount(); index++)
diff --git a/xbmc/network/upnp/UPnPServer.cpp b/xbmc/network/upnp/UPnPServer.cpp
index e7f6890ffa89..6a5fa7f85610 100644
--- a/xbmc/network/upnp/UPnPServer.cpp
+++ b/xbmc/network/upnp/UPnPServer.cpp
@@ -353,8 +353,17 @@ CUPnPServer::Build(CFileItemPtr                  item,
                         db.GetMusicVideoInfo((const char*)path, *item->GetVideoInfoTag(), params.GetMVideoId());
                     else if (params.GetEpisodeId() >= 0 )
                         db.GetEpisodeInfo((const char*)path, *item->GetVideoInfoTag(), params.GetEpisodeId());
-                    else if (params.GetTvShowId() >= 0 )
-                        db.GetTvShowInfo((const char*)path, *item->GetVideoInfoTag(), params.GetTvShowId());
+                    else if (params.GetTvShowId() >= 0)
+                    {
+                        if (params.GetSeason() >= 0)
+                        {
+                            int idSeason = db.GetSeasonId(params.GetTvShowId(), params.GetSeason());
+                            if (idSeason >= 0)
+                                db.GetSeasonInfo(idSeason, *item->GetVideoInfoTag());
+                        }
+                        else
+                            db.GetTvShowInfo((const char*)path, *item->GetVideoInfoTag(), params.GetTvShowId());
+                    }
                 }
 
                 if (item->GetVideoInfoTag()->m_type == MediaTypeTvShow || item->GetVideoInfoTag()->m_type == MediaTypeSeason) {
@@ -848,57 +857,50 @@ CUPnPServer::OnSearchContainer(PLT_ActionReference&          action,
                   search_criteria);
 
   NPT_String id = object_id;
-  if (id.StartsWith("musicdb://"))
-  {
-    // we browse for all tracks given a genre, artist or album
-    if (NPT_String(search_criteria).Find("object.item.audioItem") >= 0)
-    {
-      if (!id.EndsWith("/"))
-        id += "/";
-      NPT_Cardinal count = id.SubString(10).Split("/").GetItemCount();
-      // remove extra empty node count
-      count = count ? count - 1 : 0;
-
-      // genre
-      if (id.StartsWith("musicdb://genres/"))
-      {
-        // all tracks of all genres
-        if (count == 1)
-          id += "-1/-1/-1/";
-        // all tracks of a specific genre
-        else if (count == 2)
-          id += "-1/-1/";
-        // all tracks of a specific genre of a specific artist
-        else if (count == 3)
-          id += "-1/";
-      }
-      else if (id.StartsWith("musicdb://artists/"))
-      {
-        // all tracks by all artists
-        if (count == 1)
-          id += "-1/-1/";
-        // all tracks of a specific artist
-        else if (count == 2)
-          id += "-1/";
+  NPT_String searchClass = NPT_String(search_criteria);
+  if (id.StartsWith("musicdb://")) {
+      // we browse for all tracks given a genre, artist or album
+      if (searchClass.Find("object.item.audioItem") >= 0) {
+          if (!id.EndsWith("/")) id += "/";
+          NPT_Cardinal count = id.SubString(10).Split("/").GetItemCount();
+          // remove extra empty node count
+          count = count?count-1:0;
+
+          // genre
+          if (id.StartsWith("musicdb://genres/")) {
+              // all tracks of all genres
+              if (count == 1)
+                  id += "-1/-1/-1/";
+              // all tracks of a specific genre
+              else if (count == 2)
+                  id += "-1/-1/";
+              // all tracks of a specific genre of a specific artist
+              else if (count == 3)
+                  id += "-1/";
+          }
+          else if (id.StartsWith("musicdb://artists/")) {
+              // all tracks by all artists
+              if (count == 1)
+                  id += "-1/-1/";
+              // all tracks of a specific artist
+              else if (count == 2)
+                  id += "-1/";
+          }
+          else if (id.StartsWith("musicdb://albums/")) {
+              // all albums ?
+              if (count == 1) id += "-1/";
+          }
       }
-      else if (id.StartsWith("musicdb://albums/"))
-      {
-        // all albums ?
-        if (count == 1)
-          id += "-1/";
-      }
-    }
-    return OnBrowseDirectChildren(action, id, filter, starting_index, requested_count,
-                                  sort_criteria, context);
-    } else if (NPT_String(search_criteria).Find("object.item.audioItem") >= 0) {
+      return OnBrowseDirectChildren(action, id, filter, starting_index, requested_count, sort_criteria, context);
+    } else if (searchClass.Find("object.item.audioItem") >= 0) {
         // look for artist, album & genre filters
-        NPT_String genre = FindSubCriteria(search_criteria, "upnp:genre");
-        NPT_String album = FindSubCriteria(search_criteria, "upnp:album");
-        NPT_String artist = FindSubCriteria(search_criteria, "upnp:artist");
+        NPT_String genre = FindSubCriteria(searchClass, "upnp:genre");
+        NPT_String album = FindSubCriteria(searchClass, "upnp:album");
+        NPT_String artist = FindSubCriteria(searchClass, "upnp:artist");
         // sonos looks for microsoft specific stuff
-        artist = artist.GetLength()?artist:FindSubCriteria(search_criteria, "microsoft:artistPerformer");
-        artist = artist.GetLength()?artist:FindSubCriteria(search_criteria, "microsoft:artistAlbumArtist");
-        artist = artist.GetLength()?artist:FindSubCriteria(search_criteria, "microsoft:authorComposer");
+        artist = artist.GetLength()?artist:FindSubCriteria(searchClass, "microsoft:artistPerformer");
+        artist = artist.GetLength()?artist:FindSubCriteria(searchClass, "microsoft:artistAlbumArtist");
+        artist = artist.GetLength()?artist:FindSubCriteria(searchClass, "microsoft:authorComposer");
 
         CMusicDatabase database;
         database.Open();
@@ -928,16 +930,16 @@ CUPnPServer::OnSearchContainer(PLT_ActionReference&          action,
 
         // browse all songs
         return OnBrowseDirectChildren(action, "musicdb://songs/", filter, starting_index, requested_count, sort_criteria, context);
-    } else if (NPT_String(search_criteria).Find("object.container.album.musicAlbum") >= 0) {
+    } else if (searchClass.Find("object.container.album.musicAlbum") >= 0) {
         // sonos filters by genre
-        NPT_String genre = FindSubCriteria(search_criteria, "upnp:genre");
+        NPT_String genre = FindSubCriteria(searchClass, "upnp:genre");
 
         // 360 hack: artist/albums using search
-        NPT_String artist = FindSubCriteria(search_criteria, "upnp:artist");
+        NPT_String artist = FindSubCriteria(searchClass, "upnp:artist");
         // sonos looks for microsoft specific stuff
-        artist = artist.GetLength()?artist:FindSubCriteria(search_criteria, "microsoft:artistPerformer");
-        artist = artist.GetLength()?artist:FindSubCriteria(search_criteria, "microsoft:artistAlbumArtist");
-        artist = artist.GetLength()?artist:FindSubCriteria(search_criteria, "microsoft:authorComposer");
+        artist = artist.GetLength()?artist:FindSubCriteria(searchClass, "microsoft:artistPerformer");
+        artist = artist.GetLength()?artist:FindSubCriteria(searchClass, "microsoft:artistAlbumArtist");
+        artist = artist.GetLength()?artist:FindSubCriteria(searchClass, "microsoft:authorComposer");
 
         CMusicDatabase database;
         database.Open();
@@ -955,9 +957,9 @@ CUPnPServer::OnSearchContainer(PLT_ActionReference&          action,
 
         // all albums
         return OnBrowseDirectChildren(action, "musicdb://albums/", filter, starting_index, requested_count, sort_criteria, context);
-    } else if (NPT_String(search_criteria).Find("object.container.person.musicArtist") >= 0) {
+    } else if (searchClass.Find("object.container.person.musicArtist") >= 0) {
         // Sonos filters by genre
-        NPT_String genre = FindSubCriteria(search_criteria, "upnp:genre");
+        NPT_String genre = FindSubCriteria(searchClass, "upnp:genre");
         if (genre.GetLength() > 0) {
             CMusicDatabase database;
             database.Open();
@@ -965,42 +967,102 @@ CUPnPServer::OnSearchContainer(PLT_ActionReference&          action,
             return OnBrowseDirectChildren(action, strPath.c_str(), filter, starting_index, requested_count, sort_criteria, context);
         }
         return OnBrowseDirectChildren(action, "musicdb://artists/", filter, starting_index, requested_count, sort_criteria, context);
-    }  else if (NPT_String(search_criteria).Find("object.container.genre.musicGenre") >= 0) {
+    } else if (searchClass.Find("object.container.genre.musicGenre") >= 0) {
         return OnBrowseDirectChildren(action, "musicdb://genres/", filter, starting_index, requested_count, sort_criteria, context);
-    } else if (NPT_String(search_criteria).Find("object.container.playlistContainer") >= 0) {
+    } else if (searchClass.Find("object.container.playlistContainer") >= 0) {
         return OnBrowseDirectChildren(action, "special://musicplaylists/", filter, starting_index, requested_count, sort_criteria, context);
-    } else if (NPT_String(search_criteria).Find("object.item.videoItem") >= 0) {
-      CFileItemList items, itemsall;
-
+    } else if (searchClass.Find("object.container.album.videoAlbum.videoBroadcastShow") >= 0) {
       CVideoDatabase database;
       if (!database.Open()) {
         action->SetError(800, "Internal Error");
         return NPT_SUCCESS;
       }
 
-      if (!database.GetMoviesNav("videodb://movies/titles/", items)) {
+      CFileItemList items;
+      if (!database.GetTvShowsByWhere("videodb://tvshows/titles/?local", CDatabase::Filter(),
+        items, SortDescription(), GetRequiredVideoDbDetails(NPT_String(filter)))) {
+        action->SetError(800, "Internal Error");
+        return NPT_SUCCESS;
+      }
+
+      items.SetPath("videodb://tvshows/titles/");
+      return BuildResponse(action, items, filter, starting_index, requested_count, sort_criteria, context, NULL);
+    } else if (searchClass.Find("object.container.album.videoAlbum.videoBroadcastSeason") >= 0) {
+      CVideoDatabase database;
+      if (!database.Open()) {
         action->SetError(800, "Internal Error");
         return NPT_SUCCESS;
       }
-      itemsall.Append(items);
-      items.Clear();
 
-      if (!database.GetEpisodesByWhere("videodb://tvshows/titles/", CDatabase::Filter(), items)) {
+      CFileItemList items;
+      if (!database.GetSeasonsByWhere("videodb://tvshows/titles/-1/?local", CDatabase::Filter(), items, true)) {
         action->SetError(800, "Internal Error");
         return NPT_SUCCESS;
       }
-      itemsall.Append(items);
-      items.Clear();
 
-      if (!database.GetMusicVideosByWhere("videodb://musicvideos/titles/", CDatabase::Filter(), items)) {
+      items.SetPath("videodb://tvshows/titles/-1/");
+      return BuildResponse(action, items, filter, starting_index, requested_count, sort_criteria, context, NULL);
+    } else if (searchClass.Find("object.item.videoItem") >= 0) {
+      CFileItemList items, allItems;
+
+      CVideoDatabase database;
+      if (!database.Open()) {
         action->SetError(800, "Internal Error");
         return NPT_SUCCESS;
       }
-      itemsall.Append(items);
-      items.Clear();
 
-      return BuildResponse(action, itemsall, filter, starting_index, requested_count, sort_criteria, context, NULL);
-  } else if (NPT_String(search_criteria).Find("object.item.imageItem") >= 0) {
+      bool allVideoItems = searchClass.Compare("object.item.videoItem") == 0;
+
+      // determine the required videodb details to be retrieved
+      int requiredVideoDbDetails = GetRequiredVideoDbDetails(NPT_String(filter));
+
+      if (allVideoItems || searchClass.Find("object.item.videoItem.movie") >= 0)
+      {
+        if (!database.GetMoviesByWhere("videodb://movies/titles/?local", CDatabase::Filter(), items, SortDescription(), requiredVideoDbDetails)) {
+          action->SetError(800, "Internal Error");
+          return NPT_SUCCESS;
+        }
+
+        allItems.Append(items);
+        items.Clear();
+
+        if (!allVideoItems)
+          allItems.SetPath("videodb://movies/titles/");
+      }
+
+      if (allVideoItems || searchClass.Find("object.item.videoItem.videoBroadcast") >= 0)
+      {
+        if (!database.GetEpisodesByWhere("videodb://tvshows/titles/?local", CDatabase::Filter(), items, true, SortDescription(), requiredVideoDbDetails)) {
+          action->SetError(800, "Internal Error");
+          return NPT_SUCCESS;
+        }
+
+        allItems.Append(items);
+        items.Clear();
+
+        if (!allVideoItems)
+          allItems.SetPath("videodb://tvshows/titles/");
+      }
+
+      if (allVideoItems || searchClass.Find("object.item.videoItem.musicVideoClip") >= 0)
+      {
+        if (!database.GetMusicVideosByWhere("videodb://musicvideos/titles/?local", CDatabase::Filter(), items, true, SortDescription(), requiredVideoDbDetails)) {
+          action->SetError(800, "Internal Error");
+          return NPT_SUCCESS;
+        }
+
+        allItems.Append(items);
+        items.Clear();
+
+        if (!allVideoItems)
+          allItems.SetPath("videodb://musicvideos/titles/");
+      }
+
+      if (allVideoItems)
+        allItems.SetPath("videodb://movies/titles/");
+
+      return BuildResponse(action, allItems, filter, starting_index, requested_count, sort_criteria, context, NULL);
+  } else if (searchClass.Find("object.item.imageItem") >= 0) {
       CFileItemList items;
       return BuildResponse(action, items, filter, starting_index, requested_count, sort_criteria, context, NULL);
   }
@@ -1251,5 +1313,16 @@ CUPnPServer::AddSubtitleUriForSecResponse(NPT_String movie_md5, NPT_String subti
   return NPT_SUCCESS;
 }
 
+int CUPnPServer::GetRequiredVideoDbDetails(const NPT_String& filter)
+{
+  int details = VideoDbDetailsRating;
+  if (filter.Find("res@resolution") >= 0 || filter.Find("res@nrAudioChannels") >= 0)
+    details |= VideoDbDetailsStream;
+  if (filter.Find("upnp:actor") >= 0)
+    details |= VideoDbDetailsCast;
+
+  return details;
+}
+
 } /* namespace UPNP */
 
diff --git a/xbmc/network/upnp/UPnPServer.h b/xbmc/network/upnp/UPnPServer.h
index b151801d5a71..01b5201e94a7 100644
--- a/xbmc/network/upnp/UPnPServer.h
+++ b/xbmc/network/upnp/UPnPServer.h
@@ -124,6 +124,8 @@ class CUPnPServer : public PLT_MediaConnect,
         return file_path.Left(index);
     }
 
+    static int GetRequiredVideoDbDetails(const NPT_String& filter);
+
     NPT_Mutex m_CacheMutex;
 
     NPT_Mutex m_FileMutex;

From 1dc8ffafcaa4d5a530909c9535d47374d4c2c8a5 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Tue, 8 Apr 2014 21:14:00 +0200
Subject: [PATCH 50/88] [network] upnp: improve methods to update metadata on a
 server

---
 xbmc/network/upnp/UPnP.cpp       | 120 +++++++++++++++++++++++++------
 xbmc/network/upnp/UPnP.h         |   2 +
 xbmc/network/upnp/UPnPServer.cpp |  12 +++-
 3 files changed, 110 insertions(+), 24 deletions(-)

diff --git a/xbmc/network/upnp/UPnP.cpp b/xbmc/network/upnp/UPnP.cpp
index 5d2bd43592fc..d7d49704aa01 100644
--- a/xbmc/network/upnp/UPnP.cpp
+++ b/xbmc/network/upnp/UPnP.cpp
@@ -218,8 +218,11 @@ class CMediaBrowser : public PLT_SyncMediaBrowser,
         }
         else {
           s_logger->debug("Marking video item {} as watched", item.GetPath());
-          return InvokeUpdateObject(item.GetPath().c_str(), "<upnp:playCount>1</upnp:playCount>",
-                                    "<upnp:playCount>0</upnp:playCount>");
+
+          std::set<std::pair<NPT_String, NPT_String> > values;
+          values.insert(std::make_pair("<upnp:playCount>1</upnp:playCount>",
+                                       "<upnp:playCount>0</upnp:playCount>"));
+          return InvokeUpdateObject(item.GetPath().c_str(), values);
         }
     }
 
@@ -230,46 +233,93 @@ class CMediaBrowser : public PLT_SyncMediaBrowser,
           return false;
         }
 
-        NPT_String curr_value;
-        NPT_String new_value;
-
+        std::set<std::pair<NPT_String, NPT_String> > values;
         if (item.GetVideoInfoTag()->GetResumePoint().timeInSeconds != bookmark.timeInSeconds) {
           s_logger->debug("Updating resume point for item {}", path);
           long time = (long)bookmark.timeInSeconds;
           if (time < 0)
             time = 0;
-          curr_value.Append(
-              NPT_String::Format("<upnp:lastPlaybackPosition>%ld</upnp:lastPlaybackPosition>",
-                                 (long)item.GetVideoInfoTag()->GetResumePoint().timeInSeconds));
-          curr_value += "<xbmc:lastPlayerState>";
-          PLT_Didl::AppendXmlEscape(curr_value,
-                                    item.GetVideoInfoTag()->GetResumePoint().playerState.c_str());
+
+          values.insert(std::make_pair(
+            NPT_String::Format("<upnp:lastPlaybackPosition>%ld</upnp:lastPlaybackPosition>",
+              (long)item.GetVideoInfoTag()->GetResumePoint().timeInSeconds),
+            NPT_String::Format("<upnp:lastPlaybackPosition>%ld</upnp:lastPlaybackPosition>",
+              time)));
+
+          NPT_String curr_value = "<upnp:lastPlayerState>";
+          PLT_Didl::AppendXmlEscape(curr_value, item.GetVideoInfoTag()->GetResumePoint().playerState.c_str());
           curr_value += "</xbmc:lastPlayerState>";
-          new_value.Append(NPT_String::Format(
-              "<upnp:lastPlaybackPosition>%ld</upnp:lastPlaybackPosition>", time));
-          new_value += "<xbmc:lastPlayerState>";
+          NPT_String new_value = "<upnp:lastPlayerState>";
           PLT_Didl::AppendXmlEscape(new_value, bookmark.playerState.c_str());
           new_value += "</xbmc:lastPlayerState>";
+          values.insert(std::make_pair(curr_value, new_value));
         }
         if (updatePlayCount) {
           s_logger->debug("Marking video item {} as watched", path);
-          if (!curr_value.IsEmpty())
-            curr_value.Append(",");
-          if (!new_value.IsEmpty())
-            new_value.Append(",");
-          curr_value.Append("<upnp:playCount>0</upnp:playCount>");
-          new_value.Append("<upnp:playCount>1</upnp:playCount>");
+          values.insert(std::make_pair("<upnp:playCount>0</upnp:playCount>",
+                                       "<upnp:playCount>1</upnp:playCount>"));
         }
 
-        return InvokeUpdateObject(path.c_str(), (const char*)curr_value, (const char*)new_value);
+        return InvokeUpdateObject(path.c_str(), values);
     }
 
-    bool InvokeUpdateObject(const char* id, const char* curr_value, const char* new_value)
+    bool UpdateItem(const std::string& path, const CFileItem& item)
+    {
+      if (path.empty())
+        return false;
+
+      std::set<std::pair<NPT_String, NPT_String> > values;
+      if (item.HasVideoInfoTag())
+      {
+        // handle playcount
+        const CVideoInfoTag *details = item.GetVideoInfoTag();
+        int playcountOld = 0, playcountNew = 0;
+        if (details->GetPlayCount() <= 0)
+          playcountOld = 1;
+        else
+          playcountNew = details->GetPlayCount();
+
+        values.insert(std::make_pair(
+          NPT_String::Format("<upnp:playCount>%d</upnp:playCount>", playcountOld),
+          NPT_String::Format("<upnp:playCount>%d</upnp:playCount>", playcountNew)));
+
+        // handle lastplayed
+        CDateTime lastPlayedOld, lastPlayedNew;
+        if (!details->m_lastPlayed.IsValid())
+          lastPlayedOld = CDateTime::GetCurrentDateTime();
+        else
+          lastPlayedNew = details->m_lastPlayed;
+
+        values.insert(std::make_pair(
+          NPT_String::Format("<upnp:lastPlaybackTime>%ld</upnp:lastPlaybackTime>",
+            lastPlayedOld.GetAsW3CDateTime().c_str()),
+          NPT_String::Format("<upnp:lastPlaybackTime>%ld</upnp:lastPlaybackTime>",
+            lastPlayedNew.GetAsW3CDateTime().c_str())));
+
+        // handle resume point
+        long resumePointOld = 0L, resumePointNew = 0L;
+        if (details->GetResumePoint().timeInSeconds <= 0)
+          resumePointOld = 1;
+        else
+          resumePointNew = static_cast<long>(details->GetResumePoint().timeInSeconds);
+
+        values.insert(std::make_pair(
+          NPT_String::Format("<upnp:lastPlaybackPosition>%ld</upnp:lastPlaybackPosition>",
+            resumePointOld),
+          NPT_String::Format("<upnp:lastPlaybackPosition>%ld</upnp:lastPlaybackPosition>",
+            resumePointNew)));
+      }
+
+      return InvokeUpdateObject(path.c_str(), values);
+    }
+
+    bool InvokeUpdateObject(const char *id, const std::set<std::pair<NPT_String, NPT_String> >& values)
     {
         CURL url(id);
         PLT_DeviceDataReference device;
         PLT_Service* cds;
         PLT_ActionReference action;
+        NPT_String curr_value, new_value;
 
         s_logger->debug("attempting to invoke UpdateObject for {}", id);
 
@@ -284,6 +334,18 @@ class CMediaBrowser : public PLT_SyncMediaBrowser,
             action), failed);
 
         NPT_CHECK_LABEL(action->SetArgumentValue("ObjectID", url.GetFileName().c_str()), failed);
+
+        // put together the current and the new value string
+        for (std::set<std::pair<NPT_String, NPT_String> >::const_iterator value = values.begin(); value != values.end(); ++value)
+        {
+            if (!curr_value.IsEmpty())
+                curr_value.Append(",");
+            if (!new_value.IsEmpty())
+                new_value.Append(",");
+
+            curr_value.Append(value->first);
+            new_value.Append(value->second);
+        }
         NPT_CHECK_LABEL(action->SetArgumentValue("CurrentTagValue", curr_value), failed);
         NPT_CHECK_LABEL(action->SetArgumentValue("NewTagValue", new_value), failed);
 
@@ -566,6 +628,20 @@ CUPnP::DestroyControlPoint()
     m_CtrlPointHolder->m_CtrlPoint = NULL;
 }
 
+/*----------------------------------------------------------------------
+|   CUPnP::UpdateItem
++---------------------------------------------------------------------*/
+bool
+CUPnP::UpdateItem(const std::string& path, const CFileItem& item)
+{
+  if (upnp && upnp->m_MediaBrowser) {
+    // dynamic_cast is safe here, avoids polluting CUPnP.h header file
+    CMediaBrowser* browser = dynamic_cast<CMediaBrowser*>(upnp->m_MediaBrowser);
+    return browser->UpdateItem(path, item);
+  }
+  return false;
+}
+
 /*----------------------------------------------------------------------
 |   CUPnP::StartClient
 +---------------------------------------------------------------------*/
diff --git a/xbmc/network/upnp/UPnP.h b/xbmc/network/upnp/UPnP.h
index cb73b582762f..85ac2b9e80c9 100644
--- a/xbmc/network/upnp/UPnP.h
+++ b/xbmc/network/upnp/UPnP.h
@@ -69,6 +69,8 @@ class CUPnP
     static bool SaveFileState(const CFileItem& item,
                               const CBookmark& bookmark,
                               const bool updatePlayCount);
+    static bool UpdateItem(const std::string& path,
+                           const CFileItem& item);
 
     static void RegisterUserdata(void* ptr);
     static void UnregisterUserdata(void* ptr);
diff --git a/xbmc/network/upnp/UPnPServer.cpp b/xbmc/network/upnp/UPnPServer.cpp
index 6a5fa7f85610..22864e7ae55c 100644
--- a/xbmc/network/upnp/UPnPServer.cpp
+++ b/xbmc/network/upnp/UPnPServer.cpp
@@ -1086,7 +1086,7 @@ CUPnPServer::OnUpdateObject(PLT_ActionReference&             action,
     m_logger->info("OnUpdateObject: {} from {}", path,
                    (const char*)context.GetRemoteAddress().GetIpAddress().ToString());
 
-    NPT_String playCount, position;
+    NPT_String playCount, position, lastPlayed;
     int err;
     const char* msg = NULL;
     bool updatelisting(false);
@@ -1127,6 +1127,8 @@ CUPnPServer::OnUpdateObject(PLT_ActionReference&             action,
 
         position = new_vals["lastPlaybackPosition"];
         playCount = new_vals["playCount"];
+        lastPlayed = new_vals["lastPlaybackTime"];
+
 
         if (!position.IsEmpty()
               && position.Compare(current_vals["lastPlaybackPosition"]) != 0) {
@@ -1157,7 +1159,13 @@ CUPnPServer::OnUpdateObject(PLT_ActionReference&             action,
 
             NPT_UInt32 count;
             NPT_CHECK_LABEL(playCount.ToInteger32(count), args);
-            db.SetPlayCount(updated, count);
+
+            CDateTime lastPlayedObj;
+            if (!lastPlayed.IsEmpty() &&
+                lastPlayed.Compare(current_vals["lastPlaybackTime"]) != 0)
+                lastPlayedObj.SetFromW3CDateTime(lastPlayed.GetChars());
+
+            db.SetPlayCount(updated, count, lastPlayedObj);
             updatelisting = true;
         }
 

From 0fc9ae82d158e3ed1e2c4502ad4606ffb8410884 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 18 Dec 2016 17:52:28 +0100
Subject: [PATCH 51/88] [network] CUPnPServer: better handle files vs.
 directories in OnBrowseMetadata

---
 xbmc/network/upnp/UPnPServer.cpp | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/xbmc/network/upnp/UPnPServer.cpp b/xbmc/network/upnp/UPnPServer.cpp
index 22864e7ae55c..02446b29c110 100644
--- a/xbmc/network/upnp/UPnPServer.cpp
+++ b/xbmc/network/upnp/UPnPServer.cpp
@@ -300,6 +300,7 @@ CUPnPServer::Build(CFileItemPtr                  item,
             if (path == "musicdb://" ) {
                 item->SetLabel("Music Library");
                 item->SetLabelPreformatted(true);
+                item->m_bIsFolder = true;
             } else {
                 if (!item->HasMusicInfoTag()) {
                     MUSICDATABASEDIRECTORY::CQueryParams params;
@@ -314,11 +315,13 @@ CUPnPServer::Build(CFileItemPtr                  item,
                             item->GetMusicInfoTag()->SetSong(song);
                     }
                     else if (params.GetAlbumId() >= 0 ) {
+                        item->m_bIsFolder = true;
                         CAlbum album;
                         if (db.GetAlbum(params.GetAlbumId(), album, false))
                             item->GetMusicInfoTag()->SetAlbum(album);
                     }
                     else if (params.GetArtistId() >= 0 ) {
+                        item->m_bIsFolder = true;
                         CArtist artist;
                         if (db.GetArtist(params.GetArtistId(), artist, false))
                             item->GetMusicInfoTag()->SetArtist(artist);
@@ -339,6 +342,7 @@ CUPnPServer::Build(CFileItemPtr                  item,
             if (path == "library://video/" ) {
                 item->SetLabel("Video Library");
                 item->SetLabelPreformatted(true);
+                item->m_bIsFolder = true;
             } else {
                 if (!item->HasVideoInfoTag()) {
                     VIDEODATABASEDIRECTORY::CQueryParams params;
@@ -369,6 +373,7 @@ CUPnPServer::Build(CFileItemPtr                  item,
                 if (item->GetVideoInfoTag()->m_type == MediaTypeTvShow || item->GetVideoInfoTag()->m_type == MediaTypeSeason) {
                     // for tvshows and seasons, iEpisode and playCount are
                     // invalid
+                    item->m_bIsFolder = true;
                     item->GetVideoInfoTag()->m_iEpisode = (int)item->GetProperty("totalepisodes").asInteger();
                     item->GetVideoInfoTag()->SetPlayCount(static_cast<int>(item->GetProperty("watchedepisodes").asInteger()));
                 }
@@ -389,6 +394,8 @@ CUPnPServer::Build(CFileItemPtr                  item,
                 }
             }
         }
+        else
+            item->m_bIsFolder = CDirectory::Exists(item->GetPath());
 
         // not a virtual path directory, new system
         object = BuildObject(*item.get(), file_path, with_count, thumb_loader, &context, this, UPnPContentDirectory);
@@ -569,8 +576,7 @@ CUPnPServer::OnBrowseMetadata(PLT_ActionReference&          action,
             return NPT_FAILURE;
         }
     } else {
-        // determine if it's a container by calling CDirectory::Exists
-        item.reset(new CFileItem((const char*)id, CDirectory::Exists((const char*)id)));
+        item.reset(new CFileItem((const char*)id, false));
 
         // attempt to determine the parent of this item
         std::string parent;

From 7c94d8a5b0bc07677066b87d5f94ef53f0fe2546 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Sat, 28 Dec 2013 09:52:56 +0100
Subject: [PATCH 52/88] [WIP] platinum: add "thumb" attribute to person tags

---
 .../Source/Devices/MediaServer/PltMediaItem.cpp        | 10 +++++++++-
 .../Platinum/Source/Devices/MediaServer/PltMediaItem.h |  3 ++-
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/lib/libUPnP/Platinum/Source/Devices/MediaServer/PltMediaItem.cpp b/lib/libUPnP/Platinum/Source/Devices/MediaServer/PltMediaItem.cpp
index fac16902f78d..0575261b687d 100644
--- a/lib/libUPnP/Platinum/Source/Devices/MediaServer/PltMediaItem.cpp
+++ b/lib/libUPnP/Platinum/Source/Devices/MediaServer/PltMediaItem.cpp
@@ -55,11 +55,12 @@ NPT_DEFINE_DYNAMIC_CAST_ANCHOR(PLT_MediaContainer)
 |   PLT_PersonRoles::AddPerson
 +---------------------------------------------------------------------*/
 NPT_Result
-PLT_PersonRoles::Add(const NPT_String& name, const NPT_String& role /* = "" */)
+PLT_PersonRoles::Add(const NPT_String& name, const NPT_String& role /* = "" */, const NPT_String& thumb /* = "" */)
 {
     PLT_PersonRole person;
     person.name = name;
     person.role = role;
+    person.thumb = thumb;
 
     return NPT_List<PLT_PersonRole>::Add(person);
 }
@@ -82,6 +83,11 @@ PLT_PersonRoles::ToDidl(NPT_String& didl, const NPT_String& tag)
             PLT_Didl::AppendXmlEscape(tmp, it->role);
             tmp += "\"";
         }
+        if (!it->thumb.IsEmpty()) {
+            tmp += " thumb=\"";
+            PLT_Didl::AppendXmlEscape(tmp, it->thumb);
+            tmp += "\"";
+        }
         tmp += ">";
         PLT_Didl::AppendXmlEscape(tmp, it->name);
         tmp += "</upnp:" + tag + ">";
@@ -101,9 +107,11 @@ PLT_PersonRoles::FromDidl(const NPT_Array<NPT_XmlElementNode*>& nodes)
         PLT_PersonRole person;
         const NPT_String* name = nodes[i]->GetText();
         const NPT_String* role = nodes[i]->GetAttribute("role");
+        const NPT_String* thumb = nodes[i]->GetAttribute("thumb");
         // DLNA 7.3.17
         if (name) person.name = name->SubString(0, 1024);
         if (role) person.role = role->SubString(0, 1024);
+        if (thumb) person.thumb = thumb->SubString(0, 1024);
         NPT_CHECK(NPT_List<PLT_PersonRole>::Add(person));
     }
     return NPT_SUCCESS;
diff --git a/lib/libUPnP/Platinum/Source/Devices/MediaServer/PltMediaItem.h b/lib/libUPnP/Platinum/Source/Devices/MediaServer/PltMediaItem.h
index 3a13967f5f9b..a94fb0d4724d 100644
--- a/lib/libUPnP/Platinum/Source/Devices/MediaServer/PltMediaItem.h
+++ b/lib/libUPnP/Platinum/Source/Devices/MediaServer/PltMediaItem.h
@@ -66,12 +66,13 @@ typedef struct {
 typedef struct {
     NPT_String name;
     NPT_String role;
+    NPT_String thumb;
 } PLT_PersonRole;
 
 class PLT_PersonRoles  : public NPT_List<PLT_PersonRole>
 {
 public:
-    NPT_Result Add(const NPT_String& name, const NPT_String& role = "");
+    NPT_Result Add(const NPT_String& name, const NPT_String& role = "", const NPT_String& thumb = "");
     NPT_Result ToDidl(NPT_String& didl, const NPT_String& tag);
     NPT_Result FromDidl(const NPT_Array<NPT_XmlElementNode*>& nodes);
 };

From 1c95072a4bfdae66a8f46d2d0b57d71cdbd6ff53 Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Tue, 28 Jan 2014 16:44:28 +0100
Subject: [PATCH 53/88] [network] upnp: add IMediaImporter implementation for
 UPnP items

---
 .../resources/strings.po                      |  19 +-
 cmake/treedata/common/media.txt               |   1 +
 system/settings/settings.xml                  |   7 +
 .../import/importers/BaseMediaImporter.cpp    |  74 ++++
 .../import/importers/BaseMediaImporter.h      |  34 ++
 xbmc/media/import/importers/CMakeLists.txt    |   5 +
 xbmc/network/upnp/CMakeLists.txt              |   2 +
 xbmc/network/upnp/UPnP.cpp                    |  31 ++
 xbmc/network/upnp/UPnP.h                      |   3 +
 xbmc/network/upnp/UPnPMediaImporter.cpp       | 337 ++++++++++++++++++
 xbmc/network/upnp/UPnPMediaImporter.h         | 109 ++++++
 11 files changed, 620 insertions(+), 2 deletions(-)
 create mode 100644 xbmc/media/import/importers/BaseMediaImporter.cpp
 create mode 100644 xbmc/media/import/importers/BaseMediaImporter.h
 create mode 100644 xbmc/media/import/importers/CMakeLists.txt
 create mode 100644 xbmc/network/upnp/UPnPMediaImporter.cpp
 create mode 100644 xbmc/network/upnp/UPnPMediaImporter.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index ea6c244dbdc2..e2fcb42db8e7 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -8605,6 +8605,7 @@ msgctxt "#16000"
 msgid "General"
 msgstr ""
 
+#: system/settings/settings.xml
 #: xbmc/media/import/MediaImport.cpp
 msgctxt "#16001"
 msgid "Media Import"
@@ -20857,7 +20858,17 @@ msgctxt "#36636"
 msgid "You must first enter a password before web server authentication can be enabled."
 msgstr ""
 
-#empty strings from id 36637 to 36898
+#: system/settings/settings.xml
+msgctxt "#36637"
+msgid "Import media items from UPnP servers"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#36638"
+msgid "Adds newly detected UPnP servers to the list of available media providers with the possibility to import media items into the local library. It is possible to choose which media items to import and which not. The imported items appear in the library like any other media item except that it can only be played if the UPnP server they were imported from is available."
+msgstr ""
+
+#empty strings from id 36639 to 36898
 
 #. Description of setting with label #729 "Enable SSL"
 #: system/settings/settings.xml
@@ -22266,7 +22277,11 @@ msgctxt "#39567"
 msgid "New import added"
 msgstr ""
 
-# empty string id 39568
+#. Retrieving (media type plural)...
+#: xbmc/network/upnp/UPnPMediaImporter.cpp
+msgctxt "#39568"
+msgid "Retrieving {:s}..."
+msgstr ""
 
 #. Cleaning up (media type plural) from (media provider name)...
 #: xbmc/media/import/task/MediaImportCleanupTask.cpp
diff --git a/cmake/treedata/common/media.txt b/cmake/treedata/common/media.txt
index ef3ac76ed4ac..aa446a4b11c8 100644
--- a/cmake/treedata/common/media.txt
+++ b/cmake/treedata/common/media.txt
@@ -2,6 +2,7 @@ xbmc/media                                      media
 xbmc/media/drm                                  drm
 xbmc/media/import                               media/import
 xbmc/media/import/handlers                      media/import/handlers
+xbmc/media/import/importers                     media/import/importers
 xbmc/media/import/jobs                          media/import/jobs
 xbmc/media/import/jobs/tasks                    media/import/jobs/tasks
 xbmc/media/import/repositories                  media/import/repositories
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 0c85468ab031..4d1ffeb23c3f 100755
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1913,6 +1913,13 @@
           <control type="toggle" />
         </setting>
       </group>
+      <group id="2" label="16001">
+        <setting id="services.upnpimport" type="boolean" label="36637" help="36638">
+          <level>1</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+      </group>
     </category>
     <category id="airplay" label="1273" help="36602">
       <requirement>HAS_AIRPLAY</requirement>
diff --git a/xbmc/media/import/importers/BaseMediaImporter.cpp b/xbmc/media/import/importers/BaseMediaImporter.cpp
new file mode 100644
index 000000000000..7bf64ce60f95
--- /dev/null
+++ b/xbmc/media/import/importers/BaseMediaImporter.cpp
@@ -0,0 +1,74 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "BaseMediaImporter.h"
+
+#include "settings/lib/Setting.h"
+
+bool CBaseMediaImporter::LoadSourceSettings(CMediaImportSource& source)
+{
+  return LoadSettings(source.Settings());
+}
+
+bool CBaseMediaImporter::UnloadSourceSettings(CMediaImportSource& source)
+{
+  return UnloadSettings(source.Settings());
+}
+
+bool CBaseMediaImporter::LoadImportSettings(CMediaImport& import)
+{
+  // first try to load the source's settings
+  if (!LoadSourceSettings(import.GetSource()))
+    return false;
+
+  auto settings = import.Settings();
+  if (!LoadSettings(settings))
+    return false;
+
+  auto settingUpdatePlaybackMetadataOnSource =
+      settings->GetSetting(CMediaImportSettings::SettingUpdatePlaybackMetadataOnSource);
+  if (settingUpdatePlaybackMetadataOnSource != nullptr)
+  {
+    settingUpdatePlaybackMetadataOnSource->SetEnabled(
+        CanUpdatePlaycountOnSource(import.GetPath()) ||
+        CanUpdateLastPlayedOnSource(import.GetPath()) ||
+        CanUpdateResumePositionOnSource(import.GetPath()));
+  }
+
+  return true;
+}
+
+bool CBaseMediaImporter::UnloadImportSettings(CMediaImport& import)
+{
+  bool result = UnloadSettings(import.Settings());
+
+  // also unload the source's settings
+  if (!UnloadSourceSettings(import.GetSource()))
+    return false;
+
+  return result;
+}
+
+bool CBaseMediaImporter::LoadSettings(MediaImportSettingsBasePtr settings) const
+{
+  return settings->Load();
+}
+
+bool CBaseMediaImporter::UnloadSettings(MediaImportSettingsBasePtr settings) const
+{
+  if (!settings->IsLoaded())
+    return true;
+
+  // save the settings
+  bool result = settings->Save();
+
+  // unload the settings completely
+  settings->Unload();
+
+  return result;
+}
\ No newline at end of file
diff --git a/xbmc/media/import/importers/BaseMediaImporter.h b/xbmc/media/import/importers/BaseMediaImporter.h
new file mode 100644
index 000000000000..47147c3daf63
--- /dev/null
+++ b/xbmc/media/import/importers/BaseMediaImporter.h
@@ -0,0 +1,34 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/IMediaImporter.h"
+
+/*!
+ * \brief Interface of a media importer capable of importing media items from
+ * a specific source into the local library.
+ */
+class CBaseMediaImporter : public IMediaImporter
+{
+public:
+  virtual ~CBaseMediaImporter() = default;
+
+  // specializations of IMediaImporter
+  bool LoadSourceSettings(CMediaImportSource& source) override;
+  bool UnloadSourceSettings(CMediaImportSource& source) override;
+  bool LoadImportSettings(CMediaImport& import) override;
+  bool UnloadImportSettings(CMediaImport& import) override;
+
+protected:
+  CBaseMediaImporter() = default;
+
+private:
+  bool LoadSettings(MediaImportSettingsBasePtr settings) const;
+  bool UnloadSettings(MediaImportSettingsBasePtr settings) const;
+};
diff --git a/xbmc/media/import/importers/CMakeLists.txt b/xbmc/media/import/importers/CMakeLists.txt
new file mode 100644
index 000000000000..d113c5e639e7
--- /dev/null
+++ b/xbmc/media/import/importers/CMakeLists.txt
@@ -0,0 +1,5 @@
+set(SOURCES BaseMediaImporter.cpp)
+
+set(HEADERS BaseMediaImporter.h)
+
+core_add_library(media_import_importers)
diff --git a/xbmc/network/upnp/CMakeLists.txt b/xbmc/network/upnp/CMakeLists.txt
index e558cfcf637c..7823529b942c 100644
--- a/xbmc/network/upnp/CMakeLists.txt
+++ b/xbmc/network/upnp/CMakeLists.txt
@@ -1,5 +1,6 @@
 set(SOURCES UPnP.cpp
             UPnPInternal.cpp
+            UPnPMediaImporter.cpp
             UPnPPlayer.cpp
             UPnPRenderer.cpp
             UPnPServer.cpp
@@ -7,6 +8,7 @@ set(SOURCES UPnP.cpp
 
 set(HEADERS UPnP.h
             UPnPInternal.h
+            UPnPMediaImporter.h
             UPnPPlayer.h
             UPnPRenderer.h
             UPnPServer.h
diff --git a/xbmc/network/upnp/UPnP.cpp b/xbmc/network/upnp/UPnP.cpp
index d7d49704aa01..d6e0bba3a17f 100644
--- a/xbmc/network/upnp/UPnP.cpp
+++ b/xbmc/network/upnp/UPnP.cpp
@@ -16,6 +16,7 @@
 #include "GUIUserMessages.h"
 #include "ServiceBroker.h"
 #include "UPnPInternal.h"
+#include "UPnPMediaImporter.h"
 #include "UPnPRenderer.h"
 #include "UPnPServer.h"
 #include "UPnPSettings.h"
@@ -24,12 +25,14 @@
 #include "cores/playercorefactory/PlayerCoreFactory.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIWindowManager.h"
+#include "media/import/MediaImportManager.h"
 #include "messaging/ApplicationMessenger.h"
 #include "network/Network.h"
 #include "profiles/ProfileManager.h"
 #include "settings/Settings.h"
 #include "settings/SettingsComponent.h"
 #include "utils/StaticLoggerBase.h"
+#include "utils/StringUtils.h"
 #include "utils/SystemInfo.h"
 #include "utils/TimeUtils.h"
 #include "utils/URIUtils.h"
@@ -178,6 +181,16 @@ class CMediaBrowser : public PLT_SyncMediaBrowser,
         message.SetStringParam("upnp://");
         CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(message);
 
+        if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool("services.upnpimport"))
+        {
+          std::string sourceID = getSourceID(device);
+          CServiceBroker::GetMediaImportManager().AddAndActivateSource(
+              CUPnPMediaImporterBase::IDENTIFICATION, sourceID, sourceID,
+              device->GetFriendlyName().GetChars(), device->GetIconUrl("image/png").GetChars(),
+              {MediaTypeMovie, MediaTypeMusicVideo, MediaTypeTvShow, MediaTypeSeason,
+               MediaTypeEpisode});
+        }
+
         return PLT_SyncMediaBrowser::OnMSAdded(device);
     }
     void OnMSRemoved(PLT_DeviceDataReference& device) override
@@ -188,6 +201,8 @@ class CMediaBrowser : public PLT_SyncMediaBrowser,
         message.SetStringParam("upnp://");
         CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(message);
 
+        CServiceBroker::GetMediaImportManager().DeactivateSource(getSourceID(device));
+
         PLT_SyncMediaBrowser::OnMSRemoved(device);
     }
 
@@ -358,6 +373,12 @@ class CMediaBrowser : public PLT_SyncMediaBrowser,
       s_logger->info("invoking UpdateObject failed");
       return false;
     }
+
+private:
+    std::string getSourceID(const PLT_DeviceDataReference& device)
+    {
+      return StringUtils::Format("upnp://%s", device->GetUUID().GetChars());
+    }
 };
 
 
@@ -655,6 +676,11 @@ CUPnP::StartClient()
 
     // start browser
     m_MediaBrowser = new CMediaBrowser(m_CtrlPointHolder->m_CtrlPoint);
+
+    // register the upnp media importer
+    if (m_mediaImporterFactory == NULL)
+      m_mediaImporterFactory = std::make_shared<CUPnPMediaImporterFactory>();
+    CServiceBroker::GetMediaImportManager().RegisterImporter(m_mediaImporterFactory);
 }
 
 /*----------------------------------------------------------------------
@@ -666,6 +692,11 @@ CUPnP::StopClient()
     if (m_MediaBrowser == NULL)
         return;
 
+    // unregister the upnp media importer
+    if (m_mediaImporterFactory != NULL)
+      CServiceBroker::GetMediaImportManager().UnregisterImporter(
+          m_mediaImporterFactory->GetIdentification());
+
     delete m_MediaBrowser;
     m_MediaBrowser = NULL;
 
diff --git a/xbmc/network/upnp/UPnP.h b/xbmc/network/upnp/UPnP.h
index 85ac2b9e80c9..38fed3a42c02 100644
--- a/xbmc/network/upnp/UPnP.h
+++ b/xbmc/network/upnp/UPnP.h
@@ -14,6 +14,8 @@
 
 #include <string>
 
+#include "media/import/IMediaImporter.h"
+
 class NPT_LogHandler;
 class PLT_UPnP;
 class PLT_SyncMediaBrowser;
@@ -97,6 +99,7 @@ class CUPnP
     CRendererReferenceHolder*   m_RendererHolder;
     CCtrlPointReferenceHolder*  m_CtrlPointHolder;
 
+    MediaImporterFactoryPtr m_mediaImporterFactory;
 
     static CUPnP* upnp;
 };
diff --git a/xbmc/network/upnp/UPnPMediaImporter.cpp b/xbmc/network/upnp/UPnPMediaImporter.cpp
new file mode 100644
index 000000000000..45ef6f3b4469
--- /dev/null
+++ b/xbmc/network/upnp/UPnPMediaImporter.cpp
@@ -0,0 +1,337 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "UPnPMediaImporter.h"
+
+#include "FileItem.h"
+#include "ServiceBroker.h"
+#include "URL.h"
+#include "dialogs/GUIDialogExtendedProgressBar.h"
+#include "guilib/LocalizeStrings.h"
+#include "media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.h"
+#include "media/import/jobs/tasks/MediaImportUpdateTask.h"
+#include "network/upnp/UPnP.h"
+#include "network/upnp/UPnPInternal.h"
+#include "settings/Settings.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/log.h"
+#include "video/VideoInfoTag.h"
+
+#include <Platinum/Source/Platinum/Platinum.h>
+#include <fmt/ostream.h>
+
+using namespace UPNP;
+
+#define UPNP_ROOT_CONTAINER_ID "0"
+
+typedef struct
+{
+  MediaType mediaType;
+  const char* objectIdentification;
+} SupportedMediaType;
+
+static SupportedMediaType SupportedMediaTypes[] = {
+    {MediaTypeMovie, "object.item.videoItem.movie"},
+    {MediaTypeTvShow, "object.container.album.videoAlbum.videoBroadcastShow"},
+    {MediaTypeSeason, "object.container.album.videoAlbum.videoBroadcastSeason"},
+    {MediaTypeEpisode, "object.item.videoItem.videoBroadcast"},
+    {MediaTypeMusicVideo, "object.item.videoItem.musicVideoClip"},
+    {MediaTypeArtist, "object.container.person.musicArtist"},
+    {MediaTypeAlbum, "object.container.album.musicAlbum"},
+    {MediaTypeSong, "object.item.audioItem"}};
+
+#define SupportedMediaTypesSize sizeof(SupportedMediaTypes) / sizeof(SupportedMediaType)
+
+static bool FindServer(const std::string& deviceUUID, PLT_DeviceDataReference& device)
+{
+  if (deviceUUID.empty())
+    return false;
+
+  return CUPnP::GetInstance()->m_MediaBrowser->FindServer(deviceUUID.c_str(), device) ==
+         NPT_SUCCESS;
+}
+
+static CFileItemPtr ConstructItem(PLT_DeviceDataReference& device, PLT_MediaObject* object)
+{
+  CFileItemPtr pItem = BuildObject(object);
+  std::string id;
+  if (object->m_ReferenceID.IsEmpty())
+    id = (const char*)object->m_ObjectID;
+  else
+    id = (const char*)object->m_ReferenceID;
+
+  CURL::Encode(id);
+  URIUtils::AddSlashAtEnd(id);
+  pItem->SetPath("upnp://" + std::string(device->GetUUID()) + "/" + id);
+  pItem->GetVideoInfoTag()->m_strPath = pItem->GetVideoInfoTag()->m_strFileNameAndPath =
+      pItem->GetPath();
+
+  return pItem;
+}
+
+static void ConstructList(PLT_DeviceDataReference& device,
+                          PLT_MediaObjectListReference& list,
+                          std::vector<CFileItemPtr>& items)
+{
+  if (list.IsNull())
+    return;
+
+  for (PLT_MediaObjectList::Iterator entry = list->GetFirstItem(); entry; ++entry)
+  {
+    CFileItemPtr item(ConstructItem(device, *entry));
+    if (item != NULL)
+      items.push_back(item);
+  }
+}
+
+static bool Search(PLT_DeviceDataReference& device,
+                   const std::string& search_criteria,
+                   std::vector<CFileItemPtr>& items)
+{
+  PLT_SyncMediaBrowser* mediaBrowser = CUPnP::GetInstance()->m_MediaBrowser;
+  if (mediaBrowser == NULL)
+    return false;
+
+  PLT_MediaObjectListReference list;
+  if (mediaBrowser->SearchSync(device, UPNP_ROOT_CONTAINER_ID, search_criteria.c_str(), list) !=
+      NPT_SUCCESS)
+    return false;
+
+  ConstructList(device, list, items);
+  return true;
+}
+
+static bool Search(CMediaImportImportItemsRetrievalTask* task,
+                   PLT_DeviceDataReference& device,
+                   const MediaType& mediaType,
+                   std::vector<CFileItemPtr>& items)
+{
+  SupportedMediaType* supportedMediaType = NULL;
+  for (size_t i = 0; i < SupportedMediaTypesSize; i++)
+  {
+    if (mediaType == SupportedMediaTypes[i].mediaType)
+    {
+      supportedMediaType = &SupportedMediaTypes[i];
+      break;
+    }
+  }
+
+  if (supportedMediaType == NULL)
+    return false;
+
+  task->SetProgressText(StringUtils::Format(
+      g_localizeStrings.Get(39568).c_str(),
+      CMediaTypes::GetPluralLocalization(supportedMediaType->mediaType).c_str()));
+  if (!Search(device,
+              StringUtils::Format("upnp:class = \"{}\"", supportedMediaType->objectIdentification),
+              items))
+    return false;
+
+  if (mediaType == MediaTypeTvShow || mediaType == MediaTypeSeason)
+  {
+    std::vector<CFileItemPtr> showItems;
+    for (std::vector<CFileItemPtr>::iterator it = items.begin(); it != items.end(); ++it)
+    { // discard video albums that are NOT tv shows
+      if ((*it)->HasVideoInfoTag() && (*it)->GetVideoInfoTag()->m_type == mediaType)
+        showItems.push_back(*it);
+    }
+
+    items.clear();
+    items.assign(showItems.begin(), showItems.end());
+  }
+
+  return true;
+}
+
+constexpr char CUPnPMediaImporterBase::IDENTIFICATION[];
+
+CUPnPMediaImporter::CUPnPMediaImporter()
+  : m_logger(CServiceBroker::GetLogging().GetLogger("CUPnPMediaImporter"))
+{
+}
+
+bool CUPnPMediaImporter::CanImport(const std::string& path)
+{
+  PLT_DeviceDataReference device;
+  if (!validatePath(path, device))
+    return false;
+
+  PLT_SyncMediaBrowser* mediaBrowser = CUPnP::GetInstance()->m_MediaBrowser;
+  if (mediaBrowser == nullptr)
+    return false;
+
+  NPT_String searchCapabilities;
+  if (NPT_FAILED(mediaBrowser->GetSearchCapabilitiesSync(device, searchCapabilities)))
+    return false;
+
+  return !searchCapabilities.IsEmpty() && searchCapabilities.Find("upnp:class") >= 0;
+}
+
+bool CUPnPMediaImporter::IsSourceReady(CMediaImportSource& source)
+{
+  return CanImport(source.GetBasePath());
+}
+
+bool CUPnPMediaImporter::IsImportReady(CMediaImport& import)
+{
+  return CanImport(import.GetPath());
+}
+
+bool CUPnPMediaImporter::CanUpdatePlaycountOnSource(const std::string& path)
+{
+  // might be too restrictive
+  return isXbmcServer(path);
+}
+
+bool CUPnPMediaImporter::CanUpdateLastPlayedOnSource(const std::string& path)
+{
+  // might be too restrictive
+  return isXbmcServer(path);
+}
+
+bool CUPnPMediaImporter::CanUpdateResumePositionOnSource(const std::string& path)
+{
+  // might be too restrictive
+  return isXbmcServer(path);
+}
+
+bool CUPnPMediaImporter::Import(CMediaImportImportItemsRetrievalTask* task)
+{
+  if (task == NULL)
+    return false;
+
+  const auto& import = task->GetImport();
+
+  std::string deviceUUID;
+  if (!getDeviceIdentifier(import.GetPath(), deviceUUID))
+  {
+    m_logger->warn("unable to import media items from unknown path {}", import.GetPath());
+    return false;
+  }
+
+  PLT_DeviceDataReference device;
+  if (!FindServer(deviceUUID, device))
+  {
+    m_logger->warn("unable to import media items from unavailable source {}", deviceUUID);
+    return false;
+  }
+
+  for (const auto& importedMediaType : import.GetMediaTypes())
+  {
+    bool success = false;
+    for (size_t i = 0; i < SupportedMediaTypesSize; i++)
+    {
+      if (CMediaTypes::IsMediaType(importedMediaType, SupportedMediaTypes[i].mediaType))
+      {
+        success = true;
+        break;
+      }
+    }
+
+    if (!success)
+      return false;
+
+    success = false;
+    if (task->ShouldCancel(0, 1))
+      return false;
+
+    std::vector<CFileItemPtr> items;
+    if (!Search(task, device, importedMediaType, items))
+      return false;
+
+    // ignore any items that are not part of the requested path
+    std::vector<CFileItemPtr> itemList;
+    for (auto& item : items)
+    {
+      if (URIUtils::PathHasParent(item->GetPath(), import.GetPath()))
+        itemList.push_back(item);
+    }
+
+    task->AddItems(itemList, importedMediaType, MediaImportChangesetType::None);
+  }
+  return true;
+}
+
+bool CUPnPMediaImporter::UpdateOnSource(CMediaImportUpdateTask* task)
+{
+  if (task == NULL || !task->GetItem().IsImported())
+    return false;
+
+  const auto& import = task->GetImport();
+
+  std::string deviceUUID;
+  if (!getDeviceIdentifier(import.GetPath(), deviceUUID))
+  {
+    m_logger->warn("unable to update imported media item on unknown source {}", import.GetSource());
+    return false;
+  }
+
+  PLT_DeviceDataReference device;
+  if (!FindServer(deviceUUID, device))
+  {
+    m_logger->warn("unable to update imported media item on unavailable source {}", deviceUUID);
+    return false;
+  }
+
+  const auto& importSettings = import.Settings();
+  if (!importSettings->UpdatePlaybackMetadataOnSource())
+    return false;
+
+  const std::string& importPath = import.GetPath();
+  if (!CanUpdatePlaycountOnSource(importPath) && !CanUpdateLastPlayedOnSource(importPath) &&
+      !CanUpdateResumePositionOnSource(importPath))
+    return false;
+
+  const CFileItem& item = task->GetItem();
+  std::string url;
+  if (item.HasVideoInfoTag())
+    url = item.GetVideoInfoTag()->GetPath();
+
+  if (url.empty())
+    return false;
+
+  return CUPnP::GetInstance()->UpdateItem(url, task->GetItem());
+}
+
+bool CUPnPMediaImporter::getDeviceIdentifier(const std::string& path, std::string& deviceIdentifier)
+{
+  if (path.empty() || !URIUtils::IsUPnP(path))
+    return false;
+
+  CURL url(path);
+  deviceIdentifier = url.GetHostName();
+
+  return true;
+}
+
+bool CUPnPMediaImporter::validatePath(const std::string& path, PLT_DeviceDataReference& device)
+{
+  std::string deviceUUID;
+  if (!getDeviceIdentifier(path, deviceUUID))
+    return false;
+
+  return FindServer(deviceUUID, device);
+}
+
+bool CUPnPMediaImporter::isXbmcServer(const std::string& path)
+{
+  PLT_DeviceDataReference device;
+  if (!validatePath(path, device))
+    return false;
+
+  PLT_SyncMediaBrowser* mediaBrowser = CUPnP::GetInstance()->m_MediaBrowser;
+  if (mediaBrowser == NULL)
+    return false;
+
+  NPT_String sortCapabilities;
+  if (NPT_FAILED(mediaBrowser->GetSortCapabilitiesSync(device, sortCapabilities)))
+    return false;
+
+  return !sortCapabilities.IsEmpty() && sortCapabilities.Find("xbmc:") >= 0;
+}
diff --git a/xbmc/network/upnp/UPnPMediaImporter.h b/xbmc/network/upnp/UPnPMediaImporter.h
new file mode 100644
index 000000000000..f388c4cae146
--- /dev/null
+++ b/xbmc/network/upnp/UPnPMediaImporter.h
@@ -0,0 +1,109 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/importers/BaseMediaImporter.h"
+#include "utils/logtypes.h"
+
+#include <Platinum/Source/Core/PltDeviceData.h>
+
+class CUPnPMediaImporterBase : public virtual IMediaImporterBase
+{
+public:
+  static constexpr char IDENTIFICATION[] = "UPnPMediaImporter";
+
+  ~CUPnPMediaImporterBase() override = default;
+
+  // implementations of IMediaImporterBase
+  const char* GetIdentification() const override { return IDENTIFICATION; }
+  bool CanLookupSource() const override { return false; }
+  std::string GetSourceLookupProtocol() const override { return "UPnP"; }
+
+protected:
+  CUPnPMediaImporterBase() = default;
+};
+
+class CUPnPMediaImporterDiscoverer : public IMediaImporterDiscoverer, public CUPnPMediaImporterBase
+{
+public:
+  CUPnPMediaImporterDiscoverer() = default;
+  ~CUPnPMediaImporterDiscoverer() override = default;
+
+  // implementations of IMediaImporterDiscoverer
+  void Start() override {}
+};
+
+class CUPnPMediaImporter : public CUPnPMediaImporterBase, public CBaseMediaImporter
+{
+public:
+  CUPnPMediaImporter();
+  ~CUPnPMediaImporter() override = default;
+
+  // implementations of IMediaImporter
+  bool DiscoverSource(CMediaImportSource& source) override { return false; }
+  bool LookupSource(const CMediaImportSource& source) override { return false; }
+
+  bool CanImport(const std::string& path) override;
+  bool IsSourceReady(CMediaImportSource& source) override;
+  bool IsImportReady(CMediaImport& import) override;
+  bool CanUpdateMetadataOnSource(const std::string& path) override { return false; }
+  bool CanUpdatePlaycountOnSource(const std::string& path) override;
+  bool CanUpdateLastPlayedOnSource(const std::string& path) override;
+  bool CanUpdateResumePositionOnSource(const std::string& path) override;
+
+  bool Import(CMediaImportImportItemsRetrievalTask* task) override;
+  bool UpdateOnSource(CMediaImportUpdateTask* task) override;
+
+protected:
+  static bool getDeviceIdentifier(const std::string& path, std::string& deviceIdentifier);
+  static bool validatePath(const std::string& path, PLT_DeviceDataReference& device);
+  static bool isXbmcServer(const std::string& path);
+
+  Logger m_logger;
+};
+
+class CUPnPMediaImporterObserver : public IMediaImporterObserver
+{
+public:
+  CUPnPMediaImporterObserver() = default;
+  ~CUPnPMediaImporterObserver() override = default;
+
+  // implementations of IMediaImporterObserver
+  void OnSourceAdded(const CMediaImportSource& source) override {}
+  void OnSourceUpdated(const CMediaImportSource& source) override {}
+  void OnSourceRemoved(const CMediaImportSource& source) override {}
+  void OnSourceActivated(const CMediaImportSource& source) override {}
+  void OnSourceDeactivated(const CMediaImportSource& source) override {}
+  void OnImportAdded(const CMediaImport& import) override {}
+  void OnImportUpdated(const CMediaImport& import) override {}
+  void OnImportRemoved(const CMediaImport& import) override {}
+};
+
+class CUPnPMediaImporterFactory : public IMediaImporterFactory
+{
+public:
+  CUPnPMediaImporterFactory() = default;
+  ~CUPnPMediaImporterFactory() override = default;
+
+  // implementations of IMediaImporterFactory
+  const char* GetIdentification() const override { return CUPnPMediaImporterBase::IDENTIFICATION; }
+
+  std::unique_ptr<IMediaImporterDiscoverer> CreateDiscoverer() const override
+  {
+    return std::make_unique<CUPnPMediaImporterDiscoverer>();
+  }
+  std::unique_ptr<IMediaImporter> CreateImporter() const override
+  {
+    return std::make_unique<CUPnPMediaImporter>();
+  }
+  std::unique_ptr<IMediaImporterObserver> CreateObserver() const override
+  {
+    return std::make_unique<CUPnPMediaImporterObserver>();
+  }
+};

From f2ea9b6a7a1e4114094ff386f91405cbedc004ab Mon Sep 17 00:00:00 2001
From: montellese <montellese@xbmc.org>
Date: Tue, 21 Jan 2014 15:04:28 +0100
Subject: [PATCH 54/88] [media import] add CGUIWindowMediaSourceBrowser and
 CGUIDialogMediaImportInfo

---
 .../resources/strings.po                      | 134 ++-
 cmake/treedata/common/media.txt               |   2 +
 system/keymaps/keyboard.xml                   |  11 +
 xbmc/guilib/GUIWindowManager.cpp              |   6 +
 xbmc/guilib/WindowIDs.h                       |   3 +
 xbmc/input/WindowTranslator.cpp               |   2 +
 xbmc/media/import/dialogs/CMakeLists.txt      |   5 +
 .../dialogs/GUIDialogMediaImportInfo.cpp      | 308 ++++++
 .../import/dialogs/GUIDialogMediaImportInfo.h |  63 ++
 xbmc/media/import/windows/CMakeLists.txt      |   7 +
 .../GUIViewStateMediaSourceBrowser.cpp        |  88 ++
 .../windows/GUIViewStateMediaSourceBrowser.h  |  24 +
 .../windows/GUIWindowMediaSourceBrowser.cpp   | 908 ++++++++++++++++++
 .../windows/GUIWindowMediaSourceBrowser.h     |  73 ++
 xbmc/view/GUIViewState.cpp                    |   7 +
 15 files changed, 1637 insertions(+), 4 deletions(-)
 create mode 100644 xbmc/media/import/dialogs/CMakeLists.txt
 create mode 100644 xbmc/media/import/dialogs/GUIDialogMediaImportInfo.cpp
 create mode 100644 xbmc/media/import/dialogs/GUIDialogMediaImportInfo.h
 create mode 100644 xbmc/media/import/windows/CMakeLists.txt
 create mode 100644 xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.cpp
 create mode 100644 xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.h
 create mode 100644 xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
 create mode 100644 xbmc/media/import/windows/GUIWindowMediaSourceBrowser.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index e2fcb42db8e7..44707c71ba09 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -2703,7 +2703,10 @@ msgctxt "#578"
 msgid "Artist / Year"
 msgstr ""
 
-#empty string with id 579
+#: xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.cpp
+msgctxt "#579"
+msgid "Last synced"
+msgstr ""
 
 msgctxt "#580"
 msgid "Sort direction"
@@ -8414,6 +8417,7 @@ msgid "Keep"
 msgstr ""
 
 #: xbmc/dialogs/GUIDialogFavourites.cpp
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
 #: xbmc/video/VideoDatabase.cpp
 msgctxt "#15015"
 msgid "Remove"
@@ -9339,6 +9343,7 @@ msgstr ""
 
 #. generic 'information' label used in different places, like labels for message box headers
 #: xbmc/event/windows/GUIWindowEventLog.cpp
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
 #: xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
@@ -22212,7 +22217,12 @@ msgctxt "#39554"
 msgid "Synchronisation successful"
 msgstr ""
 
-# empty strings from id 39555 to 39557
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39555"
+msgid "Media types available for import:"
+msgstr ""
+
+# empty strings from id 39556 to 39557
 
 #. Retrieving media items from (media provider name)
 #: xbmc/media/import/task/MediaImportImportItemsRetrievalTask.cpp
@@ -22334,14 +22344,130 @@ msgstr ""
 # strings from id 39580 to 39599 reserved for media import
 
 #: xbmc/filesystem/MediaImportDirectory.cpp
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
 msgctxt "#39600"
 msgid "Media providers"
 msgstr ""
 
-# empty string ids from 39601 to 39606
+#empty string with id 39601
+
+#. Title of the dialog asking whether to really remove a media provider
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39602"
+msgid "Remove media provider"
+msgstr ""
+
+#. Text of the dialog asking whether to really remove a media provider/import
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39603"
+msgid "Are you sure you want to remove %s and all of its items?"
+msgstr ""
+
+#. Title of the dialog asking whether to really remove a media import
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39604"
+msgid "Remove media import"
+msgstr ""
+
+#. Label of the button to add a new media provider
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39605"
+msgid "Add provider..."
+msgstr ""
+
+#. Label of the button to add a new import
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39606"
+msgid "Add import..."
+msgstr ""
 
 #. Context button label to synchronise a media provider/import
-#: xbmc/events/MediaImportEvent.cpp
+#: xbmc/event/MediaImportEvent.cpp
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
 msgctxt "#39607"
 msgid "Synchronise"
 msgstr ""
+
+#. Title of the dialog reporting an error adding a new media import
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39608"
+msgid "New media import"
+msgstr ""
+
+#. Text of the dialog reporting an error adding a new media import
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39609"
+msgid "Adding a new media import failed!"
+msgstr ""
+
+#. Title of the dialog reporting an error synchronising a media provider
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39610"
+msgid "Synchronising media provider failed!"
+msgstr ""
+
+#. Text of the dialog reporting an error synchronising a media provider
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39611"
+msgid "Synchronising with the media provider %s failed!"
+msgstr ""
+
+#. Title of the dialog reporting an error synchronising a media import
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39612"
+msgid "Synchronising media import failed!"
+msgstr ""
+
+#. Text of the dialog reporting an error synchronising a media import
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39613"
+msgid "Synchronising with the media import %s failed!"
+msgstr ""
+
+#. Text of the dialog reporting an error trying to open the info dialog for an inactive media provider
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39614"
+msgid "Unable to configure the inactive media provider %s."
+msgstr ""
+
+#. Text of the dialog reporting an error trying to open the info dialog for a media import of an inactive media provider
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39615"
+msgid "Unable to configure the inactive media import %s."
+msgstr ""
+
+#. Text of the dialog reporting an error trying to view media imports of a media provider that isn't fully configured yet
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39616"
+msgid "Unable to view media imports of unconfigured media provider %s."
+msgstr ""
+
+#empty string with id 39617
+
+#. Text of the dialog reporting an error adding a new media provider
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39618"
+msgid "Adding a new media provider failed!"
+msgstr ""
+
+#. Text of the dialog reporting that the media provider already exists
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39619"
+msgid "Discovered media provider \"%s\" already exists!"
+msgstr ""
+
+# strings from id 39620 to 39699 reserved for media import GUI integration
+
+#: xbmc/media/import/dialogs/GUIDialogMediaImportInfo.cpp
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39700"
+msgid "Media provider information"
+msgstr ""
+
+#: xbmc/media/import/dialogs/GUIDialogMediaImportInfo.cpp
+#: xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
+msgctxt "#39701"
+msgid "Media import information"
+msgstr ""
+
+#strings from 39702 to 39799 are reserved for media import GUI info
diff --git a/cmake/treedata/common/media.txt b/cmake/treedata/common/media.txt
index aa446a4b11c8..7f722a5a6c31 100644
--- a/cmake/treedata/common/media.txt
+++ b/cmake/treedata/common/media.txt
@@ -1,8 +1,10 @@
 xbmc/media                                      media
 xbmc/media/drm                                  drm
 xbmc/media/import                               media/import
+xbmc/media/import/dialogs                       media/import/dialogs
 xbmc/media/import/handlers                      media/import/handlers
 xbmc/media/import/importers                     media/import/importers
 xbmc/media/import/jobs                          media/import/jobs
 xbmc/media/import/jobs/tasks                    media/import/jobs/tasks
 xbmc/media/import/repositories                  media/import/repositories
+xbmc/media/import/windows                       media/import/windows
diff --git a/system/keymaps/keyboard.xml b/system/keymaps/keyboard.xml
index 5cb986f1b6bb..b6d673b56e21 100644
--- a/system/keymaps/keyboard.xml
+++ b/system/keymaps/keyboard.xml
@@ -828,4 +828,15 @@
       <t>ToggleFont</t>
     </keyboard>
   </TextViewer>
+  <MediaSourceBrowser>
+    <keyboard>
+      <delete>Delete</delete>
+      <i>Info</i>
+    </keyboard>
+  </MediaSourceBrowser>
+  <MediaImportInformation>
+    <keyboard>
+      <i>Back</i>
+    </keyboard>
+  </MediaImportInformation>
 </keymap>
diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index 350fbdd089f0..f514c8efaf68 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -59,6 +59,9 @@
 #include "windows/GUIWindowStartup.h"
 #include "windows/GUIWindowSystemInfo.h"
 
+#include "media/import/dialogs/GUIDialogMediaImportInfo.h"
+#include "media/import/windows/GUIWindowMediaSourceBrowser.h"
+
 // Dialog includes
 #include "music/dialogs/GUIDialogMusicOSD.h"
 #include "music/dialogs/GUIDialogVisualisationPresetList.h"
@@ -299,6 +302,9 @@ void CGUIWindowManager::CreateWindows()
   Add(new GAME::CDialogGameAdvancedSettings);
   Add(new GAME::CDialogGameVideoRotation);
   Add(new RETRO::CGameWindowFullScreen);
+
+  Add(new CGUIWindowMediaSourceBrowser);
+  Add(new CGUIDialogMediaImportInfo);
 }
 
 bool CGUIWindowManager::DestroyWindows()
diff --git a/xbmc/guilib/WindowIDs.h b/xbmc/guilib/WindowIDs.h
index 1cb9a691b37a..8c9da67ac519 100644
--- a/xbmc/guilib/WindowIDs.h
+++ b/xbmc/guilib/WindowIDs.h
@@ -41,6 +41,8 @@
 
 #define WINDOW_EVENT_LOG                  10050
 
+#define WINDOW_MEDIASOURCE_BROWSER        10060
+
 #define WINDOW_SCREENSAVER_DIM               97
 #define WINDOW_DEBUG_INFO                    98
 #define WINDOW_DIALOG_POINTER             10099
@@ -92,6 +94,7 @@
 #define WINDOW_DIALOG_INFOPROVIDER_SETTINGS 10158
 #define WINDOW_DIALOG_SUBTITLE_OSD_SETTINGS  10159
 #define WINDOW_DIALOG_BUSY_NOCANCEL       10160
+#define WINDOW_DIALOG_MEDIAIMPORT_INFO    10161
 
 #define WINDOW_MUSIC_PLAYLIST             10500
 #define WINDOW_MUSIC_NAV                  10502
diff --git a/xbmc/input/WindowTranslator.cpp b/xbmc/input/WindowTranslator.cpp
index 564582371a64..e6b1e7410790 100644
--- a/xbmc/input/WindowTranslator.cpp
+++ b/xbmc/input/WindowTranslator.cpp
@@ -152,6 +152,8 @@ const CWindowTranslator::WindowMapByName CWindowTranslator::WindowMappingByName
     {"gamevolume", WINDOW_DIALOG_GAME_VOLUME},
     {"gameadvancedsettings", WINDOW_DIALOG_GAME_ADVANCED_SETTINGS},
     {"gamevideorotation", WINDOW_DIALOG_GAME_VIDEO_ROTATION},
+    {"mediasourcebrowser", WINDOW_MEDIASOURCE_BROWSER},
+    {"mediaimportinformation", WINDOW_DIALOG_MEDIAIMPORT_INFO},
 };
 
 namespace
diff --git a/xbmc/media/import/dialogs/CMakeLists.txt b/xbmc/media/import/dialogs/CMakeLists.txt
new file mode 100644
index 000000000000..c778609b7fac
--- /dev/null
+++ b/xbmc/media/import/dialogs/CMakeLists.txt
@@ -0,0 +1,5 @@
+set(SOURCES GUIDialogMediaImportInfo.cpp)
+
+set(HEADERS GUIDialogMediaImportInfo.h)
+
+core_add_library(media_import_dialogs)
diff --git a/xbmc/media/import/dialogs/GUIDialogMediaImportInfo.cpp b/xbmc/media/import/dialogs/GUIDialogMediaImportInfo.cpp
new file mode 100644
index 000000000000..ab341343c978
--- /dev/null
+++ b/xbmc/media/import/dialogs/GUIDialogMediaImportInfo.cpp
@@ -0,0 +1,308 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "GUIDialogMediaImportInfo.h"
+
+#include "FileItem.h"
+#include "ServiceBroker.h"
+#include "filesystem/MediaImportDirectory.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/WindowIDs.h"
+#include "input/Key.h"
+#include "media/MediaType.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/MediaImportManager.h"
+#include "settings/lib/SettingsManager.h"
+#include "utils/Variant.h"
+#include "utils/log.h"
+
+#include <fmt/ostream.h>
+
+CGUIDialogMediaImportInfo::CGUIDialogMediaImportInfo()
+  : CGUIDialogSettingsManagerBase(WINDOW_DIALOG_MEDIAIMPORT_INFO, "DialogMediaImportInfo.xml"),
+    m_item(std::make_shared<CFileItem>()),
+    m_import(nullptr),
+    m_source(nullptr),
+    m_importer(nullptr),
+    m_logger(CServiceBroker::GetLogging().GetLogger("CGUIDialogMediaImportInfo"))
+{
+  m_loadType = KEEP_IN_MEMORY;
+}
+
+bool CGUIDialogMediaImportInfo::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+    case GUI_MSG_WINDOW_DEINIT:
+    {
+      // get rid of the CMediaImport instance
+      m_import.reset();
+      // get rid of the CMediaImportSource instance
+      m_source.reset();
+      // get rid of the IMediaImporter instance
+      m_importer.reset();
+
+      break;
+    }
+
+    case GUI_MSG_CLICKED:
+    {
+      if (message.GetSenderId() == CONTROL_SETTINGS_CUSTOM_BUTTON)
+      {
+        OnResetSettings();
+        return true;
+      }
+
+      break;
+    }
+
+    default:
+      break;
+  }
+
+  return CGUIDialogSettingsManagerBase::OnMessage(message);
+}
+
+bool CGUIDialogMediaImportInfo::OnAction(const CAction& action)
+{
+  if (action.GetID() == ACTION_SHOW_INFO)
+  {
+    OnOkay();
+    Close();
+    return true;
+  }
+
+  return CGUIDialogSettingsManagerBase::OnAction(action);
+}
+
+bool CGUIDialogMediaImportInfo::OnBack(int actionID)
+{
+  // handle this the same as cancelling the dialog
+  OnCancel();
+
+  return CGUIDialogSettingsManagerBase::OnBack(actionID);
+}
+
+bool CGUIDialogMediaImportInfo::ShowForMediaImport(const CFileItemPtr& item)
+{
+  if (item == nullptr)
+    return false;
+
+  auto dialog = static_cast<CGUIDialogMediaImportInfo*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_MEDIAIMPORT_INFO));
+  if (!dialog)
+    return false;
+
+  // TODO(Montellese): showing this dialog while the responsible importer or the matching import is
+  // being synchronized
+  //                   might have unexpected side effects
+
+  if (!dialog->SetMediaImport(item))
+    return false;
+
+  dialog->Open();
+  return dialog->IsConfirmed();
+}
+
+bool CGUIDialogMediaImportInfo::ShowForMediaImportSource(const CFileItemPtr& item)
+{
+  if (item == nullptr)
+    return false;
+
+  auto dialog = static_cast<CGUIDialogMediaImportInfo*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_MEDIAIMPORT_INFO));
+  if (!dialog)
+    return false;
+
+  // TODO(Montellese): showing this dialog while the responsible importer or the matching import is
+  // being synchronized
+  //                   might have unexpected side effects
+
+  if (!dialog->SetMediaImportSource(item))
+    return false;
+
+  dialog->Open();
+  return dialog->IsConfirmed();
+}
+
+std::string CGUIDialogMediaImportInfo::GetLocalizedString(uint32_t labelId) const
+{
+  // first try to get the localized string the common way
+  auto localizedString = CGUIDialogSettingsManagerBase::GetLocalizedString(labelId);
+  if (!localizedString.empty())
+    return localizedString;
+
+  // now try to get it from the importer
+  if (m_importer == nullptr)
+    return "";
+
+  return m_importer->Localize(labelId);
+}
+
+void CGUIDialogMediaImportInfo::OnCancel()
+{
+  if (m_import != nullptr)
+    m_importer->UnloadImportSettings(*m_import);
+  else if (m_source != nullptr)
+    m_importer->UnloadSourceSettings(*m_source);
+
+  CGUIDialogSettingsManagerBase::OnCancel();
+}
+
+void CGUIDialogMediaImportInfo::SetupView()
+{
+  InitializeSettings();
+
+  CGUIDialogSettingsManagerBase::SetupView();
+
+  // set heading
+  SetHeading(m_source != nullptr ? 39700 : 39701);
+
+  // set control labels
+  SET_CONTROL_LABEL(CONTROL_SETTINGS_OKAY_BUTTON, 186);
+  SET_CONTROL_LABEL(CONTROL_SETTINGS_CANCEL_BUTTON, 222);
+  SET_CONTROL_LABEL(CONTROL_SETTINGS_CUSTOM_BUTTON, 409);
+}
+
+std::shared_ptr<CSettingSection> CGUIDialogMediaImportInfo::GetSection()
+{
+  // for media sources with settings we provide a custom section
+  if (m_source != nullptr && m_source->Settings()->IsLoaded())
+  {
+    const auto sections = m_source->Settings()->GetSections();
+    if (!sections.empty())
+      return sections.front();
+  }
+  else if (m_import != nullptr && m_import->Settings()->IsLoaded())
+  {
+    const auto sections = m_import->Settings()->GetSections();
+    if (!sections.empty())
+      return sections.front();
+  }
+
+  return nullptr;
+}
+
+void CGUIDialogMediaImportInfo::Save()
+{
+  if (m_import != nullptr)
+  {
+    bool success = false;
+    if (m_importer->UnloadImportSettings(*m_import))
+      success = CServiceBroker::GetMediaImportManager().UpdateImport(*m_import);
+
+    if (success)
+      m_logger->info("settings for import {} saved", *m_import);
+    else
+      m_logger->error("failed to save settings for import {}", *m_import);
+  }
+  else if (m_source != nullptr)
+  {
+    bool success = false;
+    if (m_importer->UnloadSourceSettings(*m_source))
+      success = CServiceBroker::GetMediaImportManager().UpdateSource(*m_source);
+
+    if (success)
+      m_logger->info("settings for source {} saved", *m_source);
+    else
+      m_logger->error("failed to save settings for source {}", *m_source);
+  }
+}
+
+CSettingsManager* CGUIDialogMediaImportInfo::GetSettingsManager() const
+{
+  // for media sources with settings we provide a custom section
+  if (m_source != nullptr && m_source->Settings()->IsLoaded())
+    return m_source->Settings()->GetSettingsManager();
+  else if (m_import != nullptr && m_import->Settings()->IsLoaded())
+    return m_import->Settings()->GetSettingsManager();
+
+  return nullptr;
+}
+
+void CGUIDialogMediaImportInfo::InitializeSettings()
+{
+  if (m_import != nullptr)
+    InitializeMediaImportSettings();
+  else if (m_source != nullptr)
+    InitializeMediaImportSourceSettings();
+}
+
+void CGUIDialogMediaImportInfo::InitializeMediaImportSettings()
+{
+  if (m_importer == nullptr)
+    return;
+
+  if (!m_importer->LoadImportSettings(*m_import))
+    return;
+}
+
+void CGUIDialogMediaImportInfo::InitializeMediaImportSourceSettings()
+{
+  if (m_importer == nullptr)
+    return;
+
+  if (!m_importer->LoadSourceSettings(*m_source))
+    return;
+}
+
+bool CGUIDialogMediaImportInfo::SetMediaImport(const CFileItemPtr& item)
+{
+  if (!item->HasProperty(PROPERTY_SOURCE_IDENTIFIER) || !item->HasProperty(PROPERTY_IMPORT_PATH) ||
+      !item->HasProperty(PROPERTY_IMPORT_MEDIATYPES))
+    return false;
+
+  std::string importPath = item->GetProperty(PROPERTY_IMPORT_PATH).asString();
+  GroupedMediaTypes mediaTypes =
+      CMediaTypes::Split(item->GetProperty(PROPERTY_IMPORT_MEDIATYPES).asString());
+  if (importPath.empty() || mediaTypes.empty())
+    return false;
+
+  // get the import details
+  m_import = std::make_shared<CMediaImport>();
+  if (!CServiceBroker::GetMediaImportManager().GetImport(importPath, mediaTypes, *m_import))
+  {
+    m_import.reset();
+    return false;
+  }
+
+  // get a matching importer
+  m_importer = CServiceBroker::GetMediaImportManager().GetImporterBySource(m_import->GetSource());
+  if (m_importer == nullptr)
+    return false;
+
+  // copy the given item
+  *m_item = *item;
+
+  return true;
+}
+
+bool CGUIDialogMediaImportInfo::SetMediaImportSource(const CFileItemPtr& item)
+{
+  std::string sourceId = item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString();
+  if (sourceId.empty())
+    return false;
+
+  m_source = std::make_shared<CMediaImportSource>(sourceId);
+  if (!CServiceBroker::GetMediaImportManager().GetSource(sourceId, *m_source))
+  {
+    m_source.reset();
+    return false;
+  }
+
+  // get a matching importer
+  m_importer = CServiceBroker::GetMediaImportManager().GetImporterBySource(*m_source);
+  if (m_importer == nullptr)
+    return false;
+
+  // copy the given item
+  *m_item = *item;
+
+  return true;
+}
diff --git a/xbmc/media/import/dialogs/GUIDialogMediaImportInfo.h b/xbmc/media/import/dialogs/GUIDialogMediaImportInfo.h
new file mode 100644
index 000000000000..6cbe4b411d0e
--- /dev/null
+++ b/xbmc/media/import/dialogs/GUIDialogMediaImportInfo.h
@@ -0,0 +1,63 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/import/IMediaImporter.h"
+#include "settings/dialogs/GUIDialogSettingsManagerBase.h"
+#include "utils/logtypes.h"
+#include "view/GUIViewControl.h"
+
+#include <memory>
+
+class CFileItemList;
+class CMediaImport;
+class CMediaImportSource;
+
+class CGUIDialogMediaImportInfo : public CGUIDialogSettingsManagerBase
+{
+public:
+  CGUIDialogMediaImportInfo();
+  virtual ~CGUIDialogMediaImportInfo() = default;
+
+  // specialization of CGUIControl
+  bool OnMessage(CGUIMessage& message) override;
+  bool OnAction(const CAction& action) override;
+  bool OnBack(int actionID) override;
+
+  static bool ShowForMediaImport(const CFileItemPtr& item);
+  static bool ShowForMediaImportSource(const CFileItemPtr& item);
+
+protected:
+  // specialization of CGUIDialogSettingsBase
+  bool AllowResettingSettings() const override { return false; }
+  std::string GetLocalizedString(uint32_t labelId) const override;
+  void OnCancel() override;
+  void SetupView() override;
+
+  // implementation of CGUIDialogSettingsManagerBase
+  std::shared_ptr<CSettingSection> GetSection() override;
+
+  // implementation of CGUIDialogSettingsManagerBase
+  void Save() override;
+  CSettingsManager* GetSettingsManager() const override;
+
+  void InitializeSettings();
+  void InitializeMediaImportSettings();
+  void InitializeMediaImportSourceSettings();
+
+  bool SetMediaImport(const CFileItemPtr& item);
+  bool SetMediaImportSource(const CFileItemPtr& item);
+
+  CFileItemPtr m_item;
+  std::shared_ptr<CMediaImport> m_import;
+  std::shared_ptr<CMediaImportSource> m_source;
+  MediaImporterPtr m_importer;
+
+  Logger m_logger;
+};
diff --git a/xbmc/media/import/windows/CMakeLists.txt b/xbmc/media/import/windows/CMakeLists.txt
new file mode 100644
index 000000000000..4c5b5ddea682
--- /dev/null
+++ b/xbmc/media/import/windows/CMakeLists.txt
@@ -0,0 +1,7 @@
+set(SOURCES GUIViewStateMediaSourceBrowser.cpp
+            GUIWindowMediaSourceBrowser.cpp)
+
+set(HEADERS GUIViewStateMediaSourceBrowser.h
+            GUIWindowMediaSourceBrowser.h)
+
+core_add_library(media_import_windows)
diff --git a/xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.cpp b/xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.cpp
new file mode 100644
index 000000000000..dc6d137c0f7b
--- /dev/null
+++ b/xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.cpp
@@ -0,0 +1,88 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "GUIViewStateMediaSourceBrowser.h"
+
+#include "FileItem.h"
+#include "URL.h"
+#include "guilib/LocalizeStrings.h"
+#include "guilib/WindowIDs.h"
+#include "view/ViewState.h"
+#include "windowing/GraphicContext.h"
+
+CGUIViewStateMediaSourceBrowser::CGUIViewStateMediaSourceBrowser(const CFileItemList& items)
+  : CGUIViewState(items)
+{
+  CURL url(items.GetPath());
+
+  if (items.GetContent() == "sources" || items.GetContent() == "imports")
+  {
+    AddSortMethod(
+        SortByLabel, SortAttributeIgnoreFolders, 551,
+        LABEL_MASKS("%L", "%d", "%L", "%d")); // Filename, Date Time | Foldername, Date Time
+    AddSortMethod(
+        SortByDate, SortAttributeIgnoreFolders, 579,
+        LABEL_MASKS("%L", "%d", "%L", "%d")); // Filename, Date Time | Foldername, Date Time
+
+    SetSortMethod(SortByLabel);
+    SetSortOrder(SortOrderAscending);
+  }
+  else
+  {
+    SetSortMethod(SortByNone);
+    SetSortOrder(SortOrderNone);
+  }
+
+  SetViewAsControl(DEFAULT_VIEW_AUTO);
+
+  LoadViewState(items.GetPath(), WINDOW_MEDIASOURCE_BROWSER);
+}
+
+void CGUIViewStateMediaSourceBrowser::SaveViewState()
+{
+  SaveViewToDb(m_items.GetPath(), WINDOW_MEDIASOURCE_BROWSER);
+}
+
+std::string CGUIViewStateMediaSourceBrowser::GetExtensions()
+{
+  return "";
+}
+
+VECSOURCES& CGUIViewStateMediaSourceBrowser::GetSources()
+{
+  m_sources.clear();
+
+  // all sources
+  {
+    CMediaSource source;
+    source.strPath = "import://all/";
+    source.m_iDriveType = CMediaSource::SOURCE_TYPE_LOCAL;
+    source.strName = g_localizeStrings.Get(39573);
+    m_sources.push_back(source);
+  }
+
+  // active sources
+  {
+    CMediaSource source;
+    source.strPath = "import://active/";
+    source.m_iDriveType = CMediaSource::SOURCE_TYPE_LOCAL;
+    source.strName = g_localizeStrings.Get(39574);
+    m_sources.push_back(source);
+  }
+
+  // inactive sources
+  {
+    CMediaSource source;
+    source.strPath = "import://inactive/";
+    source.m_iDriveType = CMediaSource::SOURCE_TYPE_LOCAL;
+    source.strName = g_localizeStrings.Get(39575);
+    m_sources.push_back(source);
+  }
+
+  return CGUIViewState::GetSources();
+}
diff --git a/xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.h b/xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.h
new file mode 100644
index 000000000000..edccbfb1ee1c
--- /dev/null
+++ b/xbmc/media/import/windows/GUIViewStateMediaSourceBrowser.h
@@ -0,0 +1,24 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "view/GUIViewState.h"
+
+class CGUIViewStateMediaSourceBrowser : public CGUIViewState
+{
+public:
+  CGUIViewStateMediaSourceBrowser(const CFileItemList& items);
+  ~CGUIViewStateMediaSourceBrowser() = default;
+
+protected:
+  // implementation of CGUIViewState
+  virtual void SaveViewState();
+  virtual std::string GetExtensions();
+  virtual VECSOURCES& GetSources();
+};
diff --git a/xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp b/xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
new file mode 100644
index 000000000000..b80379a05488
--- /dev/null
+++ b/xbmc/media/import/windows/GUIWindowMediaSourceBrowser.cpp
@@ -0,0 +1,908 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "GUIWindowMediaSourceBrowser.h"
+
+#include "FileItem.h"
+#include "GUIUserMessages.h"
+#include "ServiceBroker.h"
+#include "URL.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "dialogs/GUIDialogSelect.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "filesystem/MediaImportDirectory.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIKeyboardFactory.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "guilib/WindowIDs.h"
+#include "input/Key.h"
+#include "media/MediaType.h"
+#include "media/import/MediaImportManager.h"
+#include "media/import/dialogs/GUIDialogMediaImportInfo.h"
+#include "messaging/helpers/DialogOKHelper.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/log.h"
+
+#include <algorithm>
+
+#include <fmt/ostream.h>
+
+using namespace std;
+
+CGUIWindowMediaSourceBrowser::CGUIWindowMediaSourceBrowser()
+  : CGUIMediaWindow(WINDOW_MEDIASOURCE_BROWSER, "MediaSourceBrowser.xml"),
+    m_logger(CServiceBroker::GetLogging().GetLogger("CGUIWindowMediaSourceBrowser"))
+{
+}
+
+std::string CGUIWindowMediaSourceBrowser::ShowAndGetImporterToLookup(
+    const std::vector<MediaImporterPtr>& importers)
+{
+  if (importers.empty())
+    return "";
+
+  // show the select dialog with all the importers which support source lookups
+  auto selectDialog = static_cast<CGUIDialogSelect*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_SELECT));
+  if (selectDialog == nullptr)
+    return "";
+
+  selectDialog->Reset();
+  selectDialog->SetHeading(39600);
+  selectDialog->SetMultiSelection(false);
+
+  for (const auto& importer : importers)
+  {
+    CFileItem item(importer->GetSourceLookupProtocol());
+    item.SetPath(importer->GetIdentification()); // abuse the identification of the importer
+    selectDialog->Add(item);
+  }
+
+  selectDialog->Open();
+
+  if (!selectDialog->IsConfirmed() || selectDialog->GetSelectedFileItem() == nullptr)
+    return "";
+
+  return selectDialog->GetSelectedFileItem()->GetPath();
+}
+
+std::string CGUIWindowMediaSourceBrowser::ShowAndGetMediaSourcesToImportFrom(
+    const GroupedMediaTypes& mediaTypes /* = GroupedMediaTypes() */)
+{
+  // get all available sources
+  std::vector<CMediaImportSource> sources = CServiceBroker::GetMediaImportManager().GetSources();
+
+  for (std::vector<CMediaImportSource>::iterator source = sources.begin(); source != sources.end();)
+  {
+    // get all imports for the source
+    auto imports =
+        CServiceBroker::GetMediaImportManager().GetImportsBySource(source->GetIdentifier());
+
+    // put together all already imported media types for the source
+    std::set<MediaType> importedMediaTypes;
+    for (const auto& import : imports)
+      importedMediaTypes.insert(import.GetMediaTypes().begin(), import.GetMediaTypes().end());
+
+    const auto& availableMediaTypes = source->GetAvailableMediaTypes();
+    if (!source->IsActive() ||
+        std::all_of(availableMediaTypes.begin(), availableMediaTypes.end(),
+                    [&importedMediaTypes](const MediaType& mediaType) -> bool {
+                      return importedMediaTypes.find(mediaType) != importedMediaTypes.end();
+                    }))
+    {
+      source = sources.erase(source);
+      continue;
+    }
+
+    ++source;
+  }
+
+  if (sources.empty())
+    return "";
+
+  // show the select dialog with all the sources from which we can import
+  auto selectDialog = static_cast<CGUIDialogSelect*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_SELECT));
+  if (selectDialog == nullptr)
+    return "";
+
+  selectDialog->Reset();
+  selectDialog->SetHeading(39600);
+  selectDialog->SetMultiSelection(false);
+
+  for (const auto& source : sources)
+  {
+    CFileItem item(source.GetFriendlyName());
+    item.SetPath(source.GetIdentifier()); // abuse the path for the media source's identification
+
+    selectDialog->Add(item);
+  }
+
+  selectDialog->Open();
+
+  if (!selectDialog->IsConfirmed() || selectDialog->GetSelectedFileItem() == nullptr)
+    return "";
+
+  return selectDialog->GetSelectedFileItem()->GetPath();
+}
+
+GroupedMediaTypes CGUIWindowMediaSourceBrowser::ShowAndGetMediaTypesToImport(
+    const std::string& sourceID)
+{
+  GroupedMediaTypes mediaTypesToImport;
+
+  if (sourceID.empty())
+    return mediaTypesToImport;
+
+  CMediaImportSource source(sourceID);
+  if (!CServiceBroker::GetMediaImportManager().GetSource(sourceID, source))
+    return mediaTypesToImport;
+
+  return ShowAndGetMediaTypesToImport(source);
+}
+
+GroupedMediaTypes CGUIWindowMediaSourceBrowser::ShowAndGetMediaTypesToImport(
+    const CMediaImportSource& source)
+{
+  GroupedMediaTypes mediaTypesToImport;
+
+  if (source.GetIdentifier().empty() || source.GetFriendlyName().empty() ||
+      source.GetAvailableMediaTypes().empty())
+    return mediaTypesToImport;
+
+  // put together a list of media types that are available for the source and haven't been imported
+  // yet
+  MediaTypes unimportedMediaTypes = source.GetAvailableMediaTypes();
+  std::vector<CMediaImport> imports =
+      CServiceBroker::GetMediaImportManager().GetImportsBySource(source.GetIdentifier());
+  for (const auto& import : imports)
+  {
+    for (const auto& mediaType : import.GetMediaTypes())
+      unimportedMediaTypes.erase(mediaType);
+  }
+
+  // show the select dialog with all the media types available for import
+  auto selectDialog = static_cast<CGUIDialogSelect*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_SELECT));
+  if (selectDialog != nullptr)
+  {
+    selectDialog->Reset();
+    selectDialog->SetHeading(39555);
+    selectDialog->SetMultiSelection(false);
+
+    CFileItemList items;
+    if (!GetMediaTypesToImport(unimportedMediaTypes, items))
+      return mediaTypesToImport;
+
+    selectDialog->SetItems(items);
+    selectDialog->Open();
+
+    if (selectDialog->IsConfirmed() && selectDialog->GetSelectedFileItem() != nullptr)
+      return StringUtils::Split(selectDialog->GetSelectedFileItem()->GetPath(), ",");
+  }
+
+  return mediaTypesToImport;
+}
+
+bool CGUIWindowMediaSourceBrowser::GetMediaTypesToImport(const MediaTypes& availableMediaTypes,
+                                                         CFileItemList& items)
+{
+  if (availableMediaTypes.empty())
+    return false;
+
+  std::vector<GroupedMediaTypes> supportedMediaTypes =
+      CServiceBroker::GetMediaImportManager().GetSupportedMediaTypesGrouped(availableMediaTypes);
+  if (supportedMediaTypes.empty())
+    return false;
+
+  for (const auto& itSupportedMediaType : supportedMediaTypes)
+  {
+    CFileItemPtr pItem(new CFileItem(CMediaTypes::ToLabel(itSupportedMediaType)));
+    pItem->SetPath(CMediaTypes::Join(
+        itSupportedMediaType)); // abuse the path for the media type's identification
+
+    items.Add(pItem);
+  }
+
+  return true;
+}
+
+bool CGUIWindowMediaSourceBrowser::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+    case GUI_MSG_WINDOW_INIT:
+    {
+      m_rootDir.AllowNonLocalSources(false);
+
+      // is this the first time the window is opened?
+      if (m_vecItems->GetPath() == "?" && message.GetStringParam().empty())
+        m_vecItems->SetPath("");
+      break;
+    }
+
+    case GUI_MSG_WINDOW_DEINIT:
+    {
+      break;
+    }
+
+    case GUI_MSG_CLICKED:
+    {
+      int iControl = message.GetSenderId();
+      if (m_viewControl.HasControl(iControl)) // list/thumb control
+      {
+        // get selected item
+        int itemIndex = m_viewControl.GetSelectedItem();
+        int actionId = message.GetParam1();
+
+        if (actionId == ACTION_SHOW_INFO || actionId == ACTION_DELETE_ITEM)
+        {
+          CFileItemPtr item = m_vecItems->Get(itemIndex);
+          if (item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).empty())
+            return false;
+
+          if (item->GetProperty(PROPERTY_IMPORT_PATH).empty())
+          {
+            if (actionId == ACTION_SHOW_INFO)
+              return OnSourceInfo(item);
+            else if (actionId == ACTION_DELETE_ITEM)
+              return OnSourceDelete(item);
+          }
+          else
+          {
+            if (actionId == ACTION_SHOW_INFO)
+              return OnImportInfo(item);
+            else if (actionId == ACTION_DELETE_ITEM)
+              return OnImportDelete(item);
+          }
+        }
+      }
+      break;
+    }
+
+    case GUI_MSG_NOTIFY_ALL:
+    {
+      CGUIListItemPtr item = message.GetItem();
+      if (item == nullptr)
+        break;
+
+      switch (message.GetParam1())
+      {
+        case GUI_MSG_SOURCE_ADDED:
+        {
+          OnSourceAdded(message.GetItem()->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString());
+          return true;
+        }
+
+        case GUI_MSG_SOURCE_UPDATED:
+        {
+          OnSourceUpdated(message.GetItem()->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString());
+          return true;
+        }
+
+        case GUI_MSG_SOURCE_REMOVED:
+        {
+          OnSourceRemoved(message.GetItem()->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString());
+          return true;
+        }
+
+        case GUI_MSG_SOURCE_ACTIVE_CHANGED:
+        {
+          OnSourceIsActiveChanged(
+              message.GetItem()->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString(),
+              message.GetParam1() > 0);
+          return true;
+        }
+
+        case GUI_MSG_IMPORT_ADDED:
+        {
+          OnImportAdded(
+              item->GetProperty(PROPERTY_IMPORT_PATH).asString(),
+              CMediaTypes::Split(item->GetProperty(PROPERTY_IMPORT_MEDIATYPES).asString()));
+          return true;
+        }
+
+        case GUI_MSG_IMPORT_UPDATED:
+        {
+          OnImportUpdated(
+              item->GetProperty(PROPERTY_IMPORT_PATH).asString(),
+              CMediaTypes::Split(item->GetProperty(PROPERTY_IMPORT_MEDIATYPES).asString()));
+          return true;
+        }
+
+        case GUI_MSG_IMPORT_REMOVED:
+        {
+          OnImportRemoved(
+              item->GetProperty(PROPERTY_IMPORT_PATH).asString(),
+              CMediaTypes::Split(item->GetProperty(PROPERTY_IMPORT_MEDIATYPES).asString()));
+          return true;
+        }
+
+        default:
+          break;
+      }
+    }
+
+    default:
+      break;
+  }
+  return CGUIMediaWindow::OnMessage(message);
+}
+
+bool CGUIWindowMediaSourceBrowser::RefreshList(bool keepSelectedItem /* = true */)
+{
+  std::string currentItemPath;
+  if (keepSelectedItem)
+  {
+    int itemIndex = m_viewControl.GetSelectedItem();
+    if (itemIndex >= 0 && itemIndex < m_vecItems->Size())
+      currentItemPath = m_vecItems->Get(itemIndex)->GetPath();
+  }
+
+  bool result = Refresh(true);
+
+  if (keepSelectedItem && !currentItemPath.empty())
+    m_viewControl.SetSelectedItem(currentItemPath);
+
+  return result;
+}
+
+bool CGUIWindowMediaSourceBrowser::OnSourceSynchronise(const CFileItemPtr& item)
+{
+  if (item == nullptr)
+    return false;
+
+  if (CServiceBroker::GetMediaImportManager().Import(
+          item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString()))
+    return true;
+
+  KODI::MESSAGING::HELPERS::ShowOKDialogText(
+      39610, StringUtils::Format(g_localizeStrings.Get(39611), item->GetLabel()));
+  return false;
+}
+
+bool CGUIWindowMediaSourceBrowser::OnSourceInfo(const CFileItemPtr& item)
+{
+  if (item == nullptr)
+    return false;
+
+  // only active sources can be configured because the configuration might require interaction with
+  // the source
+  if (!item->GetProperty(PROPERTY_SOURCE_ISACTIVE).asBoolean())
+  {
+    KODI::MESSAGING::HELPERS::ShowOKDialogText(
+        39700, StringUtils::Format(g_localizeStrings.Get(39614), item->GetLabel()));
+    return false;
+  }
+
+  return CGUIDialogMediaImportInfo::ShowForMediaImportSource(item);
+}
+
+bool CGUIWindowMediaSourceBrowser::OnSourceDelete(const CFileItemPtr& item)
+{
+  if (item == nullptr)
+    return false;
+
+  auto pDialog = static_cast<CGUIDialogYesNo*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_YES_NO));
+  if (pDialog == nullptr)
+    return false;
+
+  pDialog->SetHeading(39602);
+  pDialog->SetText(StringUtils::Format(g_localizeStrings.Get(39603), item->GetLabel()));
+
+  pDialog->Open();
+
+  if (!pDialog->IsConfirmed())
+    return false;
+
+  CServiceBroker::GetMediaImportManager().RemoveSource(
+      item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString());
+  return true;
+}
+
+bool CGUIWindowMediaSourceBrowser::OnImportSynchronise(const CFileItemPtr& item)
+{
+  if (item == nullptr)
+    return false;
+
+  if (CServiceBroker::GetMediaImportManager().Import(
+          item->GetProperty(PROPERTY_IMPORT_PATH).asString(),
+          CMediaTypes::Split(item->GetProperty(PROPERTY_IMPORT_MEDIATYPES).asString())))
+    return true;
+
+  KODI::MESSAGING::HELPERS::ShowOKDialogText(
+      39612, StringUtils::Format(g_localizeStrings.Get(39613), item->GetLabel()));
+  return false;
+}
+
+bool CGUIWindowMediaSourceBrowser::OnImportInfo(const CFileItemPtr& item)
+{
+  if (item == nullptr)
+    return false;
+
+  // only imports with active and ready sources can be configured because the configuration might
+  // require interaction with the source
+  if (!item->GetProperty(PROPERTY_SOURCE_ISACTIVE).asBoolean() ||
+      !item->GetProperty(PROPERTY_SOURCE_ISREADY).asBoolean())
+  {
+    KODI::MESSAGING::HELPERS::ShowOKDialogText(
+        39701, StringUtils::Format(g_localizeStrings.Get(39615), item->GetLabel()));
+    return false;
+  }
+
+  return CGUIDialogMediaImportInfo::ShowForMediaImport(item);
+}
+
+bool CGUIWindowMediaSourceBrowser::OnImportDelete(const CFileItemPtr& item)
+{
+  if (item == nullptr)
+    return false;
+
+  auto pDialog = static_cast<CGUIDialogYesNo*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_YES_NO));
+  if (pDialog == nullptr)
+    return false;
+
+  std::string sourceID = item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString();
+  std::string importPath = item->GetProperty(PROPERTY_IMPORT_PATH).asString();
+  GroupedMediaTypes mediaTypes =
+      CMediaTypes::Split(item->GetProperty(PROPERTY_IMPORT_MEDIATYPES).asString());
+
+  pDialog->SetHeading(39604);
+  pDialog->SetText(StringUtils::Format(g_localizeStrings.Get(39603), item->GetLabel()));
+
+  pDialog->Open();
+
+  if (!pDialog->IsConfirmed())
+    return false;
+
+  CServiceBroker::GetMediaImportManager().RemoveImport(importPath, mediaTypes);
+  return true;
+}
+
+void CGUIWindowMediaSourceBrowser::OnSourceAdded(const std::string& sourceId)
+{
+  if (m_vecItems->GetContent() == "sources")
+    RefreshList(true);
+}
+
+void CGUIWindowMediaSourceBrowser::OnSourceUpdated(const std::string& sourceId)
+{
+  if (m_vecItems->GetContent() == "sources")
+  {
+    // only refresh the list if the updated source is part of it
+    CFileItemPtr item = GetSourceItem(sourceId);
+    if (item != nullptr)
+      RefreshList(true);
+  }
+}
+
+void CGUIWindowMediaSourceBrowser::OnSourceRemoved(const std::string& sourceId)
+{
+  if (m_vecItems->GetContent() == "sources")
+  {
+    // only refresh the list if the removed source is part of it
+    CFileItemPtr item = GetSourceItem(sourceId);
+    if (item != nullptr)
+    {
+      int selectedItemIndex = m_viewControl.GetSelectedItem();
+      // only update the selected item index when the deleted item is focused
+      if (m_vecItems->Get(selectedItemIndex) != item)
+        selectedItemIndex = -1;
+
+      RefreshList(false);
+
+      if (selectedItemIndex >= 0)
+        m_viewControl.SetSelectedItem(selectedItemIndex);
+    }
+  }
+}
+
+void CGUIWindowMediaSourceBrowser::OnImportAdded(const std::string& importPath,
+                                                 const GroupedMediaTypes& mediaTypes)
+{
+  if (m_vecItems->GetContent() == "imports")
+    RefreshList(true);
+}
+
+void CGUIWindowMediaSourceBrowser::OnImportUpdated(const std::string& importPath,
+                                                   const GroupedMediaTypes& mediaTypes)
+{
+  if (m_vecItems->GetContent() == "imports")
+  {
+    // only refresh the list if the updated import is part of it
+    CFileItemPtr item = GetImportItem(importPath, mediaTypes);
+    if (item != nullptr)
+      RefreshList(true);
+  }
+}
+
+void CGUIWindowMediaSourceBrowser::OnImportRemoved(const std::string& importPath,
+                                                   const GroupedMediaTypes& mediaTypes)
+{
+  if (m_vecItems->GetContent() == "imports")
+  {
+    // only refresh the list if the removed import is part of it
+    CFileItemPtr item = GetImportItem(importPath, mediaTypes);
+    if (item != nullptr)
+    {
+      int selectedItemIndex = m_viewControl.GetSelectedItem();
+      // only update the selected item index when the deleted item is focused
+      if (m_vecItems->Get(selectedItemIndex) != item)
+        selectedItemIndex = -1;
+
+      RefreshList(false);
+
+      if (selectedItemIndex >= 0)
+        m_viewControl.SetSelectedItem(selectedItemIndex);
+    }
+  }
+}
+
+void CGUIWindowMediaSourceBrowser::OnSourceIsActiveChanged(const std::string& sourceId,
+                                                           bool isactive)
+{
+  RefreshList(true);
+
+  // if the source was just manually added by the user open the info dialog
+  if (m_manuallyAddedSourceId == sourceId)
+  {
+    m_manuallyAddedSourceId.clear();
+
+    CMediaImportSource addedSource;
+    if (CServiceBroker::GetMediaImportManager().GetSource(sourceId, addedSource))
+    {
+      CFileItemPtr sourceItem = XFILE::CMediaImportDirectory::FileItemFromMediaImportSource(
+          addedSource, m_vecItems->GetPath());
+      if (sourceItem != nullptr)
+      {
+        auto selectedItemPath = m_viewControl.GetSelectedItemPath();
+        // now select the new import so that it will be available to skins in the source info dialog
+        m_viewControl.SetSelectedItem(sourceItem->GetPath());
+
+        // and now finally open the source info dialog
+        OnSourceInfo(sourceItem);
+
+        // now see if the add source button is still there and if so re-select it
+        if (m_vecItems->Contains(selectedItemPath))
+          m_viewControl.SetSelectedItem(selectedItemPath);
+      }
+    }
+  }
+}
+
+CFileItemPtr CGUIWindowMediaSourceBrowser::GetImportItem(const std::string& importPath,
+                                                         const GroupedMediaTypes& mediaTypes) const
+{
+  for (int index = 0; index < m_vecItems->Size(); index++)
+  {
+    CFileItemPtr item = m_vecItems->Get(index);
+    if (item->IsParentFolder())
+      continue;
+
+    if (item->GetProperty(PROPERTY_IMPORT_PATH).asString() == importPath &&
+        CMediaTypes::Split(item->GetProperty(PROPERTY_IMPORT_MEDIATYPES).asString()) == mediaTypes)
+      return item;
+  }
+
+  return CFileItemPtr();
+}
+
+CFileItemPtr CGUIWindowMediaSourceBrowser::GetSourceItem(const std::string& sourceId) const
+{
+  for (int index = 0; index < m_vecItems->Size(); index++)
+  {
+    CFileItemPtr item = m_vecItems->Get(index);
+    if (item->IsParentFolder())
+      continue;
+
+    if (item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString() == sourceId)
+      return item;
+  }
+
+  return CFileItemPtr();
+}
+
+bool CGUIWindowMediaSourceBrowser::GetDirectory(const std::string& strDirectory,
+                                                CFileItemList& items)
+{
+  if (!CGUIMediaWindow::GetDirectory(strDirectory, items))
+    return false;
+
+  CURL url(strDirectory);
+  // "Add import" button for imports by media provider views
+  if (items.GetContent() == "imports")
+  {
+    bool addNewImport = false;
+    std::string addImportPath = "newimport://";
+    std::string sourceDir = strDirectory;
+    URIUtils::RemoveSlashAtEnd(sourceDir);
+    std::string sourceID;
+    if (url.GetHostName() == "all" || url.GetHostName() == "active")
+      sourceID = url.GetFileName();
+    else if (url.GetHostName() != "inactive")
+      sourceID = url.GetHostName();
+    URIUtils::RemoveSlashAtEnd(sourceID);
+    sourceID = CURL::Decode(sourceID);
+
+    addImportPath += CURL::Encode(sourceID);
+    CMediaImportSource source(sourceID);
+    if (CServiceBroker::GetMediaImportManager().GetSource(sourceID, source) && source.IsActive() &&
+        CServiceBroker::GetMediaImportManager().IsSourceReady(source))
+    {
+      // count the number of media types already being imported for a source
+      size_t importedMediaTypesCount = 0;
+      for (const auto& import :
+           CServiceBroker::GetMediaImportManager().GetImportsBySource(sourceID))
+        importedMediaTypesCount += import.GetMediaTypes().size();
+
+      // check if all media types are already being imported or not
+      if (importedMediaTypesCount < source.GetAvailableMediaTypes().size())
+        addNewImport = true;
+    }
+
+    if (addNewImport && !items.Contains(addImportPath))
+    {
+      CFileItemPtr addImport(new CFileItem(addImportPath, false));
+      addImport->SetLabel(g_localizeStrings.Get(39606));
+      addImport->SetLabelPreformatted(true);
+      addImport->SetSpecialSort(SortSpecialOnBottom);
+      items.Add(addImport);
+    }
+  }
+  else if (items.GetContent() == "sources")
+  {
+    bool addNewSource = false;
+    std::string addSourcePath = "newsource://";
+    if (url.GetHostName() == "all" || url.GetHostName() == "active")
+    {
+      const auto importers = CServiceBroker::GetMediaImportManager().GetImporters();
+      addNewSource = std::any_of(importers.begin(), importers.end(),
+                                 [](const MediaImporterFactoryConstPtr& importer) {
+                                   return importer->CreateImporter()->CanLookupSource();
+                                 });
+    }
+
+    if (addNewSource && !items.Contains(addSourcePath))
+    {
+      CFileItemPtr addSource(new CFileItem(addSourcePath, false));
+      addSource->SetLabel(g_localizeStrings.Get(39605));
+      addSource->SetLabelPreformatted(true);
+      addSource->SetSpecialSort(SortSpecialOnBottom);
+      items.Add(addSource);
+    }
+  }
+
+  return true;
+}
+
+std::string CGUIWindowMediaSourceBrowser::GetStartFolder(const std::string& dir)
+{
+  if (StringUtils::StartsWithNoCase(dir, "import://"))
+    return dir;
+
+  return CGUIMediaWindow::GetStartFolder(dir);
+}
+
+void CGUIWindowMediaSourceBrowser::GetContextButtons(int itemNumber, CContextButtons& buttons)
+{
+  CFileItemPtr item = m_vecItems->Get(itemNumber);
+  const std::string sourceId = item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString();
+  bool isSource = !sourceId.empty() && !item->HasProperty(PROPERTY_IMPORT_PATH);
+  bool isImport = !sourceId.empty() && item->HasProperty(PROPERTY_IMPORT_PATH) &&
+                  item->HasProperty(PROPERTY_IMPORT_MEDIATYPES);
+  bool isActive = item->GetProperty(PROPERTY_SOURCE_ISACTIVE).asBoolean();
+  bool isReady = item->GetProperty(PROPERTY_SOURCE_ISREADY).asBoolean();
+
+  if (!isSource && !isImport)
+    return;
+
+  if (isActive)
+  {
+    // only allow synchronisation of the source is active and ready and has imports
+    if (isReady &&
+        (isImport || (isSource && CServiceBroker::GetMediaImportManager().HasImports(sourceId))))
+      buttons.Add(CONTEXT_BUTTON_SCAN, g_localizeStrings.Get(39607));
+
+    // only allow to open the info dialog for (active) sources and for (active and) ready imports
+    if (isSource || isReady)
+      buttons.Add(CONTEXT_BUTTON_INFO, g_localizeStrings.Get(19033));
+  }
+
+  buttons.Add(CONTEXT_BUTTON_DELETE, g_localizeStrings.Get(15015));
+}
+
+bool CGUIWindowMediaSourceBrowser::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  CFileItemPtr item = m_vecItems->Get(itemNumber);
+  bool isSource = !item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).empty() &&
+                  !item->HasProperty(PROPERTY_IMPORT_PATH);
+
+  switch (button)
+  {
+    case CONTEXT_BUTTON_SCAN:
+    {
+      if (isSource)
+        return OnSourceSynchronise(item);
+      else
+        return OnImportSynchronise(item);
+      break;
+    }
+
+    case CONTEXT_BUTTON_INFO:
+    {
+      if (isSource)
+        return OnSourceInfo(item);
+      else
+        return OnImportInfo(item);
+      break;
+    }
+
+    case CONTEXT_BUTTON_DELETE:
+    {
+      if (isSource)
+        return OnSourceDelete(item);
+      else
+        return OnImportDelete(item);
+      break;
+    }
+
+    default:
+      break;
+  }
+
+  return CGUIMediaWindow::OnContextButton(itemNumber, button);
+}
+
+bool CGUIWindowMediaSourceBrowser::OnClick(int iItem, const std::string& player /* = "" */)
+{
+  CFileItemPtr item = m_vecItems->Get(iItem);
+  CURL url(item->GetPath());
+
+  auto& mediaImportManager = CServiceBroker::GetMediaImportManager();
+
+  if (url.GetProtocol() == "newimport")
+    return AddNewImport(item, url);
+
+  if (url.GetProtocol() == "newsource")
+    return AddNewSource(item, url);
+
+  const std::string sourceId = item->GetProperty(PROPERTY_SOURCE_IDENTIFIER).asString();
+  if (!item->m_bIsFolder)
+  {
+    // if the item is a media import show the info dialog
+    if (!sourceId.empty() && item->HasProperty(PROPERTY_IMPORT_PATH) &&
+        item->HasProperty(PROPERTY_IMPORT_MEDIATYPES))
+      return OnImportInfo(item);
+  }
+  else if (!sourceId.empty())
+  {
+    // if the source is active but not ready and does not have any imports open the info dialog
+    if (item->GetProperty(PROPERTY_SOURCE_ISACTIVE).asBoolean() &&
+        !item->GetProperty(PROPERTY_SOURCE_ISREADY).asBoolean() &&
+        !mediaImportManager.HasImports(sourceId))
+      return OnSourceInfo(item);
+  }
+
+  return CGUIMediaWindow::OnClick(iItem);
+}
+
+bool CGUIWindowMediaSourceBrowser::AddNewImport(CFileItemPtr newImportItem, const CURL& url)
+{
+  std::string sourceID = CURL::Decode(url.GetHostName());
+  if (sourceID.empty())
+    return false;
+
+  // ask the user what media type to add as an import
+  GroupedMediaTypes mediaTypesToImport = ShowAndGetMediaTypesToImport(sourceID);
+  if (mediaTypesToImport.empty())
+    return true;
+
+  auto& mediaImportManager = CServiceBroker::GetMediaImportManager();
+
+  // add the new import (they aren't automatically synchronised)
+  if (!mediaImportManager.AddRecursiveImport(sourceID, sourceID, mediaTypesToImport))
+  {
+    KODI::MESSAGING::HELPERS::ShowOKDialogText(39608, g_localizeStrings.Get(39609));
+    return false;
+  }
+
+  // show the info dialog for the new import
+  CMediaImport import;
+  if (mediaImportManager.GetImport(sourceID, mediaTypesToImport, import))
+  {
+    CFileItemPtr importItem =
+        XFILE::CMediaImportDirectory::FileItemFromMediaImport(import, m_vecItems->GetPath());
+    if (importItem != nullptr)
+    {
+      // refresh the list so that the new import is listed
+      RefreshList(false);
+
+      // now select the new import so that it will be available to skins in the import info dialog
+      m_viewControl.SetSelectedItem(importItem->GetPath());
+
+      // and now finally open the import info dialog
+      OnImportInfo(importItem);
+
+      // now see if the add import button is still there and if so re-select it
+      if (m_vecItems->Contains(newImportItem->GetPath()))
+        m_viewControl.SetSelectedItem(newImportItem->GetPath());
+    }
+  }
+
+  // now try to synchronise the newly added import
+  mediaImportManager.Import(sourceID, mediaTypesToImport);
+
+  return true;
+}
+
+bool CGUIWindowMediaSourceBrowser::AddNewSource(CFileItemPtr newImportItem, const CURL& url)
+{
+  auto& mediaImportManager = CServiceBroker::GetMediaImportManager();
+
+  // get all importers which support source lookup
+  auto importerFactories = mediaImportManager.GetImporters();
+  std::vector<MediaImporterPtr> importers;
+  for (const auto& importerFactory : importerFactories)
+  {
+    auto importer = importerFactory->CreateImporter();
+    if (importer->CanLookupSource())
+      importers.push_back(std::move(importer));
+  }
+
+  const auto importerId = ShowAndGetImporterToLookup(importers);
+  if (importerId.empty())
+    return true;
+
+  const auto selectedImporter = std::find_if(importers.begin(), importers.end(),
+                                             [importerId](const MediaImporterPtr& importer) {
+                                               return importer->GetIdentification() == importerId;
+                                             });
+  if (selectedImporter == importers.end())
+    return true;
+
+  CMediaImportSource discoveredSource;
+  if (!mediaImportManager.DiscoverSource(importerId, discoveredSource))
+  {
+    m_logger->warn("failed to discover source with importer \"{}\"", importerId);
+    KODI::MESSAGING::HELPERS::ShowOKDialogText(
+        CVariant{(*selectedImporter)->GetSourceLookupProtocol()},
+        CVariant{g_localizeStrings.Get(39618)});
+    return false;
+  }
+
+  CMediaImportSource existingSource;
+  if (mediaImportManager.GetSource(discoveredSource.GetIdentifier(), existingSource))
+  {
+    m_logger->info("source {} at \"{}\" already exists", discoveredSource,
+                   discoveredSource.GetBasePath());
+    KODI::MESSAGING::HELPERS::ShowOKDialogText(
+        CVariant{(*selectedImporter)->GetSourceLookupProtocol()},
+        CVariant{
+            StringUtils::Format(g_localizeStrings.Get(39619), discoveredSource.GetFriendlyName())});
+    return true;
+  }
+
+  bool result = mediaImportManager.AddAndActivateSourceManually(discoveredSource);
+  if (!result)
+  {
+    m_logger->error("failed to add discovered source {} at \"{}\"", discoveredSource,
+                    discoveredSource.GetBasePath());
+    KODI::MESSAGING::HELPERS::ShowOKDialogText(
+        CVariant{(*selectedImporter)->GetSourceLookupProtocol()},
+        CVariant{g_localizeStrings.Get(39618)});
+    return false;
+  }
+
+  m_manuallyAddedSourceId = discoveredSource.GetIdentifier();
+  return true;
+}
diff --git a/xbmc/media/import/windows/GUIWindowMediaSourceBrowser.h b/xbmc/media/import/windows/GUIWindowMediaSourceBrowser.h
new file mode 100644
index 000000000000..d5c972f2f4c6
--- /dev/null
+++ b/xbmc/media/import/windows/GUIWindowMediaSourceBrowser.h
@@ -0,0 +1,73 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "media/MediaType.h"
+#include "media/import/IMediaImporter.h"
+#include "media/import/MediaImportSource.h"
+#include "utils/logtypes.h"
+#include "windows/GUIMediaWindow.h"
+
+#include <set>
+#include <string>
+
+class CGUIWindowMediaSourceBrowser : public CGUIMediaWindow
+{
+public:
+  CGUIWindowMediaSourceBrowser();
+  virtual ~CGUIWindowMediaSourceBrowser() = default;
+
+  // specialization of CGUIControl
+  virtual bool OnMessage(CGUIMessage& message) override;
+
+protected:
+  // specialization of CGUIMediaWindow
+  virtual bool GetDirectory(const std::string& strDirectory, CFileItemList& items) override;
+  virtual std::string GetStartFolder(const std::string& dir) override;
+
+  virtual void GetContextButtons(int itemNumber, CContextButtons& buttons) override;
+  virtual bool OnContextButton(int itemNumber, CONTEXT_BUTTON button) override;
+
+  virtual bool OnClick(int iItem, const std::string& player = "") override;
+
+  static std::string ShowAndGetImporterToLookup(const std::vector<MediaImporterPtr>& importers);
+  static std::string ShowAndGetMediaSourcesToImportFrom(
+      const GroupedMediaTypes& mediaTypes = GroupedMediaTypes());
+  static GroupedMediaTypes ShowAndGetMediaTypesToImport(const std::string& sourceId);
+  static GroupedMediaTypes ShowAndGetMediaTypesToImport(const CMediaImportSource& source);
+  static bool GetMediaTypesToImport(const MediaTypes& availableMediaTypes, CFileItemList& items);
+
+  bool RefreshList(bool keepSelectedItem = true);
+
+  bool OnSourceSynchronise(const CFileItemPtr& item);
+  bool OnSourceInfo(const CFileItemPtr& item);
+  bool OnSourceDelete(const CFileItemPtr& item);
+  bool OnImportSynchronise(const CFileItemPtr& item);
+  bool OnImportInfo(const CFileItemPtr& item);
+  bool OnImportDelete(const CFileItemPtr& item);
+
+  void OnSourceAdded(const std::string& sourceId);
+  void OnSourceUpdated(const std::string& sourceId);
+  void OnSourceRemoved(const std::string& sourceId);
+  void OnImportAdded(const std::string& importPath, const GroupedMediaTypes& mediaTypes);
+  void OnImportUpdated(const std::string& importPath, const GroupedMediaTypes& mediaTypes);
+  void OnImportRemoved(const std::string& importPath, const GroupedMediaTypes& mediaTypes);
+  void OnSourceIsActiveChanged(const std::string& sourceId, bool isactive);
+
+  CFileItemPtr GetImportItem(const std::string& importPath,
+                             const GroupedMediaTypes& mediaTypes) const;
+  CFileItemPtr GetSourceItem(const std::string& sourceId) const;
+
+  bool AddNewImport(CFileItemPtr newImportItem, const CURL& url);
+  bool AddNewSource(CFileItemPtr newImportItem, const CURL& url);
+
+  std::string m_manuallyAddedSourceId;
+
+  Logger m_logger;
+};
diff --git a/xbmc/view/GUIViewState.cpp b/xbmc/view/GUIViewState.cpp
index cb525b23c24b..1039a2318a9d 100644
--- a/xbmc/view/GUIViewState.cpp
+++ b/xbmc/view/GUIViewState.cpp
@@ -27,6 +27,7 @@
 #include "guilib/GUIWindowManager.h"
 #include "guilib/LocalizeStrings.h"
 #include "guilib/TextureManager.h"
+#include "media/import/windows/GUIViewStateMediaSourceBrowser.h"
 #include "music/GUIViewStateMusic.h"
 #include "pictures/GUIViewStatePictures.h"
 #include "profiles/ProfileManager.h"
@@ -112,6 +113,9 @@ CGUIViewState* CGUIViewState::GetViewState(int windowId, const CFileItemList& it
   if (url.IsProtocol("activities"))
     return new CGUIViewStateEventLog(items);
 
+  if (url.GetProtocol() == "import")
+    return new CGUIViewStateMediaSourceBrowser(items);
+
   if (windowId == WINDOW_MUSIC_NAV)
     return new CGUIViewStateWindowMusicNav(items);
 
@@ -178,6 +182,9 @@ CGUIViewState* CGUIViewState::GetViewState(int windowId, const CFileItemList& it
   if (windowId == WINDOW_EVENT_LOG)
     return new CGUIViewStateEventLog(items);
 
+  if (windowId == WINDOW_MEDIASOURCE_BROWSER)
+    return new CGUIViewStateMediaSourceBrowser(items);
+
   //  Use as fallback/default
   return new CGUIViewStateGeneral(items);
 }

From cea4d9fc920e09e9966f73f8dc6ebf030af76eab Mon Sep 17 00:00:00 2001
From: Montellese <montellese@kodi.tv>
Date: Tue, 25 Oct 2016 17:24:31 +0200
Subject: [PATCH 55/88] [CEmbyMediaImporter][network] add support for setting
 the port in SOCKETS::CAddress

---
 xbmc/network/Socket.h | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/xbmc/network/Socket.h b/xbmc/network/Socket.h
index facd8ec427ec..570e103fa7ab 100644
--- a/xbmc/network/Socket.h
+++ b/xbmc/network/Socket.h
@@ -64,6 +64,12 @@ namespace SOCKETS
       SetAddress(address);
     }
 
+    CAddress(const char *address, uint16_t port)
+    {
+      SetAddress(address);
+      SetPort(port);
+    }
+
     void SetAddress(const char *address)
     {
       in6_addr addr6;
@@ -117,6 +123,28 @@ namespace SOCKETS
       else
         return (unsigned long)saddr.saddr4.sin_addr.s_addr;
     }
+
+    void SetPort(uint16_t port)
+    {
+      if (saddr.saddr_generic.sa_family == AF_INET6)
+      {
+        saddr.saddr6.sin6_port = htons(port);
+        size = sizeof(saddr.saddr6);
+      }
+      else
+      {
+        saddr.saddr4.sin_port = htons(port);
+        size = sizeof(saddr.saddr4);
+      }
+    }
+
+    uint16_t Port() const
+    {
+      if (saddr.saddr_generic.sa_family == AF_INET6)
+        return ntohs(saddr.saddr6.sin6_port);
+      else
+        return ntohs(saddr.saddr4.sin_port);
+    }
   };
 
   /**********************************************************************/

From b5f48ede1d83da4b6fe8a911dc415ce75f1b1b45 Mon Sep 17 00:00:00 2001
From: Montellese <montellese@kodi.tv>
Date: Tue, 25 Oct 2016 17:27:26 +0200
Subject: [PATCH 56/88] [CEmbyMediaImporter][network] support IPv4 only UDP
 sockets (for broadcasting)

---
 xbmc/network/Socket.cpp |  2 +-
 xbmc/network/Socket.h   | 17 +++++++++++++----
 2 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/xbmc/network/Socket.cpp b/xbmc/network/Socket.cpp
index ea007c15767d..9622e7c0f7ef 100644
--- a/xbmc/network/Socket.cpp
+++ b/xbmc/network/Socket.cpp
@@ -33,7 +33,7 @@ bool CPosixUDPSocket::Bind(bool localOnly, int port, int range)
   // If we can, create a socket that works with IPv6 and IPv4.
   // If not, try an IPv4-only socket (we don't want to end up
   // with an IPv6-only socket).
-  if (!localOnly) // Only bind loopback to ipv4. TODO : Implement dual bindinds.
+  if (!localOnly && !m_ipv4Only) // Only bind loopback to ipv4. TODO : Implement dual bindinds.
   {
     m_ipv6Socket = CheckIPv6(port, range);
 
diff --git a/xbmc/network/Socket.h b/xbmc/network/Socket.h
index 570e103fa7ab..de1dadc5215c 100644
--- a/xbmc/network/Socket.h
+++ b/xbmc/network/Socket.h
@@ -194,7 +194,13 @@ namespace SOCKETS
     CUDPSocket()
       {
         m_Type = ST_UDP;
+        m_ipv4Only = false;
+        m_broadcast = false;
       }
+
+    bool IsIp4vOnly() const { return m_ipv4Only; }
+    void SetIpv4Only(bool ipv4Only) { m_ipv4Only = ipv4Only; }
+
     // I/O functions
     virtual int SendTo(const CAddress& addr, const int bufferlength,
                        const void* buffer) = 0;
@@ -203,6 +209,9 @@ namespace SOCKETS
     virtual int Read(CAddress& addr, const int buffersize, void *buffer) = 0;
     virtual bool Broadcast(const CAddress& addr, const int datasize,
                            const void* data) = 0;
+
+  protected:
+    bool m_ipv4Only;
   };
 
   // Implementation specific classes
@@ -214,10 +223,10 @@ namespace SOCKETS
   {
   public:
     CPosixUDPSocket()
-      {
-        m_iSock = INVALID_SOCKET;
-        m_ipv6Socket = false;
-      }
+    {
+      m_iSock = INVALID_SOCKET;
+      m_ipv6Socket = false;
+    }
 
     bool Bind(bool localOnly, int port, int range=0) override;
     bool Connect() override { return false; }

From bdad51a695dff459296490e49eafb345a58507f0 Mon Sep 17 00:00:00 2001
From: Montellese <montellese@kodi.tv>
Date: Tue, 25 Oct 2016 17:28:03 +0200
Subject: [PATCH 57/88] [CEmbyMediaImporter][network] add support for broadcast
 UDP sockets

---
 xbmc/network/Socket.cpp | 11 +++++++++++
 xbmc/network/Socket.h   | 11 ++++-------
 2 files changed, 15 insertions(+), 7 deletions(-)

diff --git a/xbmc/network/Socket.cpp b/xbmc/network/Socket.cpp
index 9622e7c0f7ef..9b7fb8cab145 100644
--- a/xbmc/network/Socket.cpp
+++ b/xbmc/network/Socket.cpp
@@ -90,6 +90,17 @@ bool CPosixUDPSocket::Bind(bool localOnly, int port, int range)
     CLog::Log(LOGWARNING, "UDP: %s", strerror(errno));
   }
 
+  // enable broadcasting support if necessary
+  if (m_broadcast)
+  {
+    if (setsockopt(m_iSock, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes)) == -1)
+    {
+      CLog::Log(LOGERROR, "UDP: Unable to enable broadcasting");
+      Close();
+      return false;
+    }
+  }
+
   // bind to any address or localhost
   if (m_ipv6Socket)
   {
diff --git a/xbmc/network/Socket.h b/xbmc/network/Socket.h
index de1dadc5215c..db58ad40af5c 100644
--- a/xbmc/network/Socket.h
+++ b/xbmc/network/Socket.h
@@ -201,17 +201,19 @@ namespace SOCKETS
     bool IsIp4vOnly() const { return m_ipv4Only; }
     void SetIpv4Only(bool ipv4Only) { m_ipv4Only = ipv4Only; }
 
+    bool IsBroadcast() const { return m_broadcast; }
+    void SetBroadcast(bool broadcast) { m_broadcast = broadcast; }
+
     // I/O functions
     virtual int SendTo(const CAddress& addr, const int bufferlength,
                        const void* buffer) = 0;
 
     // read datagrams, return no. of bytes read or -1 or error
     virtual int Read(CAddress& addr, const int buffersize, void *buffer) = 0;
-    virtual bool Broadcast(const CAddress& addr, const int datasize,
-                           const void* data) = 0;
 
   protected:
     bool m_ipv4Only;
+    bool m_broadcast;
   };
 
   // Implementation specific classes
@@ -233,11 +235,6 @@ namespace SOCKETS
     bool Listen(int timeout);
     int SendTo(const CAddress& addr, const int datasize, const void* data) override;
     int Read(CAddress& addr, const int buffersize, void *buffer) override;
-    bool Broadcast(const CAddress& addr, const int datasize, const void* data) override
-    {
-      //! @todo implement
-      return false;
-    }
     SOCKET Socket() override { return m_iSock; }
     void Close() override;
 

From d06d7a6fb78a619829af2350af0ec8577b3d5ed7 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 29 Oct 2016 17:27:16 +0200
Subject: [PATCH 58/88] [CEmbyMediaImporter][filesystem] CCurlFile: add support
 for HTTP DELETE requests

---
 xbmc/filesystem/CurlFile.cpp | 23 +++++++++++++++++------
 xbmc/filesystem/CurlFile.h   | 11 +++++++++++
 2 files changed, 28 insertions(+), 6 deletions(-)

diff --git a/xbmc/filesystem/CurlFile.cpp b/xbmc/filesystem/CurlFile.cpp
index 872cc781baf8..1bc55ab0bfe8 100644
--- a/xbmc/filesystem/CurlFile.cpp
+++ b/xbmc/filesystem/CurlFile.cpp
@@ -414,7 +414,7 @@ CCurlFile::CCurlFile()
   m_ftppasvip = false;
   m_bufferSize = 32768;
   m_postdata = "";
-  m_postdataset = false;
+  m_requestType = RequestType::Get;
   m_username = "";
   m_password = "";
   m_httpauth = "";
@@ -525,9 +525,13 @@ void CCurlFile::SetCommonOptions(CReadState* state, bool failOnError /* = true *
   g_curlInterface.easy_setopt(m_state->m_easyHandle, CURLOPT_TRANSFERTEXT, CURL_OFF);
 
   // setup POST data if it is set (and it may be empty)
-  if (m_postdataset)
+  if (m_requestType == RequestType::Post || m_requestType == RequestType::Delete)
   {
-    g_curlInterface.easy_setopt(h, CURLOPT_POST, 1 );
+    if (m_requestType == RequestType::Post)
+      g_curlInterface.easy_setopt(h, CURLOPT_POST, 1);
+    else
+      g_curlInterface.easy_setopt(h, CURLOPT_CUSTOMREQUEST, "DELETE");
+
     g_curlInterface.easy_setopt(h, CURLOPT_POSTFIELDSIZE, m_postdata.length());
     g_curlInterface.easy_setopt(h, CURLOPT_POSTFIELDS, m_postdata.c_str());
   }
@@ -819,7 +823,7 @@ void CCurlFile::ParseAndCorrectUrl(CURL &url2)
         else if (name == "postdata")
         {
           m_postdata = Base64::Decode(value);
-          m_postdataset = true;
+          m_requestType = RequestType::Post;
         }
         else if (name == "active-remote")// needed for DACP!
         {
@@ -874,14 +878,14 @@ void CCurlFile::ParseAndCorrectUrl(CURL &url2)
 bool CCurlFile::Post(const std::string& strURL, const std::string& strPostData, std::string& strHTML)
 {
   m_postdata = strPostData;
-  m_postdataset = true;
+  m_requestType = RequestType::Post;
   return Service(strURL, strHTML);
 }
 
 bool CCurlFile::Get(const std::string& strURL, std::string& strHTML)
 {
   m_postdata = "";
-  m_postdataset = false;
+  m_requestType = RequestType::Get;
   return Service(strURL, strHTML);
 }
 
@@ -942,6 +946,13 @@ bool CCurlFile::Download(const std::string& strURL, const std::string& strFileNa
   return written == static_cast<ssize_t>(strData.size());
 }
 
+bool CCurlFile::Delete(const std::string& strURL, std::string& strHTML)
+{
+  m_postdata.clear();
+  m_requestType = RequestType::Delete;
+  return Service(strURL, strHTML);
+}
+
 // Detect whether we are "online" or not! Very simple and dirty!
 bool CCurlFile::IsInternet()
 {
diff --git a/xbmc/filesystem/CurlFile.h b/xbmc/filesystem/CurlFile.h
index 2fb05f304040..5ba5b292227c 100644
--- a/xbmc/filesystem/CurlFile.h
+++ b/xbmc/filesystem/CurlFile.h
@@ -53,10 +53,13 @@ namespace XFILE
       int IoControl(EIoControl request, void* param) override;
       double GetDownloadSpeed() override;
 
+      using IFile::Delete;
+
       bool Post(const std::string& strURL, const std::string& strPostData, std::string& strHTML);
       bool Get(const std::string& strURL, std::string& strHTML);
       bool ReadData(std::string& strHTML);
       bool Download(const std::string& strURL, const std::string& strFileName, unsigned int* pdwSize = NULL);
+      bool Delete(const std::string& strURL, std::string& strHTML);
       bool IsInternet();
       void Cancel();
       void Reset();
@@ -186,6 +189,14 @@ namespace XFILE
       bool m_verifyPeer = true;
       bool m_failOnError = true;
 
+      enum class RequestType
+      {
+        Get,
+        Post,
+        Delete
+      };
+      RequestType m_requestType;
+
       CRingBuffer m_buffer; // our ringhold buffer
       char* m_overflowBuffer; // in the rare case we would overflow the above buffer
       unsigned int m_overflowSize = 0; // size of the overflow buffer

From 94a91148e5b9727d43fdf8a6883ae26e7554857f Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 3 Jun 2017 00:19:34 +0200
Subject: [PATCH 59/88] [CAddonMediaImporter] factor out CRunningScriptsHandler
 from CPluginDirectory

---
 xbmc/filesystem/PluginDirectory.cpp           | 77 +++++--------------
 xbmc/filesystem/PluginDirectory.h             | 13 +---
 xbmc/interfaces/generic/CMakeLists.txt        |  1 +
 .../generic/RunningScriptsHandler.h           | 72 +++++++++++++++++
 4 files changed, 96 insertions(+), 67 deletions(-)
 create mode 100644 xbmc/interfaces/generic/RunningScriptsHandler.h

diff --git a/xbmc/filesystem/PluginDirectory.cpp b/xbmc/filesystem/PluginDirectory.cpp
index 9357abf0d0da..beb60bdbfa94 100644
--- a/xbmc/filesystem/PluginDirectory.cpp
+++ b/xbmc/filesystem/PluginDirectory.cpp
@@ -35,10 +35,6 @@ using namespace XFILE;
 using namespace ADDON;
 using namespace KODI::MESSAGING;
 
-std::map<int, CPluginDirectory *> CPluginDirectory::globalHandles;
-int CPluginDirectory::handleCounter = 0;
-CCriticalSection CPluginDirectory::m_handleLock;
-
 CPluginDirectory::CScriptObserver::CScriptObserver(int scriptId, CEvent &event) :
   CThread("scriptobs"), m_scriptId(scriptId), m_event(event)
 {
@@ -78,37 +74,6 @@ CPluginDirectory::~CPluginDirectory(void)
   delete m_fileResult;
 }
 
-int CPluginDirectory::getNewHandle(CPluginDirectory *cp)
-{
-  CSingleLock lock(m_handleLock);
-  int handle = ++handleCounter;
-  globalHandles[handle] = cp;
-  return handle;
-}
-
-void CPluginDirectory::reuseHandle(int handle, CPluginDirectory* cp)
-{
-  CSingleLock lock(m_handleLock);
-  globalHandles[handle] = cp;
-}
-
-void CPluginDirectory::removeHandle(int handle)
-{
-  CSingleLock lock(m_handleLock);
-  if (!globalHandles.erase(handle))
-    CLog::Log(LOGWARNING, "Attempt to erase invalid handle %i", handle);
-}
-
-CPluginDirectory *CPluginDirectory::dirFromHandle(int handle)
-{
-  CSingleLock lock(m_handleLock);
-  std::map<int, CPluginDirectory *>::iterator i = globalHandles.find(handle);
-  if (i != globalHandles.end())
-    return i->second;
-  CLog::Log(LOGWARNING, "Attempt to use invalid handle %i", handle);
-  return NULL;
-}
-
 bool CPluginDirectory::StartScript(const std::string& strPath, bool retrievingDir, bool resume)
 {
   CURL url(strPath);
@@ -133,9 +98,9 @@ bool CPluginDirectory::StartScript(const std::string& strPath, bool retrievingDi
   int handle = CScriptInvocationManager::GetInstance().GetReusablePluginHandle(m_addon->LibPath());
 
   if (handle < 0)
-    handle = getNewHandle(this);
+    handle = GetNewScriptHandle(this);
   else
-    reuseHandle(handle, this);
+    ReuseScriptHandle(handle, this);
 
   // clear out our status variables
   m_fileResult->Reset();
@@ -177,7 +142,7 @@ bool CPluginDirectory::StartScript(const std::string& strPath, bool retrievingDi
     CLog::Log(LOGERROR, "Unable to run plugin %s", m_addon->Name().c_str());
 
   // free our handle
-  removeHandle(handle);
+  RemoveScriptHandle(handle);
 
   return success;
 }
@@ -206,8 +171,8 @@ bool CPluginDirectory::GetPluginResult(const std::string& strPath, CFileItem &re
 
 bool CPluginDirectory::AddItem(int handle, const CFileItem *item, int totalItems)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if (!dir)
     return false;
 
@@ -220,8 +185,8 @@ bool CPluginDirectory::AddItem(int handle, const CFileItem *item, int totalItems
 
 bool CPluginDirectory::AddItems(int handle, const CFileItemList *items, int totalItems)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if (!dir)
     return false;
 
@@ -235,8 +200,8 @@ bool CPluginDirectory::AddItems(int handle, const CFileItemList *items, int tota
 
 void CPluginDirectory::EndOfDirectory(int handle, bool success, bool replaceListing, bool cacheToDisc)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if (!dir)
     return;
 
@@ -255,8 +220,8 @@ void CPluginDirectory::EndOfDirectory(int handle, bool success, bool replaceList
 
 void CPluginDirectory::AddSortMethod(int handle, SORT_METHOD sortMethod, const std::string &label2Mask)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if (!dir)
     return;
 
@@ -547,8 +512,8 @@ bool CPluginDirectory::WaitOnScriptResult(const std::string &scriptPath, int scr
 
 void CPluginDirectory::SetResolvedUrl(int handle, bool success, const CFileItem *resultItem)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if (!dir)
     return;
 
@@ -561,8 +526,8 @@ void CPluginDirectory::SetResolvedUrl(int handle, bool success, const CFileItem
 
 std::string CPluginDirectory::GetSetting(int handle, const std::string &strID)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if(dir && dir->m_addon)
     return dir->m_addon->GetSetting(strID);
   else
@@ -571,24 +536,24 @@ std::string CPluginDirectory::GetSetting(int handle, const std::string &strID)
 
 void CPluginDirectory::SetSetting(int handle, const std::string &strID, const std::string &value)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if(dir && dir->m_addon)
     dir->m_addon->UpdateSetting(strID, value);
 }
 
 void CPluginDirectory::SetContent(int handle, const std::string &strContent)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if (dir)
     dir->m_listItems->SetContent(strContent);
 }
 
 void CPluginDirectory::SetProperty(int handle, const std::string &strProperty, const std::string &strValue)
 {
-  CSingleLock lock(m_handleLock);
-  CPluginDirectory *dir = dirFromHandle(handle);
+  CSingleLock lock(GetScriptsLock());
+  CPluginDirectory *dir = GetScriptFromHandle(handle);
   if (!dir)
     return;
   if (strProperty == "fanart_image")
diff --git a/xbmc/filesystem/PluginDirectory.h b/xbmc/filesystem/PluginDirectory.h
index 65221ec8cc8b..e2bc73ee351f 100644
--- a/xbmc/filesystem/PluginDirectory.h
+++ b/xbmc/filesystem/PluginDirectory.h
@@ -11,7 +11,7 @@
 #include "IDirectory.h"
 #include "SortFileItem.h"
 #include "addons/IAddon.h"
-#include "threads/CriticalSection.h"
+#include "interfaces/generic/RunningScriptsHandler.h"
 #include "threads/Event.h"
 #include "threads/Thread.h"
 
@@ -28,7 +28,7 @@ class CFileItemList;
 namespace XFILE
 {
 
-class CPluginDirectory : public IDirectory
+class CPluginDirectory : public IDirectory, public CRunningScriptsHandler<CPluginDirectory>
 {
 public:
   CPluginDirectory();
@@ -73,15 +73,6 @@ class CPluginDirectory : public IDirectory
   bool StartScript(const std::string& strPath, bool retrievingDir, bool resume);
   bool WaitOnScriptResult(const std::string &scriptPath, int scriptId, const std::string &scriptName, bool retrievingDir);
 
-  static std::map<int,CPluginDirectory*> globalHandles;
-  static int getNewHandle(CPluginDirectory *cp);
-  static void reuseHandle(int handle, CPluginDirectory* cp);
-
-  static void removeHandle(int handle);
-  static CPluginDirectory *dirFromHandle(int handle);
-  static CCriticalSection m_handleLock;
-  static int handleCounter;
-
   CFileItemList* m_listItems;
   CFileItem*     m_fileResult;
   CEvent         m_fetchComplete;
diff --git a/xbmc/interfaces/generic/CMakeLists.txt b/xbmc/interfaces/generic/CMakeLists.txt
index 11bcb9ec191e..1c4adc0af907 100644
--- a/xbmc/interfaces/generic/CMakeLists.txt
+++ b/xbmc/interfaces/generic/CMakeLists.txt
@@ -5,6 +5,7 @@ set(SOURCES ILanguageInvoker.cpp
 set(HEADERS ILanguageInvocationHandler.h
             ILanguageInvoker.h
             LanguageInvokerThread.h
+            RunningScriptsHandler.h
             ScriptInvocationManager.h)
 
 core_add_library(generic_interface)
diff --git a/xbmc/interfaces/generic/RunningScriptsHandler.h b/xbmc/interfaces/generic/RunningScriptsHandler.h
new file mode 100644
index 000000000000..9e6037282d15
--- /dev/null
+++ b/xbmc/interfaces/generic/RunningScriptsHandler.h
@@ -0,0 +1,72 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "threads/CriticalSection.h"
+#include "threads/SingleLock.h"
+
+#include <cstdint>
+#include <map>
+
+template<class TScript>
+class CRunningScriptsHandler
+{
+protected:
+  using HandleType = int;
+
+  CRunningScriptsHandler() = default;
+  virtual ~CRunningScriptsHandler() = default;
+
+  static HandleType GetNewScriptHandle(TScript* script)
+  {
+    CSingleLock lock(s_critical);
+    uint32_t handle = ++s_scriptHandleCounter;
+    s_scriptHandles[handle] = script;
+
+    return handle;
+  }
+
+  static void ReuseScriptHandle(HandleType handle, TScript* script)
+  {
+    CSingleLock lock(s_critical);
+    s_scriptHandles[handle] = script;
+  }
+
+  static void RemoveScriptHandle(HandleType handle)
+  {
+    CSingleLock lock(s_critical);
+    s_scriptHandles.erase(handle);
+  }
+
+  static TScript* GetScriptFromHandle(HandleType handle)
+  {
+    CSingleLock lock(s_critical);
+    auto scriptHandle = s_scriptHandles.find(handle);
+    if (scriptHandle == s_scriptHandles.end())
+      return nullptr;
+
+    return scriptHandle->second;
+  }
+
+  static inline CCriticalSection& GetScriptsLock() { return s_critical; }
+
+private:
+  static std::map<HandleType, TScript*> s_scriptHandles;
+  static CCriticalSection s_critical;
+  static HandleType s_scriptHandleCounter;
+};
+
+template<class TScript>
+std::map<typename CRunningScriptsHandler<TScript>::HandleType, TScript*>
+    CRunningScriptsHandler<TScript>::s_scriptHandles;
+template<class TScript>
+CCriticalSection CRunningScriptsHandler<TScript>::s_critical;
+template<class TScript>
+typename CRunningScriptsHandler<TScript>::HandleType
+    CRunningScriptsHandler<TScript>::s_scriptHandleCounter = 0;

From eae705e99567a52d43e578d29fc53d24fbb5034e Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 3 Jun 2017 00:26:09 +0200
Subject: [PATCH 60/88] [CAddonMediaImporter] factor out CRunningScriptObserver
 from CPluginDirectory

---
 xbmc/filesystem/PluginDirectory.cpp           | 28 ++-------------
 xbmc/filesystem/PluginDirectory.h             | 12 -------
 xbmc/interfaces/generic/CMakeLists.txt        |  2 ++
 .../generic/RunningScriptObserver.cpp         | 36 +++++++++++++++++++
 .../generic/RunningScriptObserver.h           | 28 +++++++++++++++
 5 files changed, 68 insertions(+), 38 deletions(-)
 create mode 100644 xbmc/interfaces/generic/RunningScriptObserver.cpp
 create mode 100644 xbmc/interfaces/generic/RunningScriptObserver.h

diff --git a/xbmc/filesystem/PluginDirectory.cpp b/xbmc/filesystem/PluginDirectory.cpp
index beb60bdbfa94..a090fc68e6f0 100644
--- a/xbmc/filesystem/PluginDirectory.cpp
+++ b/xbmc/filesystem/PluginDirectory.cpp
@@ -20,6 +20,7 @@
 #include "dialogs/GUIDialogProgress.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIWindowManager.h"
+#include "interfaces/generic/RunningScriptObserver.h"
 #include "interfaces/generic/ScriptInvocationManager.h"
 #include "messaging/ApplicationMessenger.h"
 #include "settings/Settings.h"
@@ -35,31 +36,6 @@ using namespace XFILE;
 using namespace ADDON;
 using namespace KODI::MESSAGING;
 
-CPluginDirectory::CScriptObserver::CScriptObserver(int scriptId, CEvent &event) :
-  CThread("scriptobs"), m_scriptId(scriptId), m_event(event)
-{
-  Create();
-}
-
-void CPluginDirectory::CScriptObserver::Process()
-{
-  while (!m_bStop)
-  {
-    if (!CScriptInvocationManager::GetInstance().IsRunning(m_scriptId))
-    {
-      m_event.Set();
-      break;
-    }
-    CThread::Sleep(20);
-  }
-}
-
-void CPluginDirectory::CScriptObserver::Abort()
-{
-  // will wait until thread exits
-  StopThread();
-}
-
 CPluginDirectory::CPluginDirectory()
   : m_fetchComplete(true)
   , m_cancelled(false)
@@ -466,7 +442,7 @@ bool CPluginDirectory::WaitOnScriptResult(const std::string &scriptPath, int scr
   {
     if (!m_fetchComplete.WaitMSec(20))
     {
-      CScriptObserver scriptObs(scriptId, m_fetchComplete);
+      CRunningScriptObserver scriptObs(scriptId, m_fetchComplete);
 
       CGUIDialogProgress* progress = nullptr;
       CGUIWindowManager& wm = CServiceBroker::GetGUI()->GetWindowManager();
diff --git a/xbmc/filesystem/PluginDirectory.h b/xbmc/filesystem/PluginDirectory.h
index e2bc73ee351f..b6ff3346f13b 100644
--- a/xbmc/filesystem/PluginDirectory.h
+++ b/xbmc/filesystem/PluginDirectory.h
@@ -13,7 +13,6 @@
 #include "addons/IAddon.h"
 #include "interfaces/generic/RunningScriptsHandler.h"
 #include "threads/Event.h"
-#include "threads/Thread.h"
 
 #include <atomic>
 #include <map>
@@ -80,16 +79,5 @@ class CPluginDirectory : public IDirectory, public CRunningScriptsHandler<CPlugi
   std::atomic<bool> m_cancelled;
   bool          m_success = false;      // set by script in EndOfDirectory
   int    m_totalItems = 0;   // set by script in AddDirectoryItem
-
-  class CScriptObserver : public CThread
-  {
-  public:
-    CScriptObserver(int scriptId, CEvent &event);
-    void Abort();
-  protected:
-    void Process() override;
-    int m_scriptId;
-    CEvent &m_event;
-  };
 };
 }
diff --git a/xbmc/interfaces/generic/CMakeLists.txt b/xbmc/interfaces/generic/CMakeLists.txt
index 1c4adc0af907..6adc45072cbf 100644
--- a/xbmc/interfaces/generic/CMakeLists.txt
+++ b/xbmc/interfaces/generic/CMakeLists.txt
@@ -1,11 +1,13 @@
 set(SOURCES ILanguageInvoker.cpp
             LanguageInvokerThread.cpp
+            RunningScriptObserver.cpp
             ScriptInvocationManager.cpp)
 
 set(HEADERS ILanguageInvocationHandler.h
             ILanguageInvoker.h
             LanguageInvokerThread.h
             RunningScriptsHandler.h
+            RunningScriptObserver.h
             ScriptInvocationManager.h)
 
 core_add_library(generic_interface)
diff --git a/xbmc/interfaces/generic/RunningScriptObserver.cpp b/xbmc/interfaces/generic/RunningScriptObserver.cpp
new file mode 100644
index 000000000000..f83b3d2be79b
--- /dev/null
+++ b/xbmc/interfaces/generic/RunningScriptObserver.cpp
@@ -0,0 +1,36 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "RunningScriptObserver.h"
+
+#include "interfaces/generic/ScriptInvocationManager.h"
+
+CRunningScriptObserver::CRunningScriptObserver(int scriptId, CEvent& evt)
+  : CThread("ScriptObs"), m_scriptId(scriptId), m_event(evt)
+{
+  Create();
+}
+
+void CRunningScriptObserver::Process()
+{
+  while (!m_bStop)
+  {
+    if (!CScriptInvocationManager::GetInstance().IsRunning(m_scriptId))
+    {
+      m_event.Set();
+      break;
+    }
+
+    CThread::Sleep(20);
+  }
+}
+
+void CRunningScriptObserver::Abort()
+{
+  m_bStop = true;
+}
diff --git a/xbmc/interfaces/generic/RunningScriptObserver.h b/xbmc/interfaces/generic/RunningScriptObserver.h
new file mode 100644
index 000000000000..f2d471120c09
--- /dev/null
+++ b/xbmc/interfaces/generic/RunningScriptObserver.h
@@ -0,0 +1,28 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "threads/Event.h"
+#include "threads/Thread.h"
+
+class CRunningScriptObserver : public CThread
+{
+public:
+  CRunningScriptObserver(int scriptId, CEvent& evt);
+  ~CRunningScriptObserver() = default;
+
+  void Abort();
+
+protected:
+  // implementation of CThread
+  void Process() override;
+
+  int m_scriptId;
+  CEvent& m_event;
+};

From 0214a7b8e320833fa65993e194ea89014aa67515 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 3 Jun 2017 23:58:21 +0200
Subject: [PATCH 61/88] [CAddonMediaImporter][filesystem] CPluginDirectory:
 remove unused retrievingDir parameter(s)

---
 xbmc/filesystem/PluginDirectory.cpp | 10 +++++-----
 xbmc/filesystem/PluginDirectory.h   |  4 ++--
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/xbmc/filesystem/PluginDirectory.cpp b/xbmc/filesystem/PluginDirectory.cpp
index a090fc68e6f0..cc0fa824e633 100644
--- a/xbmc/filesystem/PluginDirectory.cpp
+++ b/xbmc/filesystem/PluginDirectory.cpp
@@ -50,7 +50,7 @@ CPluginDirectory::~CPluginDirectory(void)
   delete m_fileResult;
 }
 
-bool CPluginDirectory::StartScript(const std::string& strPath, bool retrievingDir, bool resume)
+bool CPluginDirectory::StartScript(const std::string& strPath, bool resume)
 {
   CURL url(strPath);
 
@@ -112,7 +112,7 @@ bool CPluginDirectory::StartScript(const std::string& strPath, bool retrievingDi
   if (id >= 0)
   { // wait for our script to finish
     std::string scriptName = m_addon->Name();
-    success = WaitOnScriptResult(file, id, scriptName, retrievingDir);
+    success = WaitOnScriptResult(file, id, scriptName);
   }
   else
     CLog::Log(LOGERROR, "Unable to run plugin %s", m_addon->Name().c_str());
@@ -128,7 +128,7 @@ bool CPluginDirectory::GetPluginResult(const std::string& strPath, CFileItem &re
   CURL url(strPath);
   CPluginDirectory newDir;
 
-  bool success = newDir.StartScript(strPath, false, resume);
+  bool success = newDir.StartScript(strPath, resume);
 
   if (success)
   { // update the play path and metadata, saving the old one as needed
@@ -383,7 +383,7 @@ void CPluginDirectory::AddSortMethod(int handle, SORT_METHOD sortMethod, const s
 bool CPluginDirectory::GetDirectory(const CURL& url, CFileItemList& items)
 {
   const std::string pathToUrl(url.Get());
-  bool success = StartScript(pathToUrl, true, false);
+  bool success = StartScript(pathToUrl, false);
 
   // append the items to the list
   items.Assign(*m_listItems, true); // true to keep the current items
@@ -433,7 +433,7 @@ bool CPluginDirectory::RunScriptWithParams(const std::string& strPath, bool resu
   return false;
 }
 
-bool CPluginDirectory::WaitOnScriptResult(const std::string &scriptPath, int scriptId, const std::string &scriptName, bool retrievingDir)
+bool CPluginDirectory::WaitOnScriptResult(const std::string &scriptPath, int scriptId, const std::string &scriptName)
 {
   // CPluginDirectory::GetDirectory can be called from the main and other threads.
   // If called form the main thread, we need to bring up the BusyDialog in order to
diff --git a/xbmc/filesystem/PluginDirectory.h b/xbmc/filesystem/PluginDirectory.h
index b6ff3346f13b..cf4bc7b78451 100644
--- a/xbmc/filesystem/PluginDirectory.h
+++ b/xbmc/filesystem/PluginDirectory.h
@@ -69,8 +69,8 @@ class CPluginDirectory : public IDirectory, public CRunningScriptsHandler<CPlugi
 
 private:
   ADDON::AddonPtr m_addon;
-  bool StartScript(const std::string& strPath, bool retrievingDir, bool resume);
-  bool WaitOnScriptResult(const std::string &scriptPath, int scriptId, const std::string &scriptName, bool retrievingDir);
+  bool StartScript(const std::string& strPath, bool resume);
+  bool WaitOnScriptResult(const std::string &scriptPath, int scriptId, const std::string &scriptName);
 
   CFileItemList* m_listItems;
   CFileItem*     m_fileResult;

From de7ecf7ea8d195842b05eba47a97341b49d68028 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 4 Jun 2017 01:06:34 +0200
Subject: [PATCH 62/88] [CAddonMediaImporter] factor out CScriptRunner from
 CPluginDirectory

---
 xbmc/filesystem/PluginDirectory.cpp           | 158 ++----------------
 xbmc/filesystem/PluginDirectory.h             |  14 +-
 xbmc/interfaces/generic/CMakeLists.txt        |   6 +-
 .../generic/RunningScriptsHandler.h           |  31 +++-
 xbmc/interfaces/generic/ScriptRunner.cpp      | 145 ++++++++++++++++
 xbmc/interfaces/generic/ScriptRunner.h        |  52 ++++++
 6 files changed, 255 insertions(+), 151 deletions(-)
 create mode 100644 xbmc/interfaces/generic/ScriptRunner.cpp
 create mode 100644 xbmc/interfaces/generic/ScriptRunner.h

diff --git a/xbmc/filesystem/PluginDirectory.cpp b/xbmc/filesystem/PluginDirectory.cpp
index cc0fa824e633..f70e0ae9945f 100644
--- a/xbmc/filesystem/PluginDirectory.cpp
+++ b/xbmc/filesystem/PluginDirectory.cpp
@@ -37,8 +37,7 @@ using namespace ADDON;
 using namespace KODI::MESSAGING;
 
 CPluginDirectory::CPluginDirectory()
-  : m_fetchComplete(true)
-  , m_cancelled(false)
+  : m_cancelled(false)
 {
   m_listItems = new CFileItemList;
   m_fileResult = new CFileItem;
@@ -54,73 +53,27 @@ bool CPluginDirectory::StartScript(const std::string& strPath, bool resume)
 {
   CURL url(strPath);
 
+  ADDON::AddonPtr addon;
   // try the plugin type first, and if not found, try an unknown type
-  if (!CServiceBroker::GetAddonMgr().GetAddon(url.GetHostName(), m_addon, ADDON_PLUGIN) &&
-      !CServiceBroker::GetAddonMgr().GetAddon(url.GetHostName(), m_addon, ADDON_UNKNOWN) &&
-      !CAddonInstaller::GetInstance().InstallModal(url.GetHostName(), m_addon))
+  if (!CServiceBroker::GetAddonMgr().GetAddon(url.GetHostName(), addon, ADDON_PLUGIN) &&
+      !CServiceBroker::GetAddonMgr().GetAddon(url.GetHostName(), addon, ADDON_UNKNOWN) &&
+      !CAddonInstaller::GetInstance().InstallModal(url.GetHostName(), addon))
   {
     CLog::Log(LOGERROR, "Unable to find plugin %s", url.GetHostName().c_str());
     return false;
   }
 
-  // get options
-  std::string options = url.GetOptions();
-  url.SetOptions(""); // do this because we can then use the url to generate the basepath
-                      // which is passed to the plugin (and represents the share)
-
-  std::string basePath(url.Get());
-  // reset our wait event, and grab a new handle
-  m_fetchComplete.Reset();
-  int handle = CScriptInvocationManager::GetInstance().GetReusablePluginHandle(m_addon->LibPath());
-
-  if (handle < 0)
-    handle = GetNewScriptHandle(this);
-  else
-    ReuseScriptHandle(handle, this);
-
   // clear out our status variables
   m_fileResult->Reset();
   m_listItems->Clear();
   m_listItems->SetPath(strPath);
-  m_listItems->SetLabel(m_addon->Name());
+  m_listItems->SetLabel(addon->Name());
   m_cancelled = false;
   m_success = false;
   m_totalItems = 0;
 
-  // setup our parameters to send the script
-  std::string strHandle = StringUtils::Format("%i", handle);
-  std::vector<std::string> argv;
-  argv.push_back(basePath);
-  argv.push_back(strHandle);
-  argv.push_back(options);
-
-  std::string strResume = "resume:false";
-  if (resume)
-    strResume = "resume:true";
-  argv.push_back(strResume);
-
   // run the script
-  CLog::Log(LOGDEBUG, "%s - calling plugin %s('%s','%s','%s','%s')", __FUNCTION__, m_addon->Name().c_str(), argv[0].c_str(), argv[1].c_str(), argv[2].c_str(), argv[3].c_str());
-  bool success = false;
-  std::string file = m_addon->LibPath();
-  bool reuseLanguageInvoker = false;
-  if (m_addon->ExtraInfo().find("reuselanguageinvoker") != m_addon->ExtraInfo().end())
-    reuseLanguageInvoker = m_addon->ExtraInfo().at("reuselanguageinvoker") == "true";
-
-  int id = CScriptInvocationManager::GetInstance().ExecuteAsync(file, m_addon, argv,
-                                                                reuseLanguageInvoker, handle);
-  if (id >= 0)
-  { // wait for our script to finish
-    std::string scriptName = m_addon->Name();
-    success = WaitOnScriptResult(file, id, scriptName);
-  }
-  else
-    CLog::Log(LOGERROR, "Unable to run plugin %s", m_addon->Name().c_str());
-
-  // free our handle
-  RemoveScriptHandle(handle);
-
-  return success;
+  return RunScript(this, addon, strPath, resume);
 }
 
 bool CPluginDirectory::GetPluginResult(const std::string& strPath, CFileItem &resultItem, bool resume)
@@ -191,7 +144,7 @@ void CPluginDirectory::EndOfDirectory(int handle, bool success, bool replaceList
     dir->m_listItems->AddSortMethod(SortByNone, 552, LABEL_MASKS("%L", "%D"));
 
   // set the event to mark that we're done
-  dir->m_fetchComplete.Set();
+  dir->SetDone();
 }
 
 void CPluginDirectory::AddSortMethod(int handle, SORT_METHOD sortMethod, const std::string &label2Mask)
@@ -398,92 +351,14 @@ bool CPluginDirectory::RunScriptWithParams(const std::string& strPath, bool resu
     return false;
 
   AddonPtr addon;
-  if (!CServiceBroker::GetAddonMgr().GetAddon(url.GetHostName(), addon, ADDON_PLUGIN) && !CAddonInstaller::GetInstance().InstallModal(url.GetHostName(), addon))
+  if (!CServiceBroker::GetAddonMgr().GetAddon(url.GetHostName(), addon, ADDON_PLUGIN) &&
+      !CAddonInstaller::GetInstance().InstallModal(url.GetHostName(), addon))
   {
     CLog::Log(LOGERROR, "Unable to find plugin %s", url.GetHostName().c_str());
     return false;
   }
 
-  // options
-  std::string options = url.GetOptions();
-  url.SetOptions(""); // do this because we can then use the url to generate the basepath
-                      // which is passed to the plugin (and represents the share)
-
-  std::string basePath(url.Get());
-
-  // setup our parameters to send the script
-  std::string strHandle = StringUtils::Format("%i", -1);
-  std::vector<std::string> argv;
-  argv.push_back(basePath);
-  argv.push_back(strHandle);
-  argv.push_back(options);
-
-  std::string strResume = "resume:false";
-  if (resume)
-    strResume = "resume:true";
-  argv.push_back(strResume);
-
-  // run the script
-  CLog::Log(LOGDEBUG, "%s - calling plugin %s('%s','%s','%s','%s')", __FUNCTION__, addon->Name().c_str(), argv[0].c_str(), argv[1].c_str(), argv[2].c_str(), argv[3].c_str());
-  if (CScriptInvocationManager::GetInstance().ExecuteAsync(addon->LibPath(), addon, argv) >= 0)
-    return true;
-  else
-    CLog::Log(LOGERROR, "Unable to run plugin %s", addon->Name().c_str());
-
-  return false;
-}
-
-bool CPluginDirectory::WaitOnScriptResult(const std::string &scriptPath, int scriptId, const std::string &scriptName)
-{
-  // CPluginDirectory::GetDirectory can be called from the main and other threads.
-  // If called form the main thread, we need to bring up the BusyDialog in order to
-  // keep the render loop alive
-  if (g_application.IsCurrentThread())
-  {
-    if (!m_fetchComplete.WaitMSec(20))
-    {
-      CRunningScriptObserver scriptObs(scriptId, m_fetchComplete);
-
-      CGUIDialogProgress* progress = nullptr;
-      CGUIWindowManager& wm = CServiceBroker::GetGUI()->GetWindowManager();
-      if (wm.IsModalDialogTopmost(WINDOW_DIALOG_PROGRESS))
-        progress = wm.GetWindow<CGUIDialogProgress>(WINDOW_DIALOG_PROGRESS);
-
-      if (progress != nullptr)
-      {
-        if (!progress->WaitOnEvent(m_fetchComplete))
-          m_cancelled = true;
-      }
-      else if (!CGUIDialogBusy::WaitOnEvent(m_fetchComplete, 200))
-        m_cancelled = true;
-
-      scriptObs.Abort();
-    }
-  }
-  else
-  {
-    // Wait for directory fetch to complete, end, or be cancelled
-    while (!m_cancelled
-        && CScriptInvocationManager::GetInstance().IsRunning(scriptId)
-        && !m_fetchComplete.WaitMSec(20));
-
-    // Give the script 30 seconds to exit before we attempt to stop it
-    XbmcThreads::EndTime timer(30000);
-    while (!timer.IsTimePast()
-          && CScriptInvocationManager::GetInstance().IsRunning(scriptId)
-          && !m_fetchComplete.WaitMSec(20));
-  }
-
-  if (m_cancelled)
-  { // cancel our script
-    if (scriptId != -1 && CScriptInvocationManager::GetInstance().IsRunning(scriptId))
-    {
-      CLog::Log(LOGDEBUG, "%s- cancelling plugin %s (id=%d)", __FUNCTION__, scriptName.c_str(), scriptId);
-      CScriptInvocationManager::GetInstance().Stop(scriptId);
-    }
-  }
-
-  return !m_cancelled && m_success;
+  return ExecuteScript(addon, strPath, resume) >= 0;
 }
 
 void CPluginDirectory::SetResolvedUrl(int handle, bool success, const CFileItem *resultItem)
@@ -497,15 +372,15 @@ void CPluginDirectory::SetResolvedUrl(int handle, bool success, const CFileItem
   *dir->m_fileResult = *resultItem;
 
   // set the event to mark that we're done
-  dir->m_fetchComplete.Set();
+  dir->SetDone();
 }
 
 std::string CPluginDirectory::GetSetting(int handle, const std::string &strID)
 {
   CSingleLock lock(GetScriptsLock());
   CPluginDirectory *dir = GetScriptFromHandle(handle);
-  if(dir && dir->m_addon)
-    return dir->m_addon->GetSetting(strID);
+  if(dir && dir->GetAddon())
+    return dir->GetAddon()->GetSetting(strID);
   else
     return "";
 }
@@ -514,8 +389,8 @@ void CPluginDirectory::SetSetting(int handle, const std::string &strID, const st
 {
   CSingleLock lock(GetScriptsLock());
   CPluginDirectory *dir = GetScriptFromHandle(handle);
-  if(dir && dir->m_addon)
-    dir->m_addon->UpdateSetting(strID, value);
+  if(dir && dir->GetAddon())
+    dir->GetAddon()->UpdateSetting(strID, value);
 }
 
 void CPluginDirectory::SetContent(int handle, const std::string &strContent)
@@ -541,7 +416,6 @@ void CPluginDirectory::SetProperty(int handle, const std::string &strProperty, c
 void CPluginDirectory::CancelDirectory()
 {
   m_cancelled = true;
-  m_fetchComplete.Set();
 }
 
 float CPluginDirectory::GetProgress() const
diff --git a/xbmc/filesystem/PluginDirectory.h b/xbmc/filesystem/PluginDirectory.h
index cf4bc7b78451..bb535e28a876 100644
--- a/xbmc/filesystem/PluginDirectory.h
+++ b/xbmc/filesystem/PluginDirectory.h
@@ -67,17 +67,19 @@ class CPluginDirectory : public IDirectory, public CRunningScriptsHandler<CPlugi
   static void SetResolvedUrl(int handle, bool success, const CFileItem* resultItem);
   static void SetLabel2(int handle, const std::string& ident);
 
+protected:
+  // implementations of CRunningScriptsHandler / CScriptRunner
+  bool IsSuccessful() const override { return m_success; }
+  bool IsCancelled() const override { return m_cancelled; }
+
 private:
-  ADDON::AddonPtr m_addon;
   bool StartScript(const std::string& strPath, bool resume);
-  bool WaitOnScriptResult(const std::string &scriptPath, int scriptId, const std::string &scriptName);
 
   CFileItemList* m_listItems;
-  CFileItem*     m_fileResult;
-  CEvent         m_fetchComplete;
+  CFileItem* m_fileResult;
 
   std::atomic<bool> m_cancelled;
-  bool          m_success = false;      // set by script in EndOfDirectory
-  int    m_totalItems = 0;   // set by script in AddDirectoryItem
+  bool m_success = false;      // set by script in EndOfDirectory
+  int m_totalItems = 0;   // set by script in AddDirectoryItem
 };
 }
diff --git a/xbmc/interfaces/generic/CMakeLists.txt b/xbmc/interfaces/generic/CMakeLists.txt
index 6adc45072cbf..8fd742d9036d 100644
--- a/xbmc/interfaces/generic/CMakeLists.txt
+++ b/xbmc/interfaces/generic/CMakeLists.txt
@@ -1,13 +1,15 @@
 set(SOURCES ILanguageInvoker.cpp
             LanguageInvokerThread.cpp
             RunningScriptObserver.cpp
-            ScriptInvocationManager.cpp)
+            ScriptInvocationManager.cpp
+            ScriptRunner.cpp)
 
 set(HEADERS ILanguageInvocationHandler.h
             ILanguageInvoker.h
             LanguageInvokerThread.h
             RunningScriptsHandler.h
             RunningScriptObserver.h
-            ScriptInvocationManager.h)
+            ScriptInvocationManager.h
+            ScriptRunner.h)
 
 core_add_library(generic_interface)
diff --git a/xbmc/interfaces/generic/RunningScriptsHandler.h b/xbmc/interfaces/generic/RunningScriptsHandler.h
index 9e6037282d15..9ea410471f7e 100644
--- a/xbmc/interfaces/generic/RunningScriptsHandler.h
+++ b/xbmc/interfaces/generic/RunningScriptsHandler.h
@@ -8,14 +8,17 @@
 
 #pragma once
 
+#include "interfaces/generic/ScriptInvocationManager.h"
+#include "interfaces/generic/ScriptRunner.h"
 #include "threads/CriticalSection.h"
+#include "threads/Event.h"
 #include "threads/SingleLock.h"
 
 #include <cstdint>
 #include <map>
 
 template<class TScript>
-class CRunningScriptsHandler
+class CRunningScriptsHandler : protected CScriptRunner
 {
 protected:
   using HandleType = int;
@@ -23,6 +26,32 @@ class CRunningScriptsHandler
   CRunningScriptsHandler() = default;
   virtual ~CRunningScriptsHandler() = default;
 
+  using CScriptRunner::ExecuteScript;
+  using CScriptRunner::GetAddon;
+  using CScriptRunner::SetDone;
+  using CScriptRunner::StartScript;
+
+  bool RunScript(TScript* script, ADDON::AddonPtr addon, const std::string& path, bool resume)
+  {
+    if (script == nullptr || addon == nullptr || path.empty())
+      return false;
+
+    // reuse an existing script handle or get a new one if necessary
+    int handle = CScriptInvocationManager::GetInstance().GetReusablePluginHandle(addon->LibPath());
+    if (handle < 0)
+      handle = GetNewScriptHandle(script);
+    else
+      ReuseScriptHandle(handle, script);
+
+    // run the script
+    auto result = CScriptRunner::RunScript(addon, path, handle, resume);
+
+    // remove the script handle if necessary
+    RemoveScriptHandle(handle);
+
+    return result;
+  }
+
   static HandleType GetNewScriptHandle(TScript* script)
   {
     CSingleLock lock(s_critical);
diff --git a/xbmc/interfaces/generic/ScriptRunner.cpp b/xbmc/interfaces/generic/ScriptRunner.cpp
new file mode 100644
index 000000000000..eab78347fe6b
--- /dev/null
+++ b/xbmc/interfaces/generic/ScriptRunner.cpp
@@ -0,0 +1,145 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "ScriptRunner.h"
+
+#include "Application.h"
+#include "URL.h"
+#include "dialogs/GUIDialogBusy.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "interfaces/generic/RunningScriptObserver.h"
+#include "interfaces/generic/ScriptInvocationManager.h"
+#include "threads/SystemClock.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#include <vector>
+
+void CScriptRunner::SetDone()
+{
+  m_scriptDone.Set();
+}
+
+int CScriptRunner::ExecuteScript(ADDON::AddonPtr addon,
+                                 const std::string& path,
+                                 int handle,
+                                 bool resume)
+{
+  if (addon == nullptr || path.empty())
+    return false;
+
+  CURL url(path);
+
+  // get options and remove them from the URL because we can then use the url
+  // to generate the base path which is passed to the add-on script
+  auto options = url.GetOptions();
+  url.SetOptions("");
+
+  // setup our parameters to send the script
+  std::vector<std::string> argv = {url.Get(), // base path
+                                   StringUtils::Format("{:d}", handle), options,
+                                   StringUtils::Format("resume:{}", resume)};
+
+  bool reuseLanguageInvoker = false;
+  const auto reuseLanguageInvokerIt = addon->ExtraInfo().find("reuselanguageinvoker");
+  if (reuseLanguageInvokerIt != addon->ExtraInfo().end())
+    reuseLanguageInvoker = reuseLanguageInvokerIt->second == "true";
+
+  // run the script
+  CLog::Log(LOGDEBUG, "CScriptRunner: running add-on script {:s}('{:s}', '{:s}', '{:s}')",
+            addon->Name(), argv[0], argv[1], argv[2]);
+  int scriptId = CScriptInvocationManager::GetInstance().ExecuteAsync(addon->LibPath(), addon, argv,
+                                                                      reuseLanguageInvoker, handle);
+  if (scriptId < 0)
+    CLog::Log(LOGERROR, "CScriptRunner: unable to run add-on script {:s}", addon->Name());
+
+  return scriptId;
+}
+
+bool CScriptRunner::RunScriptInternal(
+    ADDON::AddonPtr addon, const std::string& path, int handle, bool resume, bool wait /* = true */)
+{
+  if (addon == nullptr || path.empty())
+    return false;
+
+  // reset our wait event
+  m_scriptDone.Reset();
+
+  // store the add-on
+  m_addon = addon;
+
+  int scriptId = ExecuteScript(addon, path, handle, resume);
+  if (scriptId < 0)
+    return false;
+
+  // we don't need to wait for the script to end
+  if (!wait)
+    return true;
+
+  // wait for our script to finish
+  return WaitOnScriptResult(scriptId, addon->LibPath(), addon->Name());
+}
+
+bool CScriptRunner::WaitOnScriptResult(int scriptId,
+                                       const std::string& path,
+                                       const std::string& name)
+{
+  bool cancelled = false;
+
+  // Add-on scripts can be called from the main and other threads. If called
+  // form the main thread, we need to bring up the BusyDialog in order to
+  // keep the render loop alive
+  if (g_application.IsCurrentThread())
+  {
+    if (!m_scriptDone.WaitMSec(20))
+    {
+      // observe the script until it's finished while showing the busy dialog
+      CRunningScriptObserver scriptObs(scriptId, m_scriptDone);
+
+      auto& wm = CServiceBroker::GetGUI()->GetWindowManager();
+      if (wm.IsModalDialogTopmost(WINDOW_DIALOG_PROGRESS))
+      {
+        auto progress = wm.GetWindow<CGUIDialogProgress>(WINDOW_DIALOG_PROGRESS);
+        if (!progress->WaitOnEvent(m_scriptDone))
+          cancelled = true;
+      }
+      else if (!CGUIDialogBusy::WaitOnEvent(m_scriptDone, 200))
+        cancelled = true;
+
+      scriptObs.Abort();
+    }
+  }
+  else
+  {
+    // wait for the script to finish or be cancelled
+    while (!IsCancelled() && CScriptInvocationManager::GetInstance().IsRunning(scriptId) &&
+           !m_scriptDone.WaitMSec(20))
+      ;
+
+    // give the script 30 seconds to exit before we attempt to stop it
+    XbmcThreads::EndTime timer(30000);
+    while (!timer.IsTimePast() && CScriptInvocationManager::GetInstance().IsRunning(scriptId) &&
+           !m_scriptDone.WaitMSec(20))
+      ;
+  }
+
+  if (cancelled || IsCancelled())
+  {
+    // cancel the script
+    if (scriptId != -1 && CScriptInvocationManager::GetInstance().IsRunning(scriptId))
+    {
+      CLog::Log(LOGDEBUG, "CScriptRunner: cancelling add-on script {:s} (id = {:d})", name,
+                scriptId);
+      CScriptInvocationManager::GetInstance().Stop(scriptId);
+    }
+  }
+
+  return !cancelled && !IsCancelled() && IsSuccessful();
+}
diff --git a/xbmc/interfaces/generic/ScriptRunner.h b/xbmc/interfaces/generic/ScriptRunner.h
new file mode 100644
index 000000000000..7f89c06a2588
--- /dev/null
+++ b/xbmc/interfaces/generic/ScriptRunner.h
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "addons/IAddon.h"
+#include "threads/Event.h"
+
+#include <string>
+
+class CScriptRunner
+{
+protected:
+  CScriptRunner() = default;
+  virtual ~CScriptRunner() = default;
+
+  virtual bool IsSuccessful() const = 0;
+  virtual bool IsCancelled() const = 0;
+
+  ADDON::AddonPtr GetAddon() const { return m_addon; }
+
+  inline bool StartScript(ADDON::AddonPtr addon, const std::string& path)
+  {
+    return RunScriptInternal(addon, path, 0, false);
+  }
+  inline bool RunScript(ADDON::AddonPtr addon, const std::string& path, int handle, bool resume)
+  {
+    return RunScriptInternal(addon, path, handle, resume, true);
+  }
+
+  void SetDone();
+
+  static inline int ExecuteScript(ADDON::AddonPtr addon, const std::string& path, bool resume)
+  {
+    return ExecuteScript(addon, path, -1, resume);
+  }
+  static int ExecuteScript(ADDON::AddonPtr addon, const std::string& path, int handle, bool resume);
+
+private:
+  bool RunScriptInternal(
+      ADDON::AddonPtr addon, const std::string& path, int handle, bool resume, bool wait = true);
+  bool WaitOnScriptResult(int scriptId, const std::string& path, const std::string& name);
+
+  ADDON::AddonPtr m_addon;
+
+  CEvent m_scriptDone;
+};

From f851876885ded149263eab27a90243fce8a0ba43 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Mon, 5 Jun 2017 17:38:31 +0200
Subject: [PATCH 63/88] [CAddonMediaImporter][utils] CUrlOptions: support
 arrays of options

---
 xbmc/utils/UrlOptions.cpp          | 126 ++++++++++++++++++++++++++++-
 xbmc/utils/UrlOptions.h            |   9 +++
 xbmc/utils/test/TestUrlOptions.cpp | 100 ++++++++++++++++++++++-
 3 files changed, 230 insertions(+), 5 deletions(-)

diff --git a/xbmc/utils/UrlOptions.cpp b/xbmc/utils/UrlOptions.cpp
index 2aa304b8c4d2..1725021e4382 100644
--- a/xbmc/utils/UrlOptions.cpp
+++ b/xbmc/utils/UrlOptions.cpp
@@ -6,6 +6,8 @@
  *  See LICENSES/README.md for more information.
  */
 
+#include <algorithm>
+
 #include "UrlOptions.h"
 
 #include "URL.h"
@@ -30,9 +32,28 @@ std::string CUrlOptions::GetOptionsString(bool withLeadingSeparator /* = false *
     if (!options.empty())
       options += "&";
 
-    options += CURL::Encode(opt.first);
-    if (!opt.second.empty())
-      options += "=" + CURL::Encode(opt.second.asString());
+    auto key = CURL::Encode(opt.first);
+    if (opt.second.empty())
+    {
+      options += key;
+      continue;
+    }
+
+    if (opt.second.isArray())
+    {
+      if (opt.second.size() > 1)
+        key += "[]";
+
+      for (auto option = opt.second.begin_array(); option != opt.second.end_array(); ++option)
+      {
+        if (option != opt.second.begin_array())
+          options += "&";
+
+        options += key + "=" + CURL::Encode(option->asString());
+      }
+    }
+    else
+      options += key + "=" + CURL::Encode(opt.second.asString());
   }
 
   if (withLeadingSeparator && !options.empty())
@@ -94,6 +115,72 @@ void CUrlOptions::AddOption(const std::string &key, bool value)
   m_options[key] = value;
 }
 
+void CUrlOptions::AddOption(const std::string &key, const std::vector<const char*>& values)
+{
+  if (key.empty())
+    return;
+
+  CVariant arr(CVariant::VariantTypeArray);
+  for (const auto& value : values)
+    arr.push_back(value);
+  m_options[key] = arr;
+}
+
+void CUrlOptions::AddOption(const std::string &key, const std::vector<std::string>& values)
+{
+  if (key.empty())
+    return;
+
+  CVariant arr(CVariant::VariantTypeArray);
+  for (const auto& value : values)
+    arr.push_back(value);
+  m_options[key] = arr;
+}
+
+void CUrlOptions::AddOption(const std::string &key, const std::vector<int>& values)
+{
+  if (key.empty())
+    return;
+
+  CVariant arr(CVariant::VariantTypeArray);
+  for (const auto& value : values)
+    arr.push_back(value);
+  m_options[key] = arr;
+}
+
+void CUrlOptions::AddOption(const std::string &key, const std::vector<float>& values)
+{
+  if (key.empty())
+    return;
+
+  CVariant arr(CVariant::VariantTypeArray);
+  for (const auto& value : values)
+    arr.push_back(value);
+  m_options[key] = arr;
+}
+
+void CUrlOptions::AddOption(const std::string &key, const std::vector<double>& values)
+{
+  if (key.empty())
+    return;
+
+  CVariant arr(CVariant::VariantTypeArray);
+  for (const auto& value : values)
+    arr.push_back(value);
+  m_options[key] = arr;
+}
+
+void CUrlOptions::AddOption(const std::string &key, const std::vector<bool>& values)
+{
+  if (key.empty())
+    return;
+
+  CVariant arr(CVariant::VariantTypeArray);
+  for (bool value : values)
+    arr.push_back(value);
+  m_options[key] = arr;
+}
+
 void CUrlOptions::AddOptions(const std::string &options)
 {
   if (options.empty())
@@ -113,6 +200,9 @@ void CUrlOptions::AddOptions(const std::string &options)
     strOptions.erase(0, 1);
   }
 
+  CVariant arr(CVariant::VariantTypeArray);
+  std::string lastKey;
+
   // split the options by & and process them one by one
   for (const auto &option : StringUtils::Split(strOptions, "&"))
   {
@@ -127,9 +217,37 @@ void CUrlOptions::AddOptions(const std::string &options)
       value = CURL::Decode(option.substr(pos + 1));
 
     // the key cannot be empty
-    if (!key.empty())
+    if (key.empty())
+      continue;
+
+    // check if this is an array option
+    bool isArrayOption = StringUtils::EndsWith(key, "[]");
+    if (isArrayOption)
+      key = key.substr(0, key.size() - 2);
+
+    // if we haven't finished processing the previous option and the new option
+    // is different, finish processing the previous option
+    if (!lastKey.empty() && key != lastKey)
+    {
+      m_options[lastKey] = arr;
+
+      lastKey.clear();
+      arr.clear();
+    }
+
+    // if this is not an array option just add it
+    if (!isArrayOption)
       AddOption(key, value);
+    else
+    {
+      // otherwise remember the key and add the value to the array
+      lastKey = key;
+      arr.push_back(value);
+    }
   }
+
+  if (!lastKey.empty())
+    m_options[lastKey] = arr;
 }
 
 void CUrlOptions::AddOptions(const CUrlOptions &options)
diff --git a/xbmc/utils/UrlOptions.h b/xbmc/utils/UrlOptions.h
index 1fa7ac60cfbf..07e06248f5d5 100644
--- a/xbmc/utils/UrlOptions.h
+++ b/xbmc/utils/UrlOptions.h
@@ -33,8 +33,17 @@ class CUrlOptions
   virtual void AddOption(const std::string &key, float value);
   virtual void AddOption(const std::string &key, double value);
   virtual void AddOption(const std::string &key, bool value);
+
+  virtual void AddOption(const std::string &key, const std::vector<const char*>& values);
+  virtual void AddOption(const std::string &key, const std::vector<std::string>& values);
+  virtual void AddOption(const std::string &key, const std::vector<int>& values);
+  virtual void AddOption(const std::string &key, const std::vector<float>& values);
+  virtual void AddOption(const std::string &key, const std::vector<double>& values);
+  virtual void AddOption(const std::string &key, const std::vector<bool>& values);
+
   virtual void AddOptions(const std::string &options);
   virtual void AddOptions(const CUrlOptions &options);
+
   virtual void RemoveOption(const std::string &key);
 
   bool HasOption(const std::string &key) const;
diff --git a/xbmc/utils/test/TestUrlOptions.cpp b/xbmc/utils/test/TestUrlOptions.cpp
index f684fe5950d9..efcc49879131 100644
--- a/xbmc/utils/test/TestUrlOptions.cpp
+++ b/xbmc/utils/test/TestUrlOptions.cpp
@@ -101,6 +101,104 @@ TEST(TestUrlOptions, AddOption)
   }
 }
 
+TEST(TestUrlOptions, AddArrayOption)
+{
+  const char *keyChar = "char";
+  const char *keyString = "string";
+  const char *keyInt = "int";
+  const char *keyFloat = "float";
+  const char *keyDouble = "double";
+  const char *keyBool = "bool";
+
+  const char *valueChar = "valueChar";
+  std::vector<const char*> valuesChar(2, valueChar);
+  const std::string valueString = "valueString";
+  std::vector<std::string> valuesString(2, valueString);
+  int valueInt = 1;
+  std::vector<int> valuesInt(2, valueInt);
+  float valueFloat = 1.0f;
+  std::vector<float> valuesFloat(2, valueFloat);
+  double valueDouble = 1.0;
+  std::vector<double> valuesDouble(2, valueDouble);
+  bool valueBool = true;
+  std::vector<bool> valuesBool(2, valueBool);
+
+  CVariant variantValue;
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption(keyChar, valuesChar);
+  {
+    CVariant variantValues;
+    EXPECT_TRUE(urlOptions.GetOption(keyChar, variantValues));
+    EXPECT_TRUE(variantValues.isArray());
+    for (auto value = variantValues.begin_array(); value != variantValues.end_array(); ++value)
+    {
+      EXPECT_TRUE(value->isString());
+      EXPECT_STREQ(valueChar, value->asString().c_str());
+    }
+  }
+
+  urlOptions.AddOption(keyString, valuesString);
+  {
+    CVariant variantValues;
+    EXPECT_TRUE(urlOptions.GetOption(keyString, variantValues));
+    EXPECT_TRUE(variantValues.isArray());
+    for (auto value = variantValues.begin_array(); value != variantValues.end_array(); ++value)
+    {
+      EXPECT_TRUE(value->isString());
+      EXPECT_STREQ(valueString.c_str(), value->asString().c_str());
+    }
+  }
+
+  urlOptions.AddOption(keyInt, valuesInt);
+  {
+    CVariant variantValues;
+    EXPECT_TRUE(urlOptions.GetOption(keyInt, variantValues));
+    EXPECT_TRUE(variantValues.isArray());
+    for (auto value = variantValues.begin_array(); value != variantValues.end_array(); ++value)
+    {
+      EXPECT_TRUE(value->isInteger());
+      EXPECT_EQ(valueInt, static_cast<int>(value->asInteger()));
+    }
+  }
+
+  urlOptions.AddOption(keyFloat, valuesFloat);
+  {
+    CVariant variantValues;
+    EXPECT_TRUE(urlOptions.GetOption(keyFloat, variantValues));
+    EXPECT_TRUE(variantValues.isArray());
+    for (auto value = variantValues.begin_array(); value != variantValues.end_array(); ++value)
+    {
+      EXPECT_TRUE(value->isDouble());
+      EXPECT_EQ(valueFloat, value->asFloat());
+    }
+  }
+
+  urlOptions.AddOption(keyDouble, valuesDouble);
+  {
+    CVariant variantValues;
+    EXPECT_TRUE(urlOptions.GetOption(keyDouble, variantValues));
+    EXPECT_TRUE(variantValues.isArray());
+    for (auto value = variantValues.begin_array(); value != variantValues.end_array(); ++value)
+    {
+      EXPECT_TRUE(value->isDouble());
+      EXPECT_EQ(valueDouble, value->asDouble());
+    }
+  }
+
+  urlOptions.AddOption(keyBool, valuesBool);
+  {
+    CVariant variantValues;
+    EXPECT_TRUE(urlOptions.GetOption(keyBool, variantValues));
+    EXPECT_TRUE(variantValues.isArray());
+    for (auto value = variantValues.begin_array(); value != variantValues.end_array(); ++value)
+    {
+      EXPECT_TRUE(value->isBoolean());
+      EXPECT_EQ(valueBool, value->asBoolean());
+    }
+  }
+}
+
 TEST(TestUrlOptions, AddOptions)
 {
   std::string ref = "foo=bar&key=value";
@@ -185,7 +283,7 @@ TEST(TestUrlOptions, GetOptions)
 
 TEST(TestUrlOptions, GetOptionsString)
 {
-  const char *ref = "foo=bar&key";
+  const char *ref = "array[]=1&array[]=2&foo=bar&key";
 
   CUrlOptions urlOptions(ref);
   std::string value = urlOptions.GetOptionsString();

From aff1bf3b8c1727c650848a708908de18fe0e7c89 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 6 Jun 2017 16:13:06 +0200
Subject: [PATCH 64/88] [CAddonMediaImporter][codegenerator] add and use
 SwigType_lrtype() for local reference types

---
 tools/codegenerator/SwigTypeParser.groovy          | 14 ++++++++++++++
 .../python/typemaps/python.Alternative.outtm       |  2 +-
 xbmc/interfaces/python/typemaps/python.Tuple.outtm |  2 +-
 3 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/tools/codegenerator/SwigTypeParser.groovy b/tools/codegenerator/SwigTypeParser.groovy
index 24437f228d7a..8d8a64469862 100644
--- a/tools/codegenerator/SwigTypeParser.groovy
+++ b/tools/codegenerator/SwigTypeParser.groovy
@@ -269,6 +269,20 @@ public class SwigTypeParser
       //return result.replaceAll('<\\(', '<').replaceAll('\\)>', '>')
    }
 
+   /**
+    * SwigType_lrtype(const SwigType *ty)
+    *
+    * Create a locally assignable reference type
+    */
+   public static String SwigType_lrtype(String s) {
+      String ltype = SwigType_ltype(s);
+      if (SwigType_ispointer(s)) {
+         return ltype;
+      } else {
+         return "r." + ltype;
+      }
+   }
+   
    /**
    * This creates the C++ declaration for a valid ltype for the type string
    * given. For example, if the type is a "const char*" which is equivalent
diff --git a/xbmc/interfaces/python/typemaps/python.Alternative.outtm b/xbmc/interfaces/python/typemaps/python.Alternative.outtm
index ff94ecd43d1e..31f42051cdb3 100644
--- a/xbmc/interfaces/python/typemaps/python.Alternative.outtm
+++ b/xbmc/interfaces/python/typemaps/python.Alternative.outtm
@@ -21,7 +21,7 @@
 %>
       if (pos == XBMCAddon::${altSwitch[entryIndex]})
       {
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(curType))}& entry${seq} = ${api}${accessor}${altAccess[entryIndex]}();
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_lrtype(curType))} entry${seq} = ${api}${accessor}${altAccess[entryIndex]}();
         {
           ${helper.getOutConversion(curType,result,method,[ 'api' : 'entry' + seq, 'sequence' : sequence ])}
         }
diff --git a/xbmc/interfaces/python/typemaps/python.Tuple.outtm b/xbmc/interfaces/python/typemaps/python.Tuple.outtm
index a56c6072fefa..18655fe2ac48 100644
--- a/xbmc/interfaces/python/typemaps/python.Tuple.outtm
+++ b/xbmc/interfaces/python/typemaps/python.Tuple.outtm
@@ -27,7 +27,7 @@
 
       if (vecSize > ${entryIndex})
       {
-        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(curType))}& entry${seq} = ${api}${accessor}${tupleAccess[entryIndex]}();
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_lrtype(curType))} entry${seq} = ${api}${accessor}${tupleAccess[entryIndex]}();
         {
           ${helper.getOutConversion(curType,'result',method,[ 'result' : 'pyentry' + seq, 'api' : 'entry' + seq, 'sequence' : sequence ])}
         }

From 1e45a3b2fcb7840dbe4eff70e554b3052221da62 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 2 Apr 2020 15:40:39 +0200
Subject: [PATCH 65/88] [CAddonMediaImporter][interfaces/legacy] add
 ListItem::setDynamicPath()

---
 xbmc/interfaces/legacy/ListItem.cpp |  6 ++++++
 xbmc/interfaces/legacy/ListItem.h   | 29 +++++++++++++++++++++++++++++
 2 files changed, 35 insertions(+)

diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index f73df260bbb2..b9f5b2d3fed4 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -272,6 +272,12 @@ namespace XBMCAddon
       item->SetPath(path);
     }
 
+    void ListItem::setDynamicPath(const String& path)
+    {
+      XBMCAddonUtils::GuiLock lock(languageHook, m_offscreen);
+      item->SetDynPath(path);
+    }
+
     void ListItem::setMimeType(const String& mimetype)
     {
       XBMCAddonUtils::GuiLock lock(languageHook, m_offscreen);
diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index 6d030c9c55da..79ca1b18ef81 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -960,6 +960,35 @@ namespace XBMCAddon
       void setPath(const String& path);
 #endif
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcgui_listitem
+      /// @brief \python_func{ setDynamicPath(path) }
+      ///-----------------------------------------------------------------------
+      /// Sets the listitem's dynamic path.
+      ///
+      /// @param path           string or unicode - dynamic path.
+      ///
+      /// @note You can use the above as keywords for arguments.
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      ///
+      /// **Example:**
+      /// ~~~~~~~~~~~~~{.py}
+      /// ...
+      /// listitem.setDynamicPath(path='/path/to/some/file.ext')
+      /// ...
+      /// ~~~~~~~~~~~~~
+      ///
+      ///-----------------------------------------------------------------------
+      /// @python_v19 New function added.
+      ///
+      setDynamicPath(...);
+#else
+      void setDynamicPath(const String& path);
+#endif
+
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_xbmcgui_listitem

From 201614d16757f8fd2bea9d2ec0f20af0f9159bc8 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Fri, 3 Apr 2020 23:28:14 +0200
Subject: [PATCH 66/88] [CAddonMediaImporter][interfaces/legacy] add
 ListItem::isFolder()

---
 xbmc/interfaces/legacy/ListItem.cpp |  6 ++++++
 xbmc/interfaces/legacy/ListItem.h   | 22 ++++++++++++++++++++++
 2 files changed, 28 insertions(+)

diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index b9f5b2d3fed4..b3c66e3c6d49 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -248,6 +248,12 @@ namespace XBMCAddon
       return item->GetArt(key);
     }
 
+    bool ListItem::isFolder() const
+    {
+      XBMCAddonUtils::GuiLock lock(languageHook, m_offscreen);
+      return item->m_bIsFolder;
+    }
+
     String ListItem::getUniqueID(const char* key)
     {
       XBMCAddonUtils::GuiLock lock(languageHook, m_offscreen);
diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index 79ca1b18ef81..4e5c175d1aaa 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -384,6 +384,28 @@ namespace XBMCAddon
       String getArt(const char* key);
 #endif
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcgui_listitem
+      /// @brief \python_func{ isFolder() }
+      ///-----------------------------------------------------------------------
+      /// Returns whether the item is a folder or not.
+      ///
+      ///-----------------------------------------------------------------------
+      /// @python_v19 New function added.
+      ///
+      /// **Example:**
+      /// ~~~~~~~~~~~~~{.py}
+      /// ...
+      /// isFolder = listitem.isFolder()
+      /// ...
+      /// ~~~~~~~~~~~~~
+      ///
+      isFolder();
+#else
+      bool isFolder() const;
+#endif
+
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_xbmcgui_listitem

From 63dc0b03166d6e62e5b7ab608ff504071ba621f0 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 10 Jun 2017 12:07:28 +0200
Subject: [PATCH 67/88] [CAddonMediaImporter][interfaces/legacy] ListItem: add
 getDatetime() and setDateTime()

---
 xbmc/interfaces/legacy/ListItem.cpp | 24 ++++++++++++++
 xbmc/interfaces/legacy/ListItem.h   | 50 +++++++++++++++++++++++++++++
 2 files changed, 74 insertions(+)

diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index b3c66e3c6d49..994c0ac22a63 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -101,6 +101,30 @@ namespace XBMCAddon
       }
     }
 
+    String ListItem::getDateTime()
+    {
+      if (!item) return "";
+
+      String ret;
+      {
+        XBMCAddonUtils::GuiLock lock(languageHook, m_offscreen);
+        if (item->m_dateTime.IsValid())
+          ret = item->m_dateTime.GetAsW3CDateTime();
+      }
+
+      return ret;
+    }
+
+    void ListItem::setDateTime(const String& dateTime)
+    {
+      if (!item) return;
+      // set label
+      {
+        XBMCAddonUtils::GuiLock lock(languageHook, m_offscreen);
+        item->m_dateTime.SetFromW3CDateTime(dateTime);
+      }
+    }
+
     void ListItem::setArt(const Properties& dictionary)
     {
       if (!item) return;
diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index 4e5c175d1aaa..e5682c4b2ad9 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -189,6 +189,56 @@ namespace XBMCAddon
       void setLabel2(const String& label);
 #endif
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcgui_listitem
+      /// @brief \python_func{ getDateTime() }
+      ///-----------------------------------------------------------------------
+      /// Returns the listitem datetime (ISO 8601).
+      ///
+      /// @return                       datetime (ISO 8601) of item
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      ///
+      /// **Example:**
+      /// ~~~~~~~~~~~~~{.py}
+      /// ...
+      /// # getDateTime()
+      /// dateTime = listitem.getDateTime()
+      /// ...
+      /// ~~~~~~~~~~~~~
+      ///
+      getDateTime();
+#else
+      String getDateTime();
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcgui_listitem
+      /// @brief \python_func{ setDateTime(dateTime) }
+      ///-----------------------------------------------------------------------
+      /// Sets the listitem's datetime (ISO 8601).
+      ///
+      /// @param label              string or unicode - datetime string (ISO 8601).
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      ///
+      /// **Example:**
+      /// ~~~~~~~~~~~~~{.py}
+      /// ...
+      /// # setDate(dateTime)
+      /// listitem.setDateTime('TODO')
+      /// ...
+      /// ~~~~~~~~~~~~~
+      ///
+      setDateTime(...);
+#else
+      void setDateTime(const String& dateTime);
+#endif
+
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_xbmcgui_listitem

From 199238bcb1fd2dc1e6164a381656c21c42236fae Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 14 Dec 2019 01:02:45 +0100
Subject: [PATCH 68/88] [CAddonMediaImporter][interfaces/legacy] add
 InfoTagVideo::getFilenameAndPath()

---
 xbmc/interfaces/legacy/InfoTagVideo.cpp |  5 +++++
 xbmc/interfaces/legacy/InfoTagVideo.h   | 18 ++++++++++++++++++
 2 files changed, 23 insertions(+)

diff --git a/xbmc/interfaces/legacy/InfoTagVideo.cpp b/xbmc/interfaces/legacy/InfoTagVideo.cpp
index 38100e0eafca..994d93a5de93 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.cpp
+++ b/xbmc/interfaces/legacy/InfoTagVideo.cpp
@@ -109,6 +109,11 @@ namespace XBMCAddon
       return infoTag->m_strPath;
     }
 
+    String InfoTagVideo::getFilenameAndPath()
+    {
+      return infoTag->m_strFileNameAndPath;
+    }
+
     String InfoTagVideo::getIMDBNumber()
     {
       return infoTag->GetUniqueID();
diff --git a/xbmc/interfaces/legacy/InfoTagVideo.h b/xbmc/interfaces/legacy/InfoTagVideo.h
index 9c7e046ff41e..4dfb28f11192 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.h
+++ b/xbmc/interfaces/legacy/InfoTagVideo.h
@@ -320,6 +320,24 @@ namespace XBMCAddon
       String getPath();
 #endif
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_InfoTagVideo
+      /// @brief \python_func{ getFilenameAndPath() }
+      ///-----------------------------------------------------------------------
+      /// To get the full path where the video is available.
+      ///
+      /// @return [string] Path
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      /// @python_v19 New function added.
+      ///
+      getFilenameAndPath();
+#else
+      String getFilenameAndPath();
+#endif
+
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_InfoTagVideo

From cdece3aebf31116b6e9c5305d16e374247dc702e Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 14 Dec 2019 01:03:14 +0100
Subject: [PATCH 69/88] [CAddonMediaImporter][interfaces/legacy] add
 InfoTagVideo::getUniqueID() / ::setUniqueIDs()

---
 xbmc/interfaces/legacy/InfoTagVideo.cpp | 16 +++++++
 xbmc/interfaces/legacy/InfoTagVideo.h   | 55 +++++++++++++++++++++++++
 xbmc/interfaces/swig/AddonModuleXbmc.i  |  1 +
 3 files changed, 72 insertions(+)

diff --git a/xbmc/interfaces/legacy/InfoTagVideo.cpp b/xbmc/interfaces/legacy/InfoTagVideo.cpp
index 994d93a5de93..d2d762cefbb6 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.cpp
+++ b/xbmc/interfaces/legacy/InfoTagVideo.cpp
@@ -193,5 +193,21 @@ namespace XBMCAddon
     {
       return infoTag->GetDuration();
     }
+
+    String InfoTagVideo::getUniqueID(const char* key)
+    {
+      return infoTag->GetUniqueID(key);
+    }
+
+    void InfoTagVideo::setUniqueIDs(const XBMCAddon::Properties& dictionary, const String& defaultUniqueID /* = "" */)
+    {
+      infoTag->SetUniqueIDs(dictionary);
+      if (!defaultUniqueID.empty())
+      {
+        const auto& uniqueID = dictionary.find(defaultUniqueID);
+        if (uniqueID != dictionary.end())
+          infoTag->SetUniqueID(uniqueID->second, uniqueID->first, true);
+      }
+    }
   }
 }
diff --git a/xbmc/interfaces/legacy/InfoTagVideo.h b/xbmc/interfaces/legacy/InfoTagVideo.h
index 4dfb28f11192..b8dbd4ea6dec 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.h
+++ b/xbmc/interfaces/legacy/InfoTagVideo.h
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "AddonClass.h"
+#include "Dictionary.h"
 #include "video/VideoInfoTag.h"
 
 namespace XBMCAddon
@@ -611,6 +612,60 @@ namespace XBMCAddon
 #else
       unsigned int getDuration();
 #endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_InfoTagVideo
+      /// @brief \python_func{ getUniqueID(key) }
+      ///-----------------------------------------------------------------------
+      /// To get the uniqueID of the given key
+      ///
+      /// @param key            string - uniqueID name.
+      /// - Some default uniqueID values (any string possible):
+      ///  | Label         | Type                                             |
+      ///  |---------------|--------------------------------------------------|
+      ///  | imdb          | string - uniqueid name
+      ///  | tvdb          | string - uniqueid name
+      ///  | tmdb          | string - uniqueid name
+      ///  | anidb         | string - uniqueid name
+      ///
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      /// @python_v19 New function added.
+      ///
+      getUniqueID(key);
+#else
+      String getUniqueID(const char* key);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_InfoTagVideo
+      /// @brief \python_func{ setUniqueIDs(values, defaultUniqueID) }
+      ///-----------------------------------------------------------------------
+      /// To set the given uniqueIDs
+      ///
+      /// @param values             dictionary - pairs of `{ label: value }`.
+      /// @param defaultUniqueID    [opt] string - the name of default uniqueID.
+      ///
+      ///  - Some example values (any string possible):
+      ///  | Label         | Type                                              |
+      ///  |:-------------:|:--------------------------------------------------|
+      ///  | imdb          | string - uniqueid name
+      ///  | tvdb          | string - uniqueid name
+      ///  | tmdb          | string - uniqueid name
+      ///  | anidb         | string - uniqueid name
+      ///
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      /// @python_v19 New function added.
+      ///
+      setUniqueIDs(...);
+#else
+      void setUniqueIDs(const XBMCAddon::Properties& dictionary, const String& defaultUniqueID = "");
+#endif
     };
   }
 }
diff --git a/xbmc/interfaces/swig/AddonModuleXbmc.i b/xbmc/interfaces/swig/AddonModuleXbmc.i
index 27fcf45051f4..b3225a013f4b 100644
--- a/xbmc/interfaces/swig/AddonModuleXbmc.i
+++ b/xbmc/interfaces/swig/AddonModuleXbmc.i
@@ -36,6 +36,7 @@ using namespace xbmc;
 
 %include "interfaces/legacy/AddonString.h"
 %include "interfaces/legacy/ModuleXbmc.h"
+%include "interfaces/legacy/Dictionary.h"
 
 %feature("director") Player;
 

From 4edabfa8ee60d8415d4ec1c88ebd7fb654d8431b Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 15 Dec 2019 00:53:34 +0100
Subject: [PATCH 70/88] [CAddonMediaImporter][interfaces/legacy] make
 InfoTagVideo capable of accessing / modifying an existing CVideoInfoTag
 instance

---
 xbmc/interfaces/legacy/InfoTagVideo.cpp | 23 ++++++++++++++---------
 xbmc/interfaces/legacy/InfoTagVideo.h   |  4 +++-
 xbmc/interfaces/legacy/ListItem.cpp     |  4 +---
 xbmc/interfaces/legacy/Player.cpp       |  2 +-
 4 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/xbmc/interfaces/legacy/InfoTagVideo.cpp b/xbmc/interfaces/legacy/InfoTagVideo.cpp
index d2d762cefbb6..37397f1d906b 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.cpp
+++ b/xbmc/interfaces/legacy/InfoTagVideo.cpp
@@ -18,19 +18,24 @@ namespace XBMCAddon
   namespace xbmc
   {
     InfoTagVideo::InfoTagVideo()
-    {
-      infoTag = new CVideoInfoTag();
-    }
+      : infoTag(new CVideoInfoTag)
+      , owned(true)
+    { }
 
-    InfoTagVideo::InfoTagVideo(const CVideoInfoTag& tag)
-    {
-      infoTag = new CVideoInfoTag();
-      *infoTag = tag;
-    }
+    InfoTagVideo::InfoTagVideo(const CVideoInfoTag* tag)
+      : infoTag(new CVideoInfoTag(*tag))
+      , owned(true)
+    { }
+
+    InfoTagVideo::InfoTagVideo(CVideoInfoTag* tag)
+      : infoTag(tag)
+      , owned(false)
+    { }
 
     InfoTagVideo::~InfoTagVideo()
     {
-      delete infoTag;
+      if (owned)
+        delete infoTag;
     }
 
     int InfoTagVideo::getDbId()
diff --git a/xbmc/interfaces/legacy/InfoTagVideo.h b/xbmc/interfaces/legacy/InfoTagVideo.h
index b8dbd4ea6dec..30514224fd9f 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.h
+++ b/xbmc/interfaces/legacy/InfoTagVideo.h
@@ -46,10 +46,12 @@ namespace XBMCAddon
     {
     private:
       CVideoInfoTag* infoTag;
+      bool owned;
 
     public:
 #ifndef SWIG
-      explicit InfoTagVideo(const CVideoInfoTag& tag);
+      explicit InfoTagVideo(const CVideoInfoTag* tag);
+      explicit InfoTagVideo(CVideoInfoTag* tag);
 #endif
       InfoTagVideo();
       ~InfoTagVideo() override;
diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index 994c0ac22a63..ae518ab3ef53 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -821,9 +821,7 @@ namespace XBMCAddon
     xbmc::InfoTagVideo* ListItem::getVideoInfoTag()
     {
       XBMCAddonUtils::GuiLock lock(languageHook, m_offscreen);
-      if (item->HasVideoInfoTag())
-        return new xbmc::InfoTagVideo(*GetVideoInfoTag());
-      return new xbmc::InfoTagVideo();
+      return new xbmc::InfoTagVideo(GetVideoInfoTag());
     }
 
     xbmc::InfoTagMusic* ListItem::getMusicInfoTag()
diff --git a/xbmc/interfaces/legacy/Player.cpp b/xbmc/interfaces/legacy/Player.cpp
index 0ce107bf970a..cf10063b34bc 100644
--- a/xbmc/interfaces/legacy/Player.cpp
+++ b/xbmc/interfaces/legacy/Player.cpp
@@ -358,7 +358,7 @@ namespace XBMCAddon
 
       const CVideoInfoTag* movie = CServiceBroker::GetGUI()->GetInfoManager().GetCurrentMovieTag();
       if (movie)
-        return new InfoTagVideo(*movie);
+        return new InfoTagVideo(movie);
 
       return new InfoTagVideo();
     }

From 72cc7e1ac6309a842d0076939c8216e8e8b8f1e9 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Mon, 13 Apr 2020 23:39:55 +0200
Subject: [PATCH 71/88] [CAddonMediaImporter][interfaces/legacy] properly fill
 SActorInfo::thumb in ListItem::setCast()

---
 xbmc/interfaces/legacy/ListItem.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index ae518ab3ef53..47db8603e4fa 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -691,7 +691,11 @@ namespace XBMCAddon
           else if (key == "role")
             info.strRole = value;
           else if (key == "thumbnail")
+          {
             info.thumbUrl = CScraperUrl(value);
+            if (!info.thumbUrl.GetFirstThumbUrl().empty())
+              info.thumb = CScraperUrl::GetThumbUrl(info.thumbUrl.GetFirstUrlByType());
+          }
           else if (key == "order")
             info.order = strtol(value.c_str(), nullptr, 10);
         }

From b05242f669e952e574589d56b09d766cd071fcb3 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Fri, 24 Jan 2020 15:37:31 +0100
Subject: [PATCH 72/88] [CAddonMediaImporter][interfaces/legacy] add
 Player.getPlayingItem()

---
 xbmc/interfaces/legacy/Player.cpp | 10 ++++++++++
 xbmc/interfaces/legacy/Player.h   | 15 +++++++++++++++
 2 files changed, 25 insertions(+)

diff --git a/xbmc/interfaces/legacy/Player.cpp b/xbmc/interfaces/legacy/Player.cpp
index cf10063b34bc..1fb2b189a312 100644
--- a/xbmc/interfaces/legacy/Player.cpp
+++ b/xbmc/interfaces/legacy/Player.cpp
@@ -350,6 +350,16 @@ namespace XBMCAddon
       return g_application.CurrentFileItem().GetDynPath();
     }
 
+    XBMCAddon::xbmcgui::ListItem* Player::getPlayingItem()
+    {
+      XBMC_TRACE;
+      if (!g_application.GetAppPlayer().IsPlaying())
+        throw PlayerException("XBMC is not playing any item");
+
+      CFileItemPtr itemPtr = std::make_shared<CFileItem>(g_application.CurrentFileItem());
+      return new XBMCAddon::xbmcgui::ListItem(itemPtr);
+    }
+
     InfoTagVideo* Player::getVideoInfoTag()
     {
       XBMC_TRACE;
diff --git a/xbmc/interfaces/legacy/Player.h b/xbmc/interfaces/legacy/Player.h
index 80d0021d8625..3e1fa3e8e42a 100644
--- a/xbmc/interfaces/legacy/Player.h
+++ b/xbmc/interfaces/legacy/Player.h
@@ -458,6 +458,21 @@ namespace XBMCAddon
       String getPlayingFile();
 #endif
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_Player
+      /// @brief \python_func{ getPlayingItem() }
+      ///-----------------------------------------------------------------------
+      /// Returns the current playing item.
+      ///
+      /// @return                    Playing item
+      /// @throws Exception          If player is not playing a file.
+      ///
+      getPlayingItem();
+#else
+      XBMCAddon::xbmcgui::ListItem* getPlayingItem();
+#endif
+
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_Player

From ecec25ba2f0f5da7a72d70b8c93ec157df8d80a4 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 13 Oct 2019 00:35:53 +0200
Subject: [PATCH 73/88] [CAddonMediaImporter][python/swig] support passing sets
 to and from python / C++

---
 .../interfaces/python/PythonSwig.cpp.template |  4 +-
 .../python/typemaps/python.set.intm           | 35 ++++++++++++++++
 .../python/typemaps/python.set.outtm          | 41 +++++++++++++++++++
 3 files changed, 79 insertions(+), 1 deletion(-)
 create mode 100644 xbmc/interfaces/python/typemaps/python.set.intm
 create mode 100644 xbmc/interfaces/python/typemaps/python.set.outtm

diff --git a/xbmc/interfaces/python/PythonSwig.cpp.template b/xbmc/interfaces/python/PythonSwig.cpp.template
index 1a46bad6446a..974f577c25c9 100644
--- a/xbmc/interfaces/python/PythonSwig.cpp.template
+++ b/xbmc/interfaces/python/PythonSwig.cpp.template
@@ -60,7 +60,8 @@ Helper.setup(this,classes,
       (Pattern.compile('''std::unique_ptr<\\(.*\\)>''')) : new File('typemaps/python.smart_ptr.outtm'),
       (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('typemaps/python.vector.outtm'),
       (Pattern.compile('''(p.){0,1}Tuple<\\(.*\\)>''')) : new File('typemaps/python.Tuple.outtm'),
-      (Pattern.compile('''(p.){0,1}Alternative<\\(.*\\)>''')) : new File('typemaps/python.Alternative.outtm')
+      (Pattern.compile('''(p.){0,1}Alternative<\\(.*\\)>''')) : new File('typemaps/python.Alternative.outtm'),
+      (Pattern.compile('''(p.){0,1}std::set<\\(.*\\)>''')) : new File('typemaps/python.set.outtm')
     ], '${result} = makePythonInstance(${api},true);',
     /**
      * This is meant to contain mini-templates for converting the parameter types
@@ -78,6 +79,7 @@ Helper.setup(this,classes,
       (Pattern.compile('''(r.){0,1}XbmcCommons::Buffer''')) : new File('typemaps/python.buffer.intm'),
       (Pattern.compile('''(p.){0,1}std::map<\\(.*\\)>''')) : new File('typemaps/python.map.intm'),
       (Pattern.compile('''(r.){0,1}XBMCAddon::Dictionary<\\(.*\\)>''')) : new File('typemaps/python.dict.intm'),
+      (Pattern.compile('''(p.){0,1}std::set<\\(.*\\)>''')) : new File('typemaps/python.set.intm'),
       (Pattern.compile('''p.void''')) : '${api} = (void*)${slarg};',
       'bool' : '${api} = (PyLong_AsLong(${slarg}) == 0L ? false : true);',
       'long' : '${api} = PyLong_AsLong(${slarg});',
diff --git a/xbmc/interfaces/python/typemaps/python.set.intm b/xbmc/interfaces/python/typemaps/python.set.intm
new file mode 100644
index 000000000000..c6c6514678d5
--- /dev/null
+++ b/xbmc/interfaces/python/typemaps/python.set.intm
@@ -0,0 +1,35 @@
+<%
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+    List templateArgs = swigTypeParser.SwigType_templateparmlist(ltype)
+    settype = templateArgs[0]
+    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
+    String accessor = ispointer ? '->' : '.'
+    int seq = sequence.increment()
+%>
+    if (${slarg})
+    {
+      bool isList = PyObject_TypeCheck(${slarg},&PyList_Type);
+      if (!isList && !PyObject_TypeCheck(${slarg},&PySet_Type))
+        throw WrongTypeException("The parameter \"${api}\" must be a set.");
+
+      <%  if (ispointer) print("${api} = new std::set<${swigTypeParser.SwigType_str(settype)}>();") %>
+      PyObject *pyentry${seq} = NULL;
+      int setSize = isList ? PyList_Size(${slarg}) : PySet_Size(${slarg});
+      for(int i = 0; i < setSize; i++)
+      {
+        pyentry${seq} = isList ? PyList_GetItem(${slarg}, i) : PySet_Pop(${slarg});
+        ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_ltype(settype))} entry${seq};
+        ${helper.getInConversion(settype, 'entry' + seq, 'pyentry' + seq, method,
+                                 [ 'type' : settype,
+                                   'ltype' : swigTypeParser.SwigType_ltype(settype),
+                                   'sequence' : sequence
+                                   ])}
+        ${api}${accessor}insert(entry${seq});
+      }
+    }
diff --git a/xbmc/interfaces/python/typemaps/python.set.outtm b/xbmc/interfaces/python/typemaps/python.set.outtm
new file mode 100644
index 000000000000..0bdb7cd23e70
--- /dev/null
+++ b/xbmc/interfaces/python/typemaps/python.set.outtm
@@ -0,0 +1,41 @@
+<%
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+    List templateArgs = swigTypeParser.SwigType_templateparmlist(type)
+    settype = templateArgs[0]
+    boolean ispointer = swigTypeParser.SwigType_ispointer(type)
+    String settype_modifier = "const"
+    if (swigTypeParser.SwigType_ispointer(settype))
+    {
+      settype_modifier = ""
+    }
+    String accessor = ispointer ? '->' : '.'
+    seq = sequence.increment()
+
+    if (ispointer)
+    {
+%>
+    if (${api} != NULL)
+    { 
+<%  }  %>
+      ${result} = PySet_New(0);
+
+      for (std::set<${swigTypeParser.SwigType_str(settype)}>::iterator iter = ${api}${accessor}begin(); iter != ${api}${accessor}end(); ++iter)
+      {
+        ${settype_modifier} ${swigTypeParser.SwigType_str(swigTypeParser.SwigType_lrtype(settype))} entry${seq} = *iter;
+        PyObject* pyentry${seq};
+        ${helper.getOutConversion(settype,'result',method,[ 'result' : 'pyentry' + seq, 'api' : 'entry' + seq, 'sequence' : sequence ])}
+        PySet_Add(${result}, pyentry${seq});
+        Py_DECREF(pyentry${seq});
+      }
+<%
+    if (ispointer)
+    {
+%>
+    }
+<%  }  %>

From deb8f0eb3e70f1df0463547785c1802123aaf1c9 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 21 Nov 2019 22:54:05 +0100
Subject: [PATCH 74/88] [CAddonMediaImporter][swig/python] support classes
 without a constructor

---
 xbmc/interfaces/python/PythonSwig.cpp.template | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/interfaces/python/PythonSwig.cpp.template b/xbmc/interfaces/python/PythonSwig.cpp.template
index 974f577c25c9..467ed29d9285 100644
--- a/xbmc/interfaces/python/PythonSwig.cpp.template
+++ b/xbmc/interfaces/python/PythonSwig.cpp.template
@@ -682,7 +682,7 @@ void doClassMethodInfo(Node clazz, List initTypeCalls)
 %>
 
     pythonType.tp_base = ${baseclass ? ('&(Ty' + PythonTools.getClassNameAsVariable(baseclass) + '_Type.pythonType)') : "NULL"};
-    pythonType.tp_new = <% Helper.hasHiddenConstructor(clazz) ? print('NULL') : print("${module.@name}_${classNameAsVariable}_New") %>;
+    pythonType.tp_new = <% !Helper.hasDefinedConstructor(clazz) || Helper.hasHiddenConstructor(clazz) ? print('NULL') : print("${module.@name}_${classNameAsVariable}_New") %>;
     pythonType.tp_init = dummy_tp_init;
 
     Ty${classNameAsVariable}_Type.swigType="p.${fullClassName}";<%

From d047cde931b40a507b137b7d62766335b9b13e62 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 24 Nov 2019 10:43:12 +0100
Subject: [PATCH 75/88] [CAddonMediaImporter][WIP] [interfaces/legacy] make
 Settings accessible for all add-ons

---
 xbmc/addons/Addon.cpp                         |   7 +-
 xbmc/addons/Addon.h                           |   2 +-
 xbmc/addons/IAddon.h                          |   2 +-
 xbmc/addons/settings/CMakeLists.txt           |   1 +
 .../settings/IAddonSettingsCallbackExecutor.h |  66 ++
 xbmc/interfaces/legacy/Addon.cpp              |   6 +
 xbmc/interfaces/legacy/Addon.h                |  28 +
 xbmc/interfaces/legacy/CMakeLists.txt         |   2 +
 xbmc/interfaces/legacy/Settings.cpp           | 436 ++++++++++++
 xbmc/interfaces/legacy/Settings.h             | 652 ++++++++++++++++++
 xbmc/interfaces/swig/AddonModuleXbmcaddon.i   |   2 +
 11 files changed, 1200 insertions(+), 4 deletions(-)
 create mode 100644 xbmc/addons/settings/IAddonSettingsCallbackExecutor.h
 create mode 100644 xbmc/interfaces/legacy/Settings.cpp
 create mode 100644 xbmc/interfaces/legacy/Settings.h

diff --git a/xbmc/addons/Addon.cpp b/xbmc/addons/Addon.cpp
index 294c99a76f5d..fc02a4bfaab3 100644
--- a/xbmc/addons/Addon.cpp
+++ b/xbmc/addons/Addon.cpp
@@ -343,13 +343,16 @@ bool CAddon::SettingsToXML(CXBMCTinyXML &doc) const
   return true;
 }
 
-CAddonSettings* CAddon::GetSettings() const
+std::shared_ptr<CAddonSettings> CAddon::GetSettings()
 {
   // initialize addon settings if necessary
   if (m_settings == nullptr)
+  {
     m_settings = std::make_shared<CAddonSettings>(enable_shared_from_this::shared_from_this());
+    LoadSettings(false);
+  }
 
-  return m_settings.get();
+  return m_settings;
 }
 
 std::string CAddon::LibPath() const
diff --git a/xbmc/addons/Addon.h b/xbmc/addons/Addon.h
index c42e54f6f9d6..02d87229c00b 100644
--- a/xbmc/addons/Addon.h
+++ b/xbmc/addons/Addon.h
@@ -208,7 +208,7 @@ class CAddon : public IAddon
   */
   bool GetSettingString(const std::string& key, std::string& value) override;
 
-  CAddonSettings* GetSettings() const override;
+  std::shared_ptr<CAddonSettings> GetSettings() override;
 
   /*! \brief get the required version of a dependency.
    \param dependencyID the addon ID of the dependency.
diff --git a/xbmc/addons/IAddon.h b/xbmc/addons/IAddon.h
index 5a3c14ca1c79..96d6a8f5d59a 100644
--- a/xbmc/addons/IAddon.h
+++ b/xbmc/addons/IAddon.h
@@ -72,7 +72,7 @@ namespace ADDON
     virtual bool GetSettingInt(const std::string& key, int& value) = 0;
     virtual bool GetSettingNumber(const std::string& key, double& value) = 0;
     virtual bool GetSettingString(const std::string& key, std::string& value) = 0;
-    virtual CAddonSettings* GetSettings() const =0;
+    virtual std::shared_ptr<CAddonSettings> GetSettings() = 0;
     virtual const std::vector<DependencyInfo> &GetDependencies() const =0;
     virtual AddonVersion GetDependencyVersion(const std::string &dependencyID) const =0;
     virtual bool MeetsVersion(const AddonVersion& versionMin,
diff --git a/xbmc/addons/settings/CMakeLists.txt b/xbmc/addons/settings/CMakeLists.txt
index eaf10e2b4cbd..d28a26f75783 100644
--- a/xbmc/addons/settings/CMakeLists.txt
+++ b/xbmc/addons/settings/CMakeLists.txt
@@ -4,6 +4,7 @@ set(SOURCES AddonSettings.cpp
 
 set(HEADERS AddonSettings.h
             GUIDialogAddonSettings.h
+            IAddonSettingsCallbackExecutor.h
             SettingUrlEncodedString.h)
 
 core_add_library(addons_settings)
diff --git a/xbmc/addons/settings/IAddonSettingsCallbackExecutor.h b/xbmc/addons/settings/IAddonSettingsCallbackExecutor.h
new file mode 100644
index 000000000000..c627a8621343
--- /dev/null
+++ b/xbmc/addons/settings/IAddonSettingsCallbackExecutor.h
@@ -0,0 +1,66 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "settings/SettingsBase.h"
+#include "settings/lib/SettingDefinitions.h"
+
+#include <memory>
+#include <string>
+
+namespace ADDON
+{
+
+class IAddonSettingsCallbackExecutor
+{
+public:
+  virtual ~IAddonSettingsCallbackExecutor() = default;
+
+  virtual bool LoadSettings(std::shared_ptr<CSettingsBase> settings, void* data) { return false; }
+  virtual bool SaveSettings(std::shared_ptr<CSettingsBase> settings, void* data) { return false; }
+  virtual void SetSettingsLoaded(void* data) {}
+
+  virtual void OnSettingAction(std::shared_ptr<const CSetting> setting,
+                               const std::string& callback,
+                               void* data)
+  {
+  }
+
+  virtual void OnIntegerSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                             const std::string& callback,
+                                             IntegerSettingOptions& list,
+                                             int& current,
+                                             void* data)
+  {
+  }
+  virtual bool SetIntegerSettingOptions(const std::string& settingId,
+                                        const IntegerSettingOptions& list,
+                                        void* data)
+  {
+    return false;
+  }
+
+  virtual void OnStringSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                            const std::string& callback,
+                                            StringSettingOptions& list,
+                                            std::string& current,
+                                            void* data)
+  {
+  }
+  virtual bool SetStringSettingOptions(const std::string& settingId,
+                                       const StringSettingOptions& list,
+                                       void* data)
+  {
+    return false;
+  }
+
+protected:
+  IAddonSettingsCallbackExecutor() = default;
+};
+} // namespace ADDON
diff --git a/xbmc/interfaces/legacy/Addon.cpp b/xbmc/interfaces/legacy/Addon.cpp
index 67eb952ad099..2e2ee048fd3c 100644
--- a/xbmc/interfaces/legacy/Addon.cpp
+++ b/xbmc/interfaces/legacy/Addon.cpp
@@ -12,6 +12,7 @@
 #include "LanguageHook.h"
 #include "ServiceBroker.h"
 #include "addons/AddonManager.h"
+#include "addons/settings/AddonSettings.h"
 #include "addons/settings/GUIDialogAddonSettings.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIWindowManager.h"
@@ -77,6 +78,11 @@ namespace XBMCAddon
       return g_localizeStrings.GetAddonString(pAddon->ID(), id);
     }
 
+    Settings* Addon::getSettings()
+    {
+      return new Settings(pAddon->GetSettings(), pAddon->ID(), nullptr /* TODO(Montellese) */);
+    }
+
     String Addon::getSetting(const char* id)
     {
       return pAddon->GetSetting(id);
diff --git a/xbmc/interfaces/legacy/Addon.h b/xbmc/interfaces/legacy/Addon.h
index 8f497c0418f2..7f810fc4c070 100644
--- a/xbmc/interfaces/legacy/Addon.h
+++ b/xbmc/interfaces/legacy/Addon.h
@@ -11,6 +11,7 @@
 #include "AddonClass.h"
 #include "AddonString.h"
 #include "Exception.h"
+#include "Settings.h"
 #include "addons/IAddon.h"
 
 namespace XBMCAddon
@@ -96,6 +97,33 @@ namespace XBMCAddon
       String getLocalizedString(int id);
 #endif
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcaddon
+      /// @brief \python_func{ xbmcaddon.Addon([id]).getSettings() }
+      ///-----------------------------------------------------------------------
+      /// TODO
+      ///
+      /// @return                        TODO
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      /// @python_v19
+      /// **id** is optional as it will be auto detected for this add-on instance.
+      ///
+      ///
+      /// **Example:**
+      /// ~~~~~~~~~~~~~{.py}
+      /// ..
+      /// settings = self.Addon.getSettings()
+      /// ..
+      /// ~~~~~~~~~~~~~
+      ///
+      getSettings(...);
+#else
+      Settings* getSettings();
+#endif
+
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_xbmcaddon
diff --git a/xbmc/interfaces/legacy/CMakeLists.txt b/xbmc/interfaces/legacy/CMakeLists.txt
index bab88ee85d21..1f2f56f8191d 100644
--- a/xbmc/interfaces/legacy/CMakeLists.txt
+++ b/xbmc/interfaces/legacy/CMakeLists.txt
@@ -21,6 +21,7 @@ set(SOURCES AddonCallback.cpp
             Monitor.cpp
             Player.cpp
             PlayList.cpp
+            Settings.cpp
             String.cpp
             Window.cpp
             WindowDialog.cpp
@@ -57,6 +58,7 @@ set(HEADERS Addon.h
             Player.h
             PlayList.h
             RenderCapture.h
+            Settings.h
             Stat.h
             swighelper.h
             Tuple.h
diff --git a/xbmc/interfaces/legacy/Settings.cpp b/xbmc/interfaces/legacy/Settings.cpp
new file mode 100644
index 000000000000..a9f2ce0ce97a
--- /dev/null
+++ b/xbmc/interfaces/legacy/Settings.cpp
@@ -0,0 +1,436 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "Settings.h"
+
+#include "settings/lib/Setting.h"
+
+#include <algorithm>
+#include <functional>
+
+namespace XBMCAddon
+{
+namespace xbmcaddon
+{
+template<class TSetting>
+bool GetSettingValue(std::shared_ptr<CSettingsBase> settings,
+                     const std::string& key,
+                     typename TSetting::Value& value)
+{
+  if (key.empty() || !settings->IsLoaded())
+    return false;
+
+  auto setting = settings->GetSetting(key);
+  if (setting == nullptr || setting->GetType() != TSetting::Type())
+    return false;
+
+  value = std::static_pointer_cast<TSetting>(setting)->GetValue();
+  return true;
+}
+
+template<class TSetting>
+bool GetSettingValueList(std::shared_ptr<CSettingsBase> settings,
+                         const std::string& key,
+                         std::function<typename TSetting::Value(CVariant)> transform,
+                         std::vector<typename TSetting::Value>& values)
+{
+  if (key.empty() || !settings->IsLoaded())
+    return false;
+
+  auto setting = settings->GetSetting(key);
+  if (setting == nullptr || setting->GetType() != SettingType::List ||
+      std::static_pointer_cast<CSettingList>(setting)->GetElementType() != TSetting::Type())
+    return false;
+
+  const auto variantValues = settings->GetList(key);
+  std::transform(variantValues.begin(), variantValues.end(), std::back_inserter(values), transform);
+  return true;
+}
+
+template<class TSetting>
+bool SetSettingValue(std::shared_ptr<CSettingsBase> settings,
+                     const std::string& key,
+                     typename TSetting::Value value)
+{
+  if (key.empty() || !settings->IsLoaded())
+    return false;
+
+  // try to get the setting
+  auto setting = settings->GetSetting(key);
+  if (setting == nullptr || setting->GetType() != TSetting::Type())
+    return false;
+
+  return std::static_pointer_cast<TSetting>(setting)->SetValue(value);
+}
+
+template<class TSetting>
+bool SetSettingValueList(std::shared_ptr<CSettingsBase> settings,
+                         const std::string& key,
+                         const std::vector<typename TSetting::Value>& values)
+{
+  if (key.empty() || !settings->IsLoaded())
+    return false;
+
+  // try to get the setting
+  auto setting = settings->GetSetting(key);
+  if (setting == nullptr || setting->GetType() != SettingType::List ||
+      std::static_pointer_cast<CSettingList>(setting)->GetElementType() != TSetting::Type())
+    return false;
+
+  std::vector<CVariant> variantValues;
+  std::transform(values.begin(), values.end(), std::back_inserter(variantValues),
+                 [](typename TSetting::Value value) { return CVariant(value); });
+
+  return settings->SetList(key, variantValues);
+}
+
+bool Settings::load()
+{
+  if (m_callbackExecutor != nullptr)
+    return m_callbackExecutor->LoadSettings(settings, m_callbackData);
+
+  return settings->IsLoaded() || settings->Load();
+}
+
+bool Settings::save()
+{
+  if (m_callbackExecutor != nullptr)
+    return m_callbackExecutor->SaveSettings(settings, m_callbackData);
+
+  return settings->Save();
+}
+
+void Settings::setLoaded()
+{
+  if (m_callbackExecutor == nullptr)
+    return;
+
+  m_callbackExecutor->SetSettingsLoaded(m_callbackData);
+}
+
+bool Settings::getBool(const char* id) throw(XBMCAddon::WrongTypeException)
+{
+  bool value = false;
+  if (!GetSettingValue<CSettingBool>(settings, id, value))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"boolean\" for \"%s\"", id);
+
+  return value;
+}
+
+int Settings::getInt(const char* id) throw(XBMCAddon::WrongTypeException)
+{
+  int value = 0;
+  if (!GetSettingValue<CSettingInt>(settings, id, value))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"integer\" for \"%s\"", id);
+
+  return value;
+}
+
+double Settings::getNumber(const char* id) throw(XBMCAddon::WrongTypeException)
+{
+  double value = 0.0;
+  if (!GetSettingValue<CSettingNumber>(settings, id, value))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"number\" for \"%s\"", id);
+
+  return value;
+}
+
+String Settings::getString(const char* id) throw(XBMCAddon::WrongTypeException)
+{
+  std::string value;
+  if (!GetSettingValue<CSettingString>(settings, id, value))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"string\" for \"%s\"", id);
+
+  return value;
+}
+
+std::vector<bool> Settings::getBoolList(const char* id) throw(XBMCAddon::WrongTypeException)
+{
+  const auto transform = [](CVariant value) { return value.asBoolean(); };
+  std::vector<bool> values;
+  if (!GetSettingValueList<CSettingBool>(settings, id, transform, values))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"list[boolean]\" for \"%s\"", id);
+
+  return values;
+}
+
+std::vector<int> Settings::getIntList(const char* id) throw(XBMCAddon::WrongTypeException)
+{
+  const auto transform = [](CVariant value) { return value.asInteger32(); };
+  std::vector<int> values;
+  if (!GetSettingValueList<CSettingInt>(settings, id, transform, values))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"list[integer]\" for \"%s\"", id);
+
+  return values;
+}
+
+std::vector<double> Settings::getNumberList(const char* id) throw(XBMCAddon::WrongTypeException)
+{
+  const auto transform = [](CVariant value) { return value.asDouble(); };
+  std::vector<double> values;
+  if (!GetSettingValueList<CSettingNumber>(settings, id, transform, values))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"list[number]\" for \"%s\"", id);
+
+  return values;
+}
+
+std::vector<String> Settings::getStringList(const char* id) throw(XBMCAddon::WrongTypeException)
+{
+  const auto transform = [](CVariant value) { return value.asString(); };
+  std::vector<std::string> values;
+  if (!GetSettingValueList<CSettingString>(settings, id, transform, values))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"list[string]\" for \"%s\"", id);
+
+  return values;
+}
+
+void Settings::setBool(const char* id, bool value) throw(XBMCAddon::WrongTypeException)
+{
+  if (!SetSettingValue<CSettingBool>(settings, id, value))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"boolean\" for \"%s\"", id);
+  settings->Save();
+}
+
+void Settings::setInt(const char* id, int value) throw(XBMCAddon::WrongTypeException)
+{
+  if (!SetSettingValue<CSettingInt>(settings, id, value))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"integer\" for \"%s\"", id);
+  settings->Save();
+}
+
+void Settings::setNumber(const char* id, double value) throw(XBMCAddon::WrongTypeException)
+{
+  if (!SetSettingValue<CSettingNumber>(settings, id, value))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"number\" for \"%s\"", id);
+  settings->Save();
+}
+
+void Settings::setString(const char* id, const String& value) throw(XBMCAddon::WrongTypeException)
+{
+  if (!SetSettingValue<CSettingString>(settings, id, value))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"string\" for \"%s\"", id);
+  settings->Save();
+}
+
+void Settings::setBoolList(const char* id,
+                           const std::vector<bool>& values) throw(XBMCAddon::WrongTypeException)
+{
+  if (!SetSettingValueList<CSettingBool>(settings, id, values))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"list[boolean]\" for \"%s\"", id);
+  settings->Save();
+}
+
+void Settings::setIntList(const char* id,
+                          const std::vector<int>& values) throw(XBMCAddon::WrongTypeException)
+{
+  if (!SetSettingValueList<CSettingInt>(settings, id, values))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"list[integer]\" for \"%s\"", id);
+  settings->Save();
+}
+
+void Settings::setNumberList(const char* id,
+                             const std::vector<double>& values) throw(XBMCAddon::WrongTypeException)
+{
+  if (!SetSettingValueList<CSettingNumber>(settings, id, values))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"list[number]\" for \"%s\"", id);
+  settings->Save();
+}
+
+void Settings::setStringList(const char* id,
+                             const std::vector<String>& values) throw(XBMCAddon::WrongTypeException)
+{
+  if (!SetSettingValueList<CSettingString>(settings, id, values))
+    throw XBMCAddon::WrongTypeException("Invalid setting type \"list[string]\" for \"%s\"", id);
+  settings->Save();
+}
+
+bool Settings::registerActionCallback(const String& settingId, const String& callback) throw(
+    SettingCallbacksNotSupportedException)
+{
+  if (m_callbackExecutor == nullptr)
+    throw SettingCallbacksNotSupportedException("Add-on %s does not support setting callbacks",
+                                                m_addonId.c_str());
+
+  if (settingId.empty() || !settings->IsLoaded())
+    return false;
+
+  auto setting = settings->GetSetting(settingId);
+  if (setting == nullptr || setting->GetType() != SettingType::Action)
+    return false;
+
+  settings->RegisterCallback(this, {settingId});
+  m_actionCallbacks[settingId] = callback;
+  return true;
+}
+
+bool Settings::registerOptionsFillerCallback(const String& settingId, const String& callback) throw(
+    SettingCallbacksNotSupportedException)
+{
+  if (m_callbackExecutor == nullptr)
+    throw SettingCallbacksNotSupportedException("Add-on %s does not support setting callbacks",
+                                                m_addonId.c_str());
+
+  if (settingId.empty() || !settings->IsLoaded())
+    return false;
+
+  auto setting = GetSetting(settingId);
+  if (setting == nullptr)
+    return false;
+
+  // make sure the setting is either an integer or a string or a list of one of the two
+  const SettingType settingType = setting->GetType();
+  if (settingType != SettingType::Integer && settingType != SettingType::String)
+    return false;
+
+  // set setting options filler and register our wrapper filler
+  // ATTENTION: we must use CSetting::GetId() to get the settings proper
+  // identifier because GetSetting() also handles CSettingList settings
+  m_optionsFillerCallbacks[setting->GetId()] = callback;
+  switch (settingType)
+  {
+    case SettingType::Integer:
+      std::static_pointer_cast<CSettingInt>(setting)->SetOptionsFiller(IntegerSettingOptionsFiller,
+                                                                       this);
+      break;
+
+    case SettingType::String:
+      std::static_pointer_cast<CSettingString>(setting)->SetOptionsFiller(
+          StringSettingOptionsFiller, this);
+      break;
+
+    default:
+      return false;
+  }
+
+  return true;
+}
+
+bool Settings::setIntegerOptions(
+    const String& settingId,
+    const std::vector<Tuple<String, int>>& options) throw(SettingCallbacksNotSupportedException)
+{
+  if (m_callbackExecutor == nullptr)
+    throw SettingCallbacksNotSupportedException("Add-on %s does not support setting callbacks",
+                                                m_addonId.c_str());
+
+  if (settingId.empty() || !settings->IsLoaded())
+    return false;
+
+  auto setting = GetSetting(settingId);
+  if (setting == nullptr)
+    return false;
+
+  // make sure the setting is an integer or a list of integers
+  if (setting->GetType() != SettingType::Integer)
+    return false;
+
+  // convert options
+  IntegerSettingOptions integerOptions;
+  for (const auto& option : options)
+    integerOptions.emplace_back(option.first(), option.second());
+
+  return m_callbackExecutor->SetIntegerSettingOptions(settingId, integerOptions, m_callbackData);
+}
+
+bool Settings::setStringOptions(
+    const String& settingId,
+    const std::vector<Tuple<String, String>>& options) throw(SettingCallbacksNotSupportedException)
+{
+  if (m_callbackExecutor == nullptr)
+    throw SettingCallbacksNotSupportedException("Add-on %s does not support setting callbacks",
+                                                m_addonId.c_str());
+
+  if (settingId.empty() || !settings->IsLoaded())
+    return false;
+
+  auto setting = GetSetting(settingId);
+  if (setting == nullptr)
+    return false;
+
+  // make sure the setting is a string or a list of strings
+  if (setting->GetType() != SettingType::String)
+    return false;
+
+  // convert options
+  StringSettingOptions stringOptions;
+  for (const auto& option : options)
+    stringOptions.emplace_back(option.first(), option.second());
+
+  return m_callbackExecutor->SetStringSettingOptions(settingId, stringOptions, m_callbackData);
+}
+
+#ifndef SWIG
+void Settings::OnSettingAction(std::shared_ptr<const CSetting> setting)
+{
+  if (m_callbackExecutor == nullptr || setting == nullptr)
+    return;
+
+  const auto& callback = m_actionCallbacks.find(setting->GetId());
+  if (callback == m_actionCallbacks.end())
+    return;
+
+  m_callbackExecutor->OnSettingAction(setting, callback->second, m_callbackData);
+}
+
+std::shared_ptr<CSetting> Settings::GetSetting(const std::string& settingId) const
+{
+  if (settingId.empty() || !settings->IsLoaded())
+    return nullptr;
+
+  auto setting = settings->GetSetting(settingId);
+  if (setting == nullptr)
+    return nullptr;
+
+  if (setting->GetType() == SettingType::List)
+    setting = std::static_pointer_cast<CSettingList>(setting)->GetDefinition();
+
+  return setting;
+}
+
+void Settings::IntegerSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                           IntegerSettingOptions& list,
+                                           int& current,
+                                           void* data)
+{
+  if (setting == nullptr || data == nullptr)
+    return;
+
+  auto settings = static_cast<Settings*>(data);
+  if (settings->m_callbackExecutor == nullptr)
+    return;
+
+  const auto& callback = settings->m_optionsFillerCallbacks.find(setting->GetId());
+  if (callback == settings->m_optionsFillerCallbacks.end())
+    return;
+
+  settings->m_callbackExecutor->OnIntegerSettingOptionsFiller(setting, callback->second, list,
+                                                              current, settings->m_callbackData);
+}
+
+void Settings::StringSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                          StringSettingOptions& list,
+                                          std::string& current,
+                                          void* data)
+{
+  if (setting == nullptr || data == nullptr)
+    return;
+
+  auto settings = static_cast<Settings*>(data);
+  if (settings->m_callbackExecutor == nullptr)
+    return;
+
+  const auto& callback = settings->m_optionsFillerCallbacks.find(setting->GetId());
+  if (callback == settings->m_optionsFillerCallbacks.end())
+    return;
+
+  settings->m_callbackExecutor->OnStringSettingOptionsFiller(setting, callback->second, list,
+                                                             current, settings->m_callbackData);
+}
+#endif
+} // namespace xbmcaddon
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/legacy/Settings.h b/xbmc/interfaces/legacy/Settings.h
new file mode 100644
index 000000000000..0241b9e367ea
--- /dev/null
+++ b/xbmc/interfaces/legacy/Settings.h
@@ -0,0 +1,652 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "addons/IAddon.h"
+#include "addons/settings/IAddonSettingsCallbackExecutor.h"
+#include "commons/Exception.h"
+#include "interfaces/legacy/AddonClass.h"
+#include "interfaces/legacy/AddonString.h"
+#include "interfaces/legacy/Exception.h"
+#include "interfaces/legacy/Tuple.h"
+#include "settings/SettingsBase.h"
+#include "settings/lib/SettingDefinitions.h"
+
+#include <vector>
+
+namespace XBMCAddon
+{
+namespace xbmcaddon
+{
+XBMCCOMMONS_STANDARD_EXCEPTION(SettingCallbacksNotSupportedException);
+
+//
+/// \addtogroup python_xbmcaddon
+/// @{
+/// @brief **Add-on settings**
+///
+/// This wrapper provides access to the settings specific to an add-on.
+/// It supports reading and writing specific setting values.
+///
+/// \python_class{ Settings() }
+///
+///
+///-----------------------------------------------------------------------
+/// @python_v19
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ...
+/// settings = xbmc.Addon('id').getSettings()
+/// ...
+/// ~~~~~~~~~~~~~
+class Settings : public AddonClass
+#ifndef SWIG
+  ,
+                 protected ISettingCallback
+#endif
+{
+public:
+#if !defined SWIG && !defined DOXYGEN_SHOULD_SKIP_THIS
+  std::shared_ptr<CSettingsBase> settings;
+#endif
+
+#ifndef SWIG
+  inline Settings(std::shared_ptr<CSettingsBase> settings,
+                  const std::string& addonId,
+                  ADDON::IAddonSettingsCallbackExecutor* callbackExecutor = nullptr,
+                  void* callbackData = nullptr)
+    : settings(settings),
+      m_addonId(addonId),
+      m_callbackExecutor(callbackExecutor),
+      m_callbackData(callbackData)
+  {
+  }
+#endif
+
+  virtual ~Settings() {}
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// TODO(Montellese)
+  ///
+  load(...);
+#else
+  bool load();
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// TODO(Montellese)
+  ///
+  save(...);
+#else
+  bool save();
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// TODO(Montellese)
+  ///
+  setLoaded(...);
+#else
+  void setLoaded();
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ getBool(id) }
+  ///-----------------------------------------------------------------------
+  /// Returns the value of a setting as a boolean.
+  ///
+  /// @param id                      string - id of the setting that the module
+  ///                                needs to access.
+  /// @return                        Setting as a boolean
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// enabled = settings.getBool('enabled')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  getBool(...);
+#else
+  bool getBool(const char* id) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ getInt(id) }
+  ///-----------------------------------------------------------------------
+  /// Returns the value of a setting as an integer.
+  ///
+  /// @param id                      string - id of the setting that the module
+  ///                                needs to access.
+  /// @return                        Setting as an integer
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// max = settings.getInt('max')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  getInt(...);
+#else
+  int getInt(const char* id) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ getNumber(id) }
+  ///-----------------------------------------------------------------------
+  /// Returns the value of a setting as a floating point number.
+  ///
+  /// @param id                      string - id of the setting that the module
+  ///                                needs to access.
+  /// @return                        Setting as a floating point number
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// max = settings.getNumber('max')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  getNumber(...);
+#else
+  double getNumber(const char* id) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ getString(id) }
+  ///-----------------------------------------------------------------------
+  /// Returns the value of a setting as a unicode string.
+  ///
+  /// @param id                      string - id of the setting that the module
+  ///                                needs to access.
+  /// @return                        Setting as a unicode string
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// apikey = settings.getString('apikey')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  getString(...);
+#else
+  String getString(const char* id) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ getBoolList(id) }
+  ///-----------------------------------------------------------------------
+  /// Returns the value of a setting as a list of booleans.
+  ///
+  /// @param id                      string - id of the setting that the module
+  ///                                needs to access.
+  /// @return                        Setting as a list of booleans
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// enabled = settings.getBoolList('enabled')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  getBoolList(...);
+#else
+  std::vector<bool> getBoolList(const char* id) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ getIntList(id) }
+  ///-----------------------------------------------------------------------
+  /// Returns the value of a setting as a list of integers.
+  ///
+  /// @param id                      string - id of the setting that the module
+  ///                                needs to access.
+  /// @return                        Setting as a list of integers
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// ids = settings.getIntList('ids')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  getIntList(...);
+#else
+  std::vector<int> getIntList(const char* id) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ getNumberList(id) }
+  ///-----------------------------------------------------------------------
+  /// Returns the value of a setting as a list of floating point numbers.
+  ///
+  /// @param id                      string - id of the setting that the module
+  ///                                needs to access.
+  /// @return                        Setting as a list of floating point numbers
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// max = settings.getNumberList('max')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  getNumberList(...);
+#else
+  std::vector<double> getNumberList(const char* id) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ getStringList(id) }
+  ///-----------------------------------------------------------------------
+  /// Returns the value of a setting as a list of unicode strings.
+  ///
+  /// @param id                      string - id of the setting that the module
+  ///                                needs to access.
+  /// @return                        Setting as a list of unicode strings
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// views = settings.getStringList('views')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  getStringList(...);
+#else
+  std::vector<String> getStringList(const char* id) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ setBool(id, value) }
+  ///-----------------------------------------------------------------------
+  /// Sets the value of a setting.
+  ///
+  /// @param id                  string - id of the setting that the module needs to access.
+  /// @param value               boolean - value of the setting.
+  /// @return                    True if the value of the setting was set, false otherwise
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.setBool(id='enabled', value=True)
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  setBool(...);
+#else
+  void setBool(const char* id, bool value) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ setInt(id, value) }
+  ///-----------------------------------------------------------------------
+  /// Sets the value of a setting.
+  ///
+  /// @param id                  string - id of the setting that the module needs to access.
+  /// @param value               integer - value of the setting.
+  /// @return                    True if the value of the setting was set, false otherwise
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.setInt(id='max', value=5)
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  setInt(...);
+#else
+  void setInt(const char* id, int value) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ setNumber(id, value) }
+  ///-----------------------------------------------------------------------
+  /// Sets the value of a setting.
+  ///
+  /// @param id                  string - id of the setting that the module needs to access.
+  /// @param value               float - value of the setting.
+  /// @return                    True if the value of the setting was set, false otherwise
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.setNumber(id='max', value=5.5)
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  setNumber(...);
+#else
+  void setNumber(const char* id, double value) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ setString(id, value) }
+  ///-----------------------------------------------------------------------
+  /// Sets the value of a setting.
+  ///
+  /// @param id                  string - id of the setting that the module needs to access.
+  /// @param value               string or unicode - value of the setting.
+  /// @return                    True if the value of the setting was set, false otherwise
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.setString(id='username', value='teamkodi')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  setString(...);
+#else
+  void setString(const char* id, const String& value) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ setBoolList(id, values) }
+  ///-----------------------------------------------------------------------
+  /// Sets the boolean values of a list setting.
+  ///
+  /// @param id                  string - id of the setting that the module needs to access.
+  /// @param values              list of boolean - values of the setting.
+  /// @return                    True if the values of the setting were set, false otherwise
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.setBoolList(id='enabled', values=[ True, False ])
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  setBoolList(...);
+#else
+  void setBoolList(const char* id,
+                   const std::vector<bool>& values) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ setIntList(id, value) }
+  ///-----------------------------------------------------------------------
+  /// Sets the integer values of a list setting.
+  ///
+  /// @param id                  string - id of the setting that the module needs to access.
+  /// @param values              list of int - values of the setting.
+  /// @return                    True if the values of the setting were set, false otherwise
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.setIntList(id='max', values=[ 5, 23 ])
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  setIntList(...);
+#else
+  void setIntList(const char* id,
+                  const std::vector<int>& values) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ setNumberList(id, value) }
+  ///-----------------------------------------------------------------------
+  /// Sets the floating point values of a list setting.
+  ///
+  /// @param id                  string - id of the setting that the module needs to access.
+  /// @param values              list of float - values of the setting.
+  /// @return                    True if the values of the setting were set, false otherwise
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.setNumberList(id='max', values=[ 5.5, 5.8 ])
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  setNumberList(...);
+#else
+  void setNumberList(const char* id,
+                     const std::vector<double>& values) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ setStringList(id, value) }
+  ///-----------------------------------------------------------------------
+  /// Sets the string values of a list setting.
+  ///
+  /// @param id                  string - id of the setting that the module needs to access.
+  /// @param values              list of string or unicode - values of the setting.
+  /// @return                    True if the values of the setting were set, false otherwise
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.setStringList(id='username', values=[ 'team', 'kodi' ])
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  setStringList(...);
+#else
+  void setStringList(const char* id,
+                     const std::vector<String>& values) throw(XBMCAddon::WrongTypeException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcaddon
+  /// @brief \python_func{ registerActionCallback(settingId, callback) }
+  ///-----------------------------------------------------------------------
+  /// TODO
+  ///
+  /// @param settingId           string - TODO.
+  /// @param callback            string - TODO.
+  /// @return                    TODO
+  ///
+  ///
+  /// @note You can use the above as keywords for arguments.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ..
+  /// settings.registerActionCallback('foo', 'onSettingAction')
+  /// ..
+  /// ~~~~~~~~~~~~~
+  ///
+  registerActionCallback(...);
+#else
+  bool registerActionCallback(const String& settingId,
+                              const String& callback) throw(SettingCallbacksNotSupportedException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// TODO(Montellese)
+  ///
+  registerOptionsFillerCallback(...);
+#else
+  bool registerOptionsFillerCallback(const String& settingId, const String& callback) throw(
+      SettingCallbacksNotSupportedException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// TODO(Montellese)
+  ///
+  setIntegerOptions(...);
+#else
+  bool setIntegerOptions(
+      const String& settingId,
+      const std::vector<Tuple<String, int>>& options) throw(SettingCallbacksNotSupportedException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// TODO(Montellese)
+  ///
+  setStringOptions(...);
+#else
+  bool setStringOptions(const String& settingId,
+                        const std::vector<Tuple<String, String>>&
+                            options) throw(SettingCallbacksNotSupportedException);
+#endif
+
+#ifndef SWIG
+protected:
+  void OnSettingAction(std::shared_ptr<const CSetting> setting) override;
+
+private:
+  using CallbackMap = std::map<std::string, std::string>;
+
+  std::shared_ptr<CSetting> GetSetting(const std::string& settingId) const;
+
+  static void IntegerSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                          IntegerSettingOptions& list,
+                                          int& current,
+                                          void* data);
+  static void StringSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                         StringSettingOptions& list,
+                                         std::string& current,
+                                         void* data);
+
+  const std::string m_addonId;
+
+  ADDON::IAddonSettingsCallbackExecutor* m_callbackExecutor;
+  void* m_callbackData;
+  CallbackMap m_actionCallbacks;
+  CallbackMap m_optionsFillerCallbacks;
+#endif
+};
+} // namespace xbmcaddon
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/swig/AddonModuleXbmcaddon.i b/xbmc/interfaces/swig/AddonModuleXbmcaddon.i
index 8a084686ab8c..6c00a1caa2f5 100644
--- a/xbmc/interfaces/swig/AddonModuleXbmcaddon.i
+++ b/xbmc/interfaces/swig/AddonModuleXbmcaddon.i
@@ -14,6 +14,7 @@
 #endif
 
 #include "interfaces/legacy/Addon.h"
+#include "interfaces/legacy/Settings.h"
 
 using namespace XBMCAddon;
 using namespace xbmcaddon;
@@ -32,4 +33,5 @@ using namespace xbmcaddon;
 %include "interfaces/legacy/AddonString.h"
 
 %include "interfaces/legacy/Addon.h"
+%include "interfaces/legacy/Settings.h"
 

From 70b58ddadb5a6062d21378ae920b47754d0d68d7 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 13 Oct 2019 00:34:50 +0200
Subject: [PATCH 76/88] [CAddonMediaImporter][addons] add CMediaImporter and
 CAddonMediaImporter to import media items from add-ons

---
 .../resources/strings.po                      |    7 +-
 addons/xbmc.python/addon.xml                  |    1 +
 addons/xbmc.python/mediaimporter.xsd          |   51 +
 xbmc/addons/AddonBuilder.cpp                  |    3 +
 xbmc/addons/CMakeLists.txt                    |    2 +
 xbmc/addons/MediaImporter.cpp                 |  408 ++++++
 xbmc/addons/MediaImporter.h                   |  137 ++
 xbmc/addons/addoninfo/AddonInfo.cpp           |    1 +
 xbmc/addons/addoninfo/AddonType.h             |    1 +
 .../import/importers/AddonMediaImporter.cpp   | 1123 +++++++++++++++++
 .../import/importers/AddonMediaImporter.h     |  296 +++++
 .../importers/AddonMediaImporterExecutor.cpp  |  217 ++++
 .../importers/AddonMediaImporterExecutor.h    |  121 ++
 xbmc/media/import/importers/CMakeLists.txt    |    8 +-
 14 files changed, 2373 insertions(+), 3 deletions(-)
 create mode 100644 addons/xbmc.python/mediaimporter.xsd
 create mode 100644 xbmc/addons/MediaImporter.cpp
 create mode 100644 xbmc/addons/MediaImporter.h
 create mode 100644 xbmc/media/import/importers/AddonMediaImporter.cpp
 create mode 100644 xbmc/media/import/importers/AddonMediaImporter.h
 create mode 100644 xbmc/media/import/importers/AddonMediaImporterExecutor.cpp
 create mode 100644 xbmc/media/import/importers/AddonMediaImporterExecutor.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 44707c71ba09..cb0c51777f71 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -22014,7 +22014,12 @@ msgctxt "#39027"
 msgid "Sortname"
 msgstr ""
 
-#empty strings from id 39028 to 39029
+#empty string with id 39028
+
+#: /xbmc/addons/Addon.cpp
+msgctxt "#39029"
+msgid "Media importer"
+msgstr ""
 
 #. Media source, a filter and smart playlist rule option
 #: xbmc/dialogs/GUIDialogMediaFilter.cpp
diff --git a/addons/xbmc.python/addon.xml b/addons/xbmc.python/addon.xml
index 72d2955a4d5a..93930a20a564 100644
--- a/addons/xbmc.python/addon.xml
+++ b/addons/xbmc.python/addon.xml
@@ -12,4 +12,5 @@
   <extension-point id="screensaver" schema="script.xsd"/>
   <extension-point id="plugin" schema="pluginsource.xsd"/>
   <extension-point id="context.item" schema="contextitem.xsd"/>
+  <extension-point id="mediaimporter" schema="mediaimporter.xsd"/>
 </addon>
diff --git a/addons/xbmc.python/mediaimporter.xsd b/addons/xbmc.python/mediaimporter.xsd
new file mode 100644
index 000000000000..36144d9de282
--- /dev/null
+++ b/addons/xbmc.python/mediaimporter.xsd
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE schema PUBLIC "-//W3C//DTD XMLSCHEMA 200102//EN" "http://www.w3.org/2001/XMLSchema.dtd">
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
+  <xs:element name="extension">
+    <xs:complexType>
+      <xs:all>
+        <xs:element name="canlookupprovider" minOccurs="0" maxOccurs="1">
+          <xs:complexType>
+            <xs:simpleContent>
+              <xs:extension base="xs:boolean">
+                <xs:attribute name="protocol" type="xs:string" use="required"/>
+              </xs:extension>
+            </xs:simpleContent>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name="automaticallyaddasprovider" minOccurs="0" maxOccurs="1">
+          <xs:complexType>
+            <xs:all>
+              <xs:element name="supportedmediatypes" type="mediaTypes" minOccurs="1" maxOccurs="1"/>
+          </xs:all>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name="providersettings" type="settings" minOccurs="0" maxOccurs="1"/>
+        <xs:element name="importsettings" type="settings" minOccurs="0" maxOccurs="1"/>
+      </xs:all>
+      <xs:attribute name="point" type="xs:string" use="required"/>
+      <xs:attribute name="library" type="xs:string" use="required"/>
+      <xs:attribute name="discovery" type="xs:string"/>
+      <xs:attribute name="observer" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:simpleType name="mediaType">
+    <xs:restriction base="xs:string">
+      <xs:enumeration value="movies"/>
+      <xs:enumeration value="musicvideos"/>
+      <xs:enumeration value="tvshows"/>
+      <xs:enumeration value="seasons"/>
+      <xs:enumeration value="episodes"/>
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:simpleType name="mediaTypes">
+    <xs:list itemType="mediaType"/>
+  </xs:simpleType>
+  <xs:complexType name="settings">
+    <xs:simpleContent>
+      <xs:extension base="xs:string">
+        <xs:attribute name="prepare" type="xs:boolean"/>
+      </xs:extension>
+    </xs:simpleContent>
+  </xs:complexType>
+</xs:schema>
diff --git a/xbmc/addons/AddonBuilder.cpp b/xbmc/addons/AddonBuilder.cpp
index 39dd3c9eed8e..83480caa3534 100644
--- a/xbmc/addons/AddonBuilder.cpp
+++ b/xbmc/addons/AddonBuilder.cpp
@@ -14,6 +14,7 @@
 #include "addons/GameResource.h"
 #include "addons/ImageResource.h"
 #include "addons/LanguageResource.h"
+#include "addons/MediaImporter.h"
 #include "addons/PluginSource.h"
 #include "addons/Repository.h"
 #include "addons/Scraper.h"
@@ -110,6 +111,8 @@ AddonPtr CAddonBuilder::Generate(const AddonInfoPtr& info, TYPE type)
     return std::make_shared<CContextMenuAddon>(info);
   case ADDON_GAME_CONTROLLER:
     return std::make_shared<GAME::CController>(info);
+    case ADDON_MEDIAIMPORTER:
+      return std::make_shared<CMediaImporter>(info);
   default:
     break;
   }
diff --git a/xbmc/addons/CMakeLists.txt b/xbmc/addons/CMakeLists.txt
index 5d73b2c54f4b..0e6a7ccce3b0 100644
--- a/xbmc/addons/CMakeLists.txt
+++ b/xbmc/addons/CMakeLists.txt
@@ -20,6 +20,7 @@ set(SOURCES Addon.cpp
             ImageDecoder.cpp
             ImageResource.cpp
             LanguageResource.cpp
+            MediaImporter.cpp
             PluginSource.cpp
             Repository.cpp
             RepositoryUpdater.cpp
@@ -57,6 +58,7 @@ set(HEADERS Addon.h
             ImageDecoder.h
             ImageResource.h
             LanguageResource.h
+            MediaImporter.h
             PluginSource.h
             Repository.h
             RepositoryUpdater.h
diff --git a/xbmc/addons/MediaImporter.cpp b/xbmc/addons/MediaImporter.cpp
new file mode 100644
index 000000000000..15fdd77891d5
--- /dev/null
+++ b/xbmc/addons/MediaImporter.cpp
@@ -0,0 +1,408 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImporter.h"
+
+#include "AddonManager.h"
+#include "ServiceBroker.h"
+#include "interfaces/generic/ScriptInvocationManager.h"
+#include "media/import/MediaImportManager.h"
+#include "media/import/importers/AddonMediaImporter.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/log.h"
+
+namespace ADDON
+{
+
+CMediaImporter::CMediaImporter(const AddonInfoPtr& addonInfo)
+  : CAddon(addonInfo, ADDON_MEDIAIMPORTER)
+{
+  const auto& addonTypeInfo = addonInfo->Type(ADDON_MEDIAIMPORTER);
+  m_discoveryService = addonTypeInfo->GetValue("@discovery").asString();
+  m_observerService = addonTypeInfo->GetValue("@observer").asString();
+
+  m_canLookupProvider = addonTypeInfo->GetValue("canlookupprovider").asBoolean();
+  m_providerLookupProtocol = addonTypeInfo->GetValue("canlookupprovider@protocol").asString();
+
+  const auto automaticallyAddAsProvider = addonTypeInfo->GetElement("automaticallyaddasprovider");
+  if (automaticallyAddAsProvider != nullptr)
+    SetSupportedMediaTypes(automaticallyAddAsProvider->GetValue("supportedmediatypes").asString());
+
+  ParseSettingsElement(addonTypeInfo, "providersettings", m_prepareProviderSettings,
+                       m_providerSettingsPath);
+  ParseSettingsElement(addonTypeInfo, "importsettings", m_prepareImportSettings,
+                       m_importSettingsPath);
+}
+
+std::string CMediaImporter::ProviderLookupProtocol() const
+{
+  if (!m_providerLookupProtocol.empty())
+    return m_providerLookupProtocol;
+
+  return Name();
+}
+
+std::string CMediaImporter::DiscoveryServicePath() const
+{
+  if (!HasDiscoveryService())
+    return "";
+
+  return URIUtils::AddFileToFolder(m_addonInfo->Path(), m_discoveryService);
+}
+
+std::string CMediaImporter::ObserverServicePath() const
+{
+  if (!HasObserverService())
+    return "";
+
+  return URIUtils::AddFileToFolder(m_addonInfo->Path(), m_observerService);
+}
+
+bool CMediaImporter::AutomaticallyAddAsProvider() const
+{
+  return !m_supportedMediaTypes.empty();
+}
+
+bool CMediaImporter::PrepareProviderSettings() const
+{
+  return m_prepareProviderSettings && !m_providerSettingsPath.empty();
+}
+
+std::string CMediaImporter::ProviderSettingsPath() const
+{
+  if (m_providerSettingsPath.empty())
+    return "";
+
+  return URIUtils::AddFileToFolder(m_addonInfo->Path(), "resources", m_providerSettingsPath);
+}
+
+bool CMediaImporter::PrepareImportSettings() const
+{
+  return m_prepareImportSettings && !m_importSettingsPath.empty();
+}
+
+std::string CMediaImporter::ImportSettingsPath() const
+{
+  if (m_importSettingsPath.empty())
+    return "";
+
+  return URIUtils::AddFileToFolder(m_addonInfo->Path(), "resources", m_importSettingsPath);
+}
+
+void CMediaImporter::SetSupportedMediaTypes(const std::string& supportedMediaTypes)
+{
+  const auto mediaTypes = StringUtils::Split(supportedMediaTypes, " ");
+  for (auto strMediaType : mediaTypes)
+  {
+    StringUtils::Trim(strMediaType);
+    if (strMediaType.empty())
+      continue;
+
+    auto mediaType = CMediaTypes::FromString(strMediaType);
+    if (mediaType != MediaTypeNone)
+      m_supportedMediaTypes.insert(std::move(mediaType));
+  }
+}
+
+void CMediaImporter::ParseSettingsElement(const CAddonExtensions* parent,
+                                          const std::string& id,
+                                          bool& prepareSettings,
+                                          std::string& settingsPath)
+{
+  prepareSettings = false;
+  if (parent == nullptr)
+    return;
+
+  prepareSettings = true;
+  settingsPath = parent->GetValue(id).asString();
+  if (!settingsPath.empty())
+  {
+    const auto prepareSettingsValue = parent->GetValue(id + "@prepare");
+    if (!prepareSettingsValue.empty())
+      prepareSettings = prepareSettingsValue.asBoolean();
+  }
+}
+
+CMediaImportAddonManager::CMediaImportAddonManager(CAddonMgr& addonMgr)
+  : m_addonMgr(addonMgr),
+    m_logger(CServiceBroker::GetLogging().GetLogger("CMediaImportAddonManager"))
+{
+}
+
+CMediaImportAddonManager::~CMediaImportAddonManager()
+{
+  Stop();
+}
+
+void CMediaImportAddonManager::Start()
+{
+  if (m_started)
+    return;
+
+  m_addonMgr.Events().Subscribe(this, &CMediaImportAddonManager::OnEvent);
+  m_started = true;
+
+  VECADDONS addons;
+  if (m_addonMgr.GetAddons(addons, ADDON_MEDIAIMPORTER))
+  {
+    for (const auto& addon : addons)
+      Register(addon);
+  }
+}
+
+bool CMediaImportAddonManager::StartDiscovery(const std::string& addonId)
+{
+  if (!m_started)
+    return false;
+
+  const auto addon = GetAddon(addonId);
+  return StartDiscovery(addon);
+}
+
+bool CMediaImportAddonManager::StartDiscovery(const AddonPtr& addon)
+{
+  if (!m_started || addon == nullptr)
+    return false;
+
+  CSingleLock lock(m_criticalSection);
+  auto service = m_services.find(addon->ID());
+  if (service == m_services.end())
+    service = m_services.emplace(addon->ID(), ServiceHandlers{}).first;
+  else if (service->second.discovery >= 0)
+  {
+    m_logger->debug("discovery service for {:s} already started.", addon->ID());
+    return true;
+  }
+
+  auto mediaImporter = std::dynamic_pointer_cast<CMediaImporter>(addon);
+  if (mediaImporter == nullptr || !mediaImporter->HasDiscoveryService())
+    return false;
+
+  if (!StringUtils::EndsWith(mediaImporter->DiscoveryServicePath(), ".py"))
+    return false;
+
+  m_logger->debug("starting discovery service for {:s}", addon->ID());
+  auto handle = CScriptInvocationManager::GetInstance().ExecuteAsync(
+      mediaImporter->DiscoveryServicePath(), addon);
+  if (handle < 0)
+  {
+    m_logger->debug("discovery service for {:s} failed to start", addon->ID());
+    return false;
+  }
+  service->second.discovery = handle;
+
+  return true;
+}
+
+bool CMediaImportAddonManager::StartObserver(const std::string& addonId)
+{
+  if (!m_started)
+    return false;
+
+  const auto addon = GetAddon(addonId);
+  return StartObserver(addon);
+}
+
+bool CMediaImportAddonManager::StartObserver(const AddonPtr& addon)
+{
+  if (!m_started || addon == nullptr)
+    return false;
+
+  CSingleLock lock(m_criticalSection);
+  auto service = m_services.find(addon->ID());
+  if (service == m_services.end())
+    service = m_services.emplace(addon->ID(), ServiceHandlers{}).first;
+  else if (service->second.observer >= 0)
+  {
+    m_logger->debug("observer service for {:s} already started.", addon->ID());
+    return true;
+  }
+
+  auto mediaImporter = std::dynamic_pointer_cast<CMediaImporter>(addon);
+  if (mediaImporter == nullptr || !mediaImporter->HasObserverService())
+    return false;
+
+  if (!StringUtils::EndsWith(mediaImporter->ObserverServicePath(), ".py"))
+    return false;
+
+  m_logger->debug("starting observer service for {:s}", addon->ID());
+  auto handle = CScriptInvocationManager::GetInstance().ExecuteAsync(
+      mediaImporter->ObserverServicePath(), addon);
+  if (handle < 0)
+  {
+    m_logger->error("observer service for {:s} failed to start", addon->ID());
+    return false;
+  }
+  service->second.observer = handle;
+
+  return true;
+}
+
+void CMediaImportAddonManager::Stop()
+{
+  if (!m_started)
+    return;
+
+  m_addonMgr.Events().Unsubscribe(this);
+
+  VECADDONS addons;
+  if (m_addonMgr.GetAddons(addons, ADDON_MEDIAIMPORTER))
+  {
+    for (const auto& addon : addons)
+      Unregister(addon);
+  }
+
+  m_started = false;
+}
+
+bool CMediaImportAddonManager::StopDiscovery(const std::string& addonId)
+{
+  if (!m_started)
+    return false;
+
+  const auto addon = GetAddon(addonId);
+  return StopDiscovery(addon);
+}
+
+bool CMediaImportAddonManager::StopDiscovery(const AddonPtr& addon)
+{
+  if (!m_started || addon == nullptr)
+    return false;
+
+  CSingleLock lock(m_criticalSection);
+  auto it = m_services.find(addon->ID());
+  if (it == m_services.end())
+    return false;
+
+  const auto result = Stop(addon, it->second.discovery);
+  Cleanup(it);
+  return result;
+}
+
+bool CMediaImportAddonManager::StopObserver(const std::string& addonId)
+{
+  if (!m_started)
+    return false;
+
+  const auto addon = GetAddon(addonId);
+  return StopObserver(addon);
+}
+
+bool CMediaImportAddonManager::StopObserver(const AddonPtr& addon)
+{
+  if (!m_started || addon == nullptr)
+    return false;
+
+  CSingleLock lock(m_criticalSection);
+  auto it = m_services.find(addon->ID());
+  if (it == m_services.end())
+    return false;
+
+  const auto result = Stop(addon, it->second.observer);
+  Cleanup(it);
+  return result;
+}
+
+AddonPtr CMediaImportAddonManager::GetAddon(const std::string& addonId) const
+{
+  AddonPtr addon;
+  if (!m_addonMgr.GetAddon(addonId, addon, ADDON_MEDIAIMPORTER))
+    return nullptr;
+
+  return addon;
+}
+
+void CMediaImportAddonManager::OnEvent(const AddonEvent& event)
+{
+  if (typeid(event) == typeid(AddonEvents::Enabled))
+    Register(event.id);
+  else if (typeid(event) == typeid(AddonEvents::ReInstalled))
+  {
+    Unregister(event.id);
+    Register(event.id);
+  }
+  else if (typeid(event) == typeid(AddonEvents::Disabled) ||
+           typeid(event) == typeid(AddonEvents::UnInstalled))
+    Unregister(event.id);
+}
+
+void CMediaImportAddonManager::Register(const std::string& addonId)
+{
+  const auto addon = GetAddon(addonId);
+  Register(addon);
+}
+
+void CMediaImportAddonManager::Register(const AddonPtr& addon)
+{
+  if (addon == nullptr)
+    return;
+
+  // register the importer
+  CServiceBroker::GetMediaImportManager().RegisterImporter(
+      std::make_shared<CAddonMediaImporterFactory>(addon->ID()));
+}
+
+void CMediaImportAddonManager::Unregister(const std::string& addonId)
+{
+  const auto addon = GetAddon(addonId);
+  Unregister(addon);
+}
+
+void CMediaImportAddonManager::Unregister(const AddonPtr& addon)
+{
+  if (addon == nullptr)
+    return;
+
+  // unregister the importer
+  CServiceBroker::GetMediaImportManager().UnregisterImporter(addon->ID());
+
+  // make sure that all services are stopped
+  Stop(addon);
+}
+
+bool CMediaImportAddonManager::Stop(const std::string& addonId)
+{
+  const auto addon = GetAddon(addonId);
+  return Stop(addon);
+}
+
+bool CMediaImportAddonManager::Stop(const AddonPtr& addon)
+{
+  if (!m_started || addon == nullptr)
+    return false;
+
+  auto result = StopDiscovery(addon);
+  result &= StopObserver(addon);
+  return result;
+}
+
+bool CMediaImportAddonManager::Stop(const AddonPtr& addon, int& handle)
+{
+  m_logger->debug("stopping {:s}", addon->ID());
+  if (!CScriptInvocationManager::GetInstance().Stop(handle))
+  {
+    CLog::Log(LOGINFO, "CMediaImportAddonManager: failed to stop {:s} (may have ended)",
+              addon->ID());
+    return false;
+  }
+
+  handle = -1;
+
+  return true;
+}
+
+void CMediaImportAddonManager::Cleanup(ServicesMap::iterator service)
+{
+  if (service->second.discovery >= 0 || service->second.observer >= 0)
+    return;
+
+  m_services.erase(service);
+}
+
+} /*namespace ADDON*/
diff --git a/xbmc/addons/MediaImporter.h b/xbmc/addons/MediaImporter.h
new file mode 100644
index 000000000000..61dbec8b9cad
--- /dev/null
+++ b/xbmc/addons/MediaImporter.h
@@ -0,0 +1,137 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "addons/Addon.h"
+#include "media/MediaType.h"
+#include "threads/CriticalSection.h"
+#include "utils/logtypes.h"
+
+#include <string>
+#include <unordered_map>
+
+namespace ADDON
+{
+
+struct AddonEvent;
+
+class CMediaImporter : public CAddon
+{
+public:
+  explicit CMediaImporter(const AddonInfoPtr& addonInfo);
+
+
+  bool HasDiscoveryService() const { return !m_discoveryService.empty(); }
+  std::string DiscoveryServicePath() const;
+
+  bool HasObserverService() const { return !m_observerService.empty(); }
+  std::string ObserverServicePath() const;
+
+  bool CanLookupProvider() const { return m_canLookupProvider; }
+  std::string ProviderLookupProtocol() const;
+
+  bool AutomaticallyAddAsProvider() const;
+  const MediaTypes& SupportedMediaTypes() const { return m_supportedMediaTypes; }
+
+  bool PrepareProviderSettings() const;
+  std::string ProviderSettingsPath() const;
+  bool PrepareImportSettings() const;
+  std::string ImportSettingsPath() const;
+
+private:
+  void SetSupportedMediaTypes(const std::string& supportedMediaTypes);
+
+  static void ParseSettingsElement(const CAddonExtensions* parent,
+                                   const std::string& id,
+                                   bool& prepareSettings,
+                                   std::string& settingsPath);
+
+  std::string m_discoveryService;
+  std::string m_observerService;
+  bool m_canLookupProvider;
+  std::string m_providerLookupProtocol;
+  MediaTypes m_supportedMediaTypes;
+  bool m_prepareProviderSettings;
+  std::string m_providerSettingsPath;
+  bool m_prepareImportSettings;
+  std::string m_importSettingsPath;
+};
+
+class CMediaImportAddonManager
+{
+public:
+  explicit CMediaImportAddonManager(CAddonMgr& addonMgr);
+  ~CMediaImportAddonManager();
+
+  /*!
+   * Start all services.
+   */
+  void Start();
+
+  /*!
+   * Start discovery service by add-on id.
+   */
+  bool StartDiscovery(const AddonPtr& addon);
+  bool StartDiscovery(const std::string& addonId);
+
+  /*!
+   * Start observer service by add-on id.
+   */
+  bool StartObserver(const AddonPtr& addon);
+  bool StartObserver(const std::string& addonId);
+
+  /*!
+   * Stop all services.
+   */
+  void Stop();
+
+  /*!
+   * Stop discovery service by add-on id.
+   */
+  bool StopDiscovery(const AddonPtr& addon);
+  bool StopDiscovery(const std::string& addonId);
+
+  /*!
+   * Stop observer service by add-on id.
+   */
+  bool StopObserver(const AddonPtr& addon);
+  bool StopObserver(const std::string& addonId);
+
+private:
+  /*! add-on id -> script id */
+  typedef struct ServiceHandlers
+  {
+    int discovery = -1;
+    int observer = -1;
+  } ServiceHandlers;
+  using ServicesMap = std::unordered_map<std::string, ServiceHandlers>;
+
+  AddonPtr GetAddon(const std::string& addonId) const;
+
+  void OnEvent(const AddonEvent& event);
+
+  void Register(const std::string& addonId);
+  void Register(const AddonPtr& addon);
+  void Unregister(const std::string& addonId);
+  void Unregister(const AddonPtr& addon);
+
+  bool Stop(const AddonPtr& addon);
+  bool Stop(const std::string& addonId);
+  bool Stop(const AddonPtr& addon, int& handle);
+  void Cleanup(ServicesMap::iterator service);
+
+  CAddonMgr& m_addonMgr;
+  CCriticalSection m_criticalSection;
+  bool m_started = false;
+  ServicesMap m_services;
+
+  Logger m_logger;
+};
+
+} /*namespace ADDON*/
diff --git a/xbmc/addons/addoninfo/AddonInfo.cpp b/xbmc/addons/addoninfo/AddonInfo.cpp
index 33ff2198efef..9b3ed5c736c0 100644
--- a/xbmc/addons/addoninfo/AddonInfo.cpp
+++ b/xbmc/addons/addoninfo/AddonInfo.cpp
@@ -67,6 +67,7 @@ static const TypeMapping types[] =
    {"kodi.inputstream",                  "", ADDON_INPUTSTREAM,         24048, "DefaultAddonInputstream.png" },
    {"kodi.vfs",                          "", ADDON_VFS,                 39013, "DefaultAddonVfs.png" },
    {"kodi.imagedecoder",                 "", ADDON_IMAGEDECODER,        39015, "DefaultAddonImageDecoder.png" },
+   {"kodi.mediaimporter",                "", ADDON_MEDIAIMPORTER,       39029, "DefaultAddonMediaImporter.png" },
   };
 // clang-format on
 
diff --git a/xbmc/addons/addoninfo/AddonType.h b/xbmc/addons/addoninfo/AddonType.h
index 34babd9e0657..ad8f90f8c45b 100644
--- a/xbmc/addons/addoninfo/AddonType.h
+++ b/xbmc/addons/addoninfo/AddonType.h
@@ -56,6 +56,7 @@ typedef enum
   ADDON_SCRIPT_MODULE,
   ADDON_GAME_CONTROLLER,
   ADDON_VIDEOCODEC,
+  ADDON_MEDIAIMPORTER,
 
   /**
     * @brief virtual addon types
diff --git a/xbmc/media/import/importers/AddonMediaImporter.cpp b/xbmc/media/import/importers/AddonMediaImporter.cpp
new file mode 100644
index 000000000000..8e4ecb18264d
--- /dev/null
+++ b/xbmc/media/import/importers/AddonMediaImporter.cpp
@@ -0,0 +1,1123 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "AddonMediaImporter.h"
+
+#include "ServiceBroker.h"
+#include "URL.h"
+#include "addons/AddonManager.h"
+#include "addons/MediaImporter.h"
+#include "filesystem/File.h"
+#include "guilib/LocalizeStrings.h"
+#ifdef HAS_PYTHON
+#include "interfaces/python/XBPython.h"
+#endif
+#include "media/import/MediaImportManager.h"
+#include "media/import/MediaImportSource.h"
+#include "media/import/importers/AddonMediaImporterExecutor.h"
+#include "media/import/jobs/tasks/MediaImportImportItemsRetrievalTask.h"
+#include "media/import/jobs/tasks/MediaImportUpdateTask.h"
+#include "settings/lib/Setting.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+#include <fmt/format.h>
+
+template<typename TType>
+void NullDeleter(TType*)
+{
+}
+
+template<typename TType>
+std::shared_ptr<TType> createSharedPtrWithoutDeleter(TType* obj)
+{
+  return std::shared_ptr<TType>(obj, &NullDeleter<TType>);
+}
+
+SettingType GetSettingType(SettingConstPtr setting)
+{
+  SettingType settingType = setting->GetType();
+  if (settingType == SettingType::List)
+    settingType = std::static_pointer_cast<const CSettingList>(setting)->GetDefinition()->GetType();
+
+  return settingType;
+}
+
+std::shared_ptr<ADDON::CMediaImporter> GetAddon(const std::string& addonId)
+{
+  ADDON::AddonPtr addon;
+  if (!CServiceBroker::GetAddonMgr().GetAddon(addonId, addon, ADDON::ADDON_MEDIAIMPORTER, true))
+    return nullptr;
+
+  return std::static_pointer_cast<ADDON::CMediaImporter>(addon);
+}
+
+CAddonMediaImporterBaseInternal::CAddonMediaImporterBaseInternal(const std::string& addonId,
+                                                                 const std::string& name)
+  : m_addonId(addonId),
+    m_logger(CServiceBroker::GetLogging().GetLogger(StringUtils::Format("{}[{}]", name, addonId)))
+{
+}
+
+std::shared_ptr<ADDON::CMediaImporter> CAddonMediaImporterBaseInternal::GetAddon() const
+{
+  return ::GetAddon(m_addonId);
+}
+
+CAddonMediaImporterBase::CAddonMediaImporterBase(const std::string& addonId,
+                                                 const std::string& name)
+  : CAddonMediaImporterBaseInternal(addonId, name)
+{
+}
+
+bool CAddonMediaImporterBase::CanLookupSource() const
+{
+  const auto addon = GetAddon();
+  if (addon == nullptr)
+    return false;
+
+  return addon->CanLookupProvider();
+}
+
+std::string CAddonMediaImporterBase::GetSourceLookupProtocol() const
+{
+  const auto addon = GetAddon();
+  if (addon == nullptr)
+    return "";
+
+  return addon->ProviderLookupProtocol();
+}
+
+CAddonMediaImporterDiscoverer::CAddonMediaImporterDiscoverer(const std::string& addonId)
+  : CAddonMediaImporterBase(addonId, "CAddonMediaImporterDiscoverer")
+{
+}
+
+CAddonMediaImporterDiscoverer::~CAddonMediaImporterDiscoverer()
+{
+  Stop();
+}
+
+void CAddonMediaImporterDiscoverer::Start()
+{
+  auto mediaImporter = GetAddon();
+  if (mediaImporter == nullptr)
+  {
+    m_logger->warn("cannot start due to missing add-on");
+    return;
+  }
+
+  if (mediaImporter->AutomaticallyAddAsProvider())
+  {
+    // automatically add the add-on as a provider
+    const auto& id = mediaImporter->ID();
+    CMediaImportSource source(id, "plugin://" + id, mediaImporter->Name(), mediaImporter->Icon(),
+                              mediaImporter->SupportedMediaTypes());
+    source.SetImporterId(id);
+
+    if (CServiceBroker::GetMediaImportManager().AddAndActivateSource(source))
+      m_logger->info("source automatically added");
+    else
+      m_logger->warn("failed to automatically add source");
+    return;
+  }
+  else
+  {
+    // check if the media importer add-on has a discovery service
+    if (!mediaImporter->HasDiscoveryService())
+      return;
+
+    // try to start the discovery service
+    if (!CServiceBroker::GetMediaImportAddons().StartDiscovery(mediaImporter))
+    {
+      m_logger->warn("failed to start");
+      return;
+    }
+
+    m_logger->debug("successfully started");
+  }
+  m_started = true;
+}
+
+void CAddonMediaImporterDiscoverer::Stop()
+{
+  if (!m_started)
+    return;
+
+  auto mediaImporter = GetAddon();
+  if (mediaImporter == nullptr)
+  {
+    m_logger->warn("cannot stop due to missing add-on");
+    return;
+  }
+
+  // deactivate automatically added provider
+  if (mediaImporter->AutomaticallyAddAsProvider())
+  {
+    CServiceBroker::GetMediaImportManager().DeactivateSource(mediaImporter->ID());
+    m_logger->debug("automatically added provider deactivated");
+    return;
+  }
+
+  // check if the media importer add-on has a discovery service
+  if (!mediaImporter->HasDiscoveryService())
+    return;
+
+  // try to stop the discovery service
+  if (!CServiceBroker::GetMediaImportAddons().StopDiscovery(mediaImporter))
+  {
+    m_logger->warn("failed to stop");
+    return;
+  }
+
+  m_logger->debug("successfully stopped");
+}
+
+CAddonMediaImporter::CAddonMediaImporter(const std::string& addonId)
+  : CAddonMediaImporterBase(addonId, "CAddonMediaImporter"),
+    CStaticLoggerBase("CAddonMediaImporter")
+{
+}
+
+std::string CAddonMediaImporter::Localize(uint32_t code) const
+{
+  const auto addon = GetAddon();
+  if (addon == nullptr)
+    return "";
+
+  return g_localizeStrings.GetAddonString(addon->ID(), code);
+}
+
+bool CAddonMediaImporter::DiscoverSource(CMediaImportSource& source)
+{
+  if (!CAddonMediaImporterBase::CanLookupSource())
+    return false;
+
+  CAddonMediaImporterExecutor executor(m_addonId,
+                                       CAddonMediaImporterExecutor::Action::DiscoverSource, this);
+  executor.SetSource(createSharedPtrWithoutDeleter(&source));
+  return executor.Execute("");
+}
+
+bool CAddonMediaImporter::LookupSource(const CMediaImportSource& source)
+{
+  if (source.GetIdentifier().empty() || source.GetBasePath().empty() ||
+      !CAddonMediaImporterBase::CanLookupSource())
+    return false;
+
+  CAddonMediaImporterExecutor executor(m_addonId, CAddonMediaImporterExecutor::Action::LookupSource,
+                                       this);
+  executor.SetSource(source);
+  return executor.Execute("");
+}
+
+bool CAddonMediaImporter::CanImport(const std::string& path)
+{
+  const auto importer = GetAddon();
+  if (importer == nullptr)
+    return false;
+
+  // no need to check automatically added providers
+  if (importer->AutomaticallyAddAsProvider())
+    return true;
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("path", path);
+
+  CAddonMediaImporterExecutor executor(m_addonId, CAddonMediaImporterExecutor::Action::CanImport,
+                                       this);
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::IsSourceReady(CMediaImportSource& source)
+{
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("provider", source.GetIdentifier());
+
+  CAddonMediaImporterExecutor executor(m_addonId,
+                                       CAddonMediaImporterExecutor::Action::IsSourceReady, this);
+  executor.SetSource(createSharedPtrWithoutDeleter(&source));
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::IsImportReady(CMediaImport& import)
+{
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("path", import.GetPath());
+  urlOptions.AddOption("mediatypes", import.GetMediaTypes());
+
+  CAddonMediaImporterExecutor executor(m_addonId,
+                                       CAddonMediaImporterExecutor::Action::IsImportReady, this);
+  executor.SetSource(createSharedPtrWithoutDeleter(&import.GetSource()));
+  executor.SetImport(createSharedPtrWithoutDeleter(&import));
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::LoadSourceSettings(CMediaImportSource& source)
+{
+  const auto importer = GetAddon();
+
+  // nothing to do if there is no specific settings XML file
+  if (importer->ProviderSettingsPath().empty())
+    return true;
+
+  // prepare the provider settings
+  if (!PrepareProviderSettings(importer, source.Settings()))
+    return false;
+
+  if (!importer->PrepareProviderSettings())
+    return true;
+
+  m_settingsLoaded = false;
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("provider", source.GetIdentifier());
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::LoadSourceSettings, this);
+  executor.SetSource(createSharedPtrWithoutDeleter(&source));
+  executor.Execute(urlOptions.GetOptionsString());
+
+  return m_settingsLoaded;
+}
+
+bool CAddonMediaImporter::LoadImportSettings(CMediaImport& import)
+{
+  const auto importer = GetAddon();
+
+  // nothing to do if there is no specific settings XML file
+  if (importer->ImportSettingsPath().empty())
+    return true;
+
+  // prepare the import settings
+  if (!PrepareImportSettings(importer, import.Settings()))
+    return false;
+
+  if (!importer->PrepareImportSettings())
+    return true;
+
+  m_settingsLoaded = false;
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("path", import.GetPath());
+  urlOptions.AddOption("mediatypes", import.GetMediaTypes());
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::LoadImportSettings, this);
+  executor.SetSource(createSharedPtrWithoutDeleter(&import.GetSource()));
+  executor.SetImport(createSharedPtrWithoutDeleter(&import));
+  executor.Execute(urlOptions.GetOptionsString());
+
+  return m_settingsLoaded;
+}
+
+bool CAddonMediaImporter::CanUpdateMetadataOnSource(const std::string& path)
+{
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("path", path);
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::CanUpdateMetadataOnSource, this);
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::CanUpdatePlaycountOnSource(const std::string& path)
+{
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("path", path);
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::CanUpdatePlaycountOnSource, this);
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::CanUpdateLastPlayedOnSource(const std::string& path)
+{
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("path", path);
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::CanUpdateLastPlayedOnSource, this);
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::CanUpdateResumePositionOnSource(const std::string& path)
+{
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("path", path);
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::CanUpdateResumePositionOnSource, this);
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::Import(CMediaImportImportItemsRetrievalTask* task)
+{
+  if (task == nullptr)
+    return false;
+
+  auto import = task->GetImport();
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("path", import.GetPath());
+  urlOptions.AddOption("mediatypes", import.GetMediaTypes());
+
+  CAddonMediaImporterExecutor executor(m_addonId, CAddonMediaImporterExecutor::Action::Import,
+                                       this);
+  executor.SetSource(createSharedPtrWithoutDeleter(&import.GetSource()));
+  executor.SetImport(createSharedPtrWithoutDeleter(&import));
+  executor.SetTask(task);
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::UpdateOnSource(CMediaImportUpdateTask* task)
+{
+  if (task == nullptr)
+    return false;
+
+  auto import = task->GetImport();
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("provider", import.GetSource().GetIdentifier());
+  urlOptions.AddOption("path", import.GetPath());
+  urlOptions.AddOption("mediatypes", import.GetMediaTypes());
+
+  CAddonMediaImporterExecutor executor(m_addonId,
+                                       CAddonMediaImporterExecutor::Action::UpdateOnSource, this);
+  executor.SetSource(createSharedPtrWithoutDeleter(&import.GetSource()));
+  executor.SetImport(createSharedPtrWithoutDeleter(&import));
+  executor.SetTask(task);
+  return executor.Execute(urlOptions.GetOptionsString());
+}
+
+bool CAddonMediaImporter::LoadSettings(std::shared_ptr<CSettingsBase> settings, void* data)
+{
+  if (settings == nullptr)
+    return false;
+
+  if (data == nullptr)
+  {
+    m_logger->warn("missing data to load settings");
+    return false;
+  }
+
+  auto callbackData = static_cast<SettingsCallbackData*>(data);
+  if (callbackData->type == SettingsCallbackData::Source)
+  {
+    if (callbackData->data.source == nullptr)
+    {
+      m_logger->warn("missing source to load settings");
+      return false;
+    }
+
+    if (!PrepareProviderSettings(m_addonId, callbackData->data.source->Settings()))
+      return false;
+  }
+  else if (callbackData->type == SettingsCallbackData::Import)
+  {
+    if (callbackData->data.import == nullptr)
+    {
+      m_logger->warn("missing import to load settings");
+      return false;
+    }
+
+    if (!PrepareImportSettings(m_addonId, callbackData->data.import->Settings()))
+      return false;
+  }
+  else
+  {
+    m_logger->warn("invalid data to load settings");
+    return false;
+  }
+
+  return true;
+}
+
+bool CAddonMediaImporter::SaveSettings(std::shared_ptr<CSettingsBase> settings, void* data)
+{
+  if (settings == nullptr)
+    return false;
+
+  return settings->Save();
+}
+
+void CAddonMediaImporter::SetSettingsLoaded(void* data)
+{
+  m_settingsLoaded = true;
+}
+
+void CAddonMediaImporter::OnSettingAction(std::shared_ptr<const CSetting> setting,
+                                          const std::string& callback,
+                                          void* data)
+{
+  if (setting == nullptr || callback.empty())
+    return;
+
+  if (data == nullptr)
+  {
+    m_logger->warn("missing data to handle action setting callback \"{}\" for setting \"{}\"",
+                   callback, setting->GetId());
+    return;
+  }
+
+  auto callbackData = static_cast<SettingsCallbackData*>(data);
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("setting", setting->GetId());
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::SettingActionCallback, this, callback);
+  if (!SetSourceOrImportOnExecutor(executor, *callbackData, callback, setting))
+    return;
+
+  executor.Execute(urlOptions.GetOptionsString());
+}
+
+void CAddonMediaImporter::OnIntegerSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                                        const std::string& callback,
+                                                        IntegerSettingOptions& list,
+                                                        int& current,
+                                                        void* data)
+{
+  if (setting == nullptr || callback.empty())
+    return;
+
+  if (data == nullptr)
+  {
+    m_logger->warn("missing data to handle integer setting options filler "
+                   "callback \"{}\" for setting \"{}\"",
+                   callback, setting->GetId());
+    return;
+  }
+
+  auto callbackData = static_cast<SettingsCallbackData*>(data);
+
+  // clear the setting options
+  m_integerSettingOptionsSet = false;
+  m_integerSettingOptions.clear();
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("setting", setting->GetId());
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::SettingOptionsFiller, this, callback);
+  if (!SetSourceOrImportOnExecutor(executor, *callbackData, callback, setting))
+    return;
+
+  executor.Execute(urlOptions.GetOptionsString());
+
+  if (!m_integerSettingOptionsSet)
+  {
+    m_logger->error("integer setting options filler callback \"{}\" for setting \"{}\" failed",
+                    callback, setting->GetId());
+    return;
+  }
+
+  list = m_integerSettingOptions;
+
+  // validate the current value
+  bool foundCurrent =
+      std::any_of(list.cbegin(), list.cend(), [&current](const IntegerSettingOption& option) {
+        return option.value == current;
+      });
+
+  // reset the current value to the default
+  if (!foundCurrent)
+    current = std::static_pointer_cast<const CSettingInt>(setting)->GetDefault();
+}
+
+bool CAddonMediaImporter::SetIntegerSettingOptions(const std::string& settingId,
+                                                   const IntegerSettingOptions& list,
+                                                   void* data)
+{
+  m_integerSettingOptions = list;
+  m_integerSettingOptionsSet = true;
+  return true;
+}
+
+void CAddonMediaImporter::OnStringSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                                       const std::string& callback,
+                                                       StringSettingOptions& list,
+                                                       std::string& current,
+                                                       void* data)
+{
+  if (setting == nullptr || callback.empty())
+    return;
+
+  if (data == nullptr)
+  {
+    m_logger->warn("missing data to handle string setting options filler "
+                   "callback \"{}\" for setting \"{}\"",
+                   callback, setting->GetId());
+    return;
+  }
+
+  auto callbackData = static_cast<SettingsCallbackData*>(data);
+
+  // clear the setting options
+  m_stringSettingOptionsSet = false;
+  m_stringSettingOptions.clear();
+
+  CUrlOptions urlOptions;
+  urlOptions.AddOption("setting", setting->GetId());
+
+  CAddonMediaImporterExecutor executor(
+      m_addonId, CAddonMediaImporterExecutor::Action::SettingOptionsFiller, this, callback);
+  if (!SetSourceOrImportOnExecutor(executor, *callbackData, callback, setting))
+    return;
+
+  executor.Execute(urlOptions.GetOptionsString());
+
+  if (!m_stringSettingOptionsSet)
+  {
+    m_logger->error("string setting options filler callback \"{}\" for setting \"{}\" failed",
+                    callback, setting->GetId());
+    return;
+  }
+
+  list = m_stringSettingOptions;
+
+  // validate the current value
+  bool foundCurrent =
+      std::any_of(list.cbegin(), list.cend(), [&current](const StringSettingOption& option) {
+        return option.value == current;
+      });
+
+  // reset the current value to the default
+  if (!foundCurrent)
+    current = std::static_pointer_cast<const CSettingString>(setting)->GetDefault();
+}
+
+bool CAddonMediaImporter::SetStringSettingOptions(const std::string& settingId,
+                                                  const StringSettingOptions& list,
+                                                  void* data)
+{
+  m_stringSettingOptions = list;
+  m_stringSettingOptionsSet = true;
+  return true;
+}
+
+bool CAddonMediaImporter::PrepareProviderSettings(const std::string& addonId,
+                                                  MediaImportSettingsBasePtr settings)
+{
+  if (addonId.empty() || settings == nullptr)
+    return false;
+
+  // check if the media import add-on provides an XML file with the setting
+  // definitions for the media provider and load it
+  const auto importer = ::GetAddon(addonId);
+  if (importer == nullptr)
+    return false;
+
+  return PrepareProviderSettings(importer, settings);
+}
+
+bool CAddonMediaImporter::PrepareProviderSettings(std::shared_ptr<ADDON::CMediaImporter> addon,
+                                                  MediaImportSettingsBasePtr settings)
+{
+  // nothing to do if there is no specific settings XML file
+  if (addon->ProviderSettingsPath().empty())
+    return true;
+
+  if (LoadSettingsFromFile(addon->ID(), settings, addon->ProviderSettingsPath()))
+    return true;
+
+  s_logger->warn("failed to load provider settings for {} from {}", addon->ID(),
+                 addon->ProviderSettingsPath());
+
+  return false;
+}
+
+bool CAddonMediaImporter::PrepareImportSettings(const std::string& addonId,
+                                                MediaImportSettingsBasePtr settings)
+{
+  // check if the media import add-on provides an XML file with the setting
+  // definitions for the media provider and load it
+  const auto importer = ::GetAddon(addonId);
+  if (importer == nullptr)
+    return false;
+
+  return PrepareImportSettings(importer, settings);
+}
+
+bool CAddonMediaImporter::PrepareImportSettings(std::shared_ptr<ADDON::CMediaImporter> addon,
+                                                MediaImportSettingsBasePtr settings)
+{
+  // nothing to do if there is no specific settings XML file
+  if (addon->ImportSettingsPath().empty())
+    return true;
+
+  if (LoadSettingsFromFile(addon->ID(), settings, addon->ImportSettingsPath()))
+    return true;
+
+  s_logger->warn("failed to load import settings for {} from {}", addon->ID(),
+                 addon->ImportSettingsPath());
+
+  return false;
+}
+
+std::string CAddonMediaImporter::GetImporterId(const std::string& addonId)
+{
+  const auto importerAddon = ::GetAddon(addonId);
+  if (importerAddon == nullptr)
+    return "";
+
+  return importerAddon->ID();
+}
+
+void CAddonMediaImporter::SetDiscoveredProviderDetails(
+    HandleType handle,
+    bool providerDiscovered,
+    MediaImportSourcePtr discoveredSource) throw(InvalidAddonMediaImporterHandleException)
+{
+  if (discoveredSource == nullptr)
+    providerDiscovered = false;
+
+  auto executor = CAddonMediaImporterExecutor::GetExecutorFromHandle(handle);
+  executor->SetSuccess(providerDiscovered, CAddonMediaImporterExecutor::Action::DiscoverSource);
+
+  if (discoveredSource != nullptr)
+    *executor->GetSource() = *discoveredSource;
+}
+
+void CAddonMediaImporter::SetProviderFound(HandleType handle, bool providerFound)
+{
+  auto executor = CAddonMediaImporterExecutor::GetExecutorFromHandle(handle);
+  executor->SetSuccess(providerFound, CAddonMediaImporterExecutor::Action::LookupSource);
+}
+
+bool CAddonMediaImporter::SetSourceOrImportOnExecutor(CAddonMediaImporterExecutor& executor,
+                                                      const SettingsCallbackData& callbackData,
+                                                      const std::string& callback,
+                                                      std::shared_ptr<const CSetting> setting) const
+{
+  if (callbackData.type == SettingsCallbackData::Source)
+  {
+    if (callbackData.data.source == nullptr)
+    {
+      m_logger->warn("missing source to handle setting callback \"{}\" for setting \"{}\"",
+                     callback, setting->GetId());
+      return false;
+    }
+    executor.SetSource(*static_cast<CMediaImportSource*>(callbackData.data.source));
+  }
+  else if (callbackData.type == SettingsCallbackData::Import)
+  {
+    if (callbackData.data.import == nullptr)
+    {
+      m_logger->warn("missing import to handle setting callback \"{}\" for setting \"{}\"",
+                     callback, setting->GetId());
+      return false;
+    }
+    executor.SetImport(*static_cast<CMediaImport*>(callbackData.data.import));
+  }
+  else
+  {
+    m_logger->warn("invalid data to handle setting callback \"{}\" for setting \"{}\"", callback,
+                   setting->GetId());
+    return false;
+  }
+
+  return true;
+}
+
+bool CAddonMediaImporter::LoadSettingsFromFile(const std::string& addonId,
+                                               MediaImportSettingsBasePtr settings,
+                                               const std::string& settingDefinitionsFile)
+{
+  if (settings == nullptr)
+    return false;
+
+  CXBMCTinyXML xmlDoc;
+  if (!XFILE::CFile::Exists(settingDefinitionsFile))
+  {
+    s_logger->error("could not find provider settings for {} at {}", addonId,
+                    settingDefinitionsFile);
+    return false;
+  }
+  if (!xmlDoc.LoadFile(settingDefinitionsFile))
+  {
+    s_logger->error("failed to parse provider settings for {} from {}: Line {}, {}", addonId,
+                    settingDefinitionsFile, xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+    return false;
+  }
+  if (xmlDoc.RootElement() == nullptr)
+    return false;
+
+  TiXmlPrinter printer;
+  xmlDoc.Accept(&printer);
+
+  const auto settingDefinition = printer.Str();
+
+  // check if the setting definition has already been loaded
+  if (settings->IsLoaded())
+  {
+    if (settings->HasDefinition(settingDefinition))
+      return true;
+
+    // otherwise unload the settings
+    settings->Unload();
+  }
+
+  s_logger->debug("loading settings for {} from {}...", addonId, settingDefinitionsFile);
+
+  settings->AddDefinition(settingDefinition);
+  return settings->Load();
+}
+
+void CAddonMediaImporter::SetCanImport(HandleType handle, bool canImport) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  SetSuccess(handle, canImport, CAddonMediaImporterExecutor::Action::CanImport);
+}
+
+void CAddonMediaImporter::SetProviderReady(HandleType handle, bool sourceReady) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  SetSuccess(handle, sourceReady, CAddonMediaImporterExecutor::Action::IsSourceReady);
+}
+
+void CAddonMediaImporter::SetImportReady(HandleType handle, bool importReady) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  SetSuccess(handle, importReady, CAddonMediaImporterExecutor::Action::IsImportReady);
+}
+
+void CAddonMediaImporter::SetCanUpdateMetadataOnProvider(
+    HandleType handle,
+    bool canUpdateMetadataOnSource) throw(InvalidAddonMediaImporterHandleException)
+{
+  SetSuccess(handle, canUpdateMetadataOnSource,
+             CAddonMediaImporterExecutor::Action::CanUpdateMetadataOnSource);
+}
+
+void CAddonMediaImporter::SetCanUpdatePlaycountOnProvider(
+    HandleType handle,
+    bool canUpdatePlaycountOnSource) throw(InvalidAddonMediaImporterHandleException)
+{
+  SetSuccess(handle, canUpdatePlaycountOnSource,
+             CAddonMediaImporterExecutor::Action::CanUpdatePlaycountOnSource);
+}
+
+void CAddonMediaImporter::SetCanUpdateLastPlayedOnProvider(
+    HandleType handle,
+    bool canUpdateLastPlayedOnSource) throw(InvalidAddonMediaImporterHandleException)
+{
+  SetSuccess(handle, canUpdateLastPlayedOnSource,
+             CAddonMediaImporterExecutor::Action::CanUpdateLastPlayedOnSource);
+}
+
+void CAddonMediaImporter::SetCanUpdateResumePositionOnProvider(
+    HandleType handle,
+    bool canUpdateResumePositionOnSource) throw(InvalidAddonMediaImporterHandleException)
+{
+  SetSuccess(handle, canUpdateResumePositionOnSource,
+             CAddonMediaImporterExecutor::Action::CanUpdateResumePositionOnSource);
+}
+
+bool CAddonMediaImporter::ShouldCancel(
+    HandleType handle,
+    unsigned int progress,
+    unsigned int total) throw(InvalidAddonMediaImporterHandleException)
+{
+  return CAddonMediaImporterExecutor::GetExecutorFromHandle(handle)->ShouldCancel(progress, total);
+}
+
+void CAddonMediaImporter::SetProgressStatus(HandleType handle, const std::string& status) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  CAddonMediaImporterExecutor::GetExecutorFromHandle(handle)->SetProgressStatus(status);
+}
+
+CAddonMediaImporter* CAddonMediaImporter::GetImporter(HandleType handle) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  return CAddonMediaImporterExecutor::GetExecutorFromHandle(handle)->GetImporter();
+}
+
+MediaImportSourcePtr CAddonMediaImporter::GetMediaProvider(HandleType handle) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  return CAddonMediaImporterExecutor::GetExecutorFromHandle(handle)->GetSource();
+}
+
+MediaImportPtr CAddonMediaImporter::GetMediaImport(HandleType handle) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  return CAddonMediaImporterExecutor::GetExecutorFromHandle(handle)->GetImport();
+}
+
+std::vector<CFileItemPtr> CAddonMediaImporter::GetImportedItems(
+    HandleType handle, const MediaType& mediaType) throw(InvalidAddonMediaImporterHandleException)
+{
+  auto executor = CAddonMediaImporterExecutor::GetExecutorFromHandle(handle);
+  if (!executor->CheckAction(CAddonMediaImporterExecutor::Action::Import) ||
+      executor->GetTask() == nullptr)
+  {
+    s_logger->error("cannot get imported items for handle {}", handle);
+    return {};
+  }
+
+  auto retrievalTask = dynamic_cast<CMediaImportImportItemsRetrievalTask*>(executor->GetTask());
+  if (retrievalTask == nullptr)
+  {
+    s_logger->error("invalid import task ({}) to get imported items for handle {}",
+                    static_cast<int>(executor->GetTask()->GetType()), handle);
+    return {};
+  }
+
+  return retrievalTask->GetLocalItems(mediaType);
+}
+
+void CAddonMediaImporter::AddImportItem(
+    HandleType handle,
+    const CFileItemPtr& item,
+    const MediaType& mediaType,
+    MediaImportChangesetType
+        changesetType /* = MediaImportChangesetTypeNone */) throw(InvalidAddonMediaImporterHandleException)
+{
+  auto executor = CAddonMediaImporterExecutor::GetExecutorFromHandle(handle);
+  if (!executor->CheckAction(CAddonMediaImporterExecutor::Action::Import) ||
+      executor->GetTask() == nullptr)
+  {
+    s_logger->error("cannot add imported item for handle {}", handle);
+    return;
+  }
+
+  auto retrievalTask = dynamic_cast<CMediaImportImportItemsRetrievalTask*>(executor->GetTask());
+  if (retrievalTask == nullptr)
+  {
+    s_logger->error("invalid import task ({}) to add imported item for handle {}",
+                    static_cast<int>(executor->GetTask()->GetType()), handle);
+    return;
+  }
+
+  retrievalTask->AddItem(item, mediaType, changesetType);
+}
+
+void CAddonMediaImporter::AddImportItems(
+    HandleType handle,
+    const std::vector<CFileItemPtr>& items,
+    const MediaType& mediaType,
+    MediaImportChangesetType
+        changesetType /* = MediaImportChangesetTypeNone */) throw(InvalidAddonMediaImporterHandleException)
+{
+  auto executor = CAddonMediaImporterExecutor::GetExecutorFromHandle(handle);
+  if (!executor->CheckAction(CAddonMediaImporterExecutor::Action::Import) ||
+      executor->GetTask() == nullptr)
+  {
+    s_logger->error("cannot add imported items for handle {}", handle);
+    return;
+  }
+
+  auto retrievalTask = dynamic_cast<CMediaImportImportItemsRetrievalTask*>(executor->GetTask());
+  if (retrievalTask == nullptr)
+  {
+    s_logger->error("invalid import task ({}) to add imported items for handle {}",
+                    static_cast<int>(executor->GetTask()->GetType()), handle);
+    return;
+  }
+
+  retrievalTask->AddItems(items, mediaType, changesetType);
+}
+
+void CAddonMediaImporter::FinishImport(HandleType handle, bool isChangeset /* = false */) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  auto executor = CAddonMediaImporterExecutor::GetExecutorFromHandle(handle);
+  if (!executor->CheckAction(CAddonMediaImporterExecutor::Action::Import) ||
+      executor->GetTask() == nullptr)
+  {
+    s_logger->error("cannot finish import for handle {}", handle);
+    return;
+  }
+
+  auto retrievalTask = dynamic_cast<CMediaImportImportItemsRetrievalTask*>(executor->GetTask());
+  if (retrievalTask == nullptr)
+  {
+    s_logger->error("invalid import task ({}) to finish import for handle {}",
+                    static_cast<int>(executor->GetTask()->GetType()), handle);
+    return;
+  }
+
+  retrievalTask->SetChangeset(isChangeset);
+
+  executor->SetSuccess(true, CAddonMediaImporterExecutor::Action::Import);
+}
+
+CFileItemPtr CAddonMediaImporter::GetUpdatedItem(HandleType handle) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  auto executor = CAddonMediaImporterExecutor::GetExecutorFromHandle(handle);
+  if (!executor->CheckAction(CAddonMediaImporterExecutor::Action::UpdateOnSource) ||
+      executor->GetTask() == nullptr)
+  {
+    s_logger->error("cannot update imported item for handle {}", handle);
+    return nullptr;
+  }
+
+  auto updateTask = dynamic_cast<CMediaImportUpdateTask*>(executor->GetTask());
+  if (updateTask == nullptr)
+  {
+    s_logger->error("invalid import task ({}) to update imported item for handle {}",
+                    static_cast<int>(executor->GetTask()->GetType()), handle);
+    return nullptr;
+  }
+
+  return std::make_shared<CFileItem>(updateTask->GetItem());
+}
+
+void CAddonMediaImporter::FinishUpdateOnProvider(HandleType handle) throw(
+    InvalidAddonMediaImporterHandleException)
+{
+  SetSuccess(handle, true, CAddonMediaImporterExecutor::Action::UpdateOnSource);
+}
+
+void CAddonMediaImporter::SetSuccess(
+    HandleType handle,
+    bool success,
+    CAddonMediaImporterExecutor::Action action) throw(InvalidAddonMediaImporterHandleException)
+{
+  CAddonMediaImporterExecutor::GetExecutorFromHandle(handle)->SetSuccess(success, action);
+}
+
+CAddonMediaImporterObserver::CAddonMediaImporterObserver(const std::string& addonId)
+  : CAddonMediaImporterBaseInternal(addonId, "CAddonMediaImporterObserver")
+{
+}
+
+CAddonMediaImporterObserver::~CAddonMediaImporterObserver()
+{
+  Stop();
+}
+
+void CAddonMediaImporterObserver::Start()
+{
+  auto mediaImporter = GetAddon();
+  if (mediaImporter == nullptr)
+  {
+    m_logger->warn("cannot start due to missing add-on");
+    return;
+  }
+
+  // check if the media importer add-on has a observer service
+  if (!mediaImporter->HasObserverService())
+    return;
+
+  // try to start the observer service
+  if (!CServiceBroker::GetMediaImportAddons().StartObserver(mediaImporter))
+  {
+    m_logger->warn("failed to start");
+    return;
+  }
+
+  m_started = true;
+  m_logger->debug("successfully started");
+}
+
+void CAddonMediaImporterObserver::OnSourceAdded(const CMediaImportSource& source)
+{
+#ifdef HAS_PYTHON
+  CServiceBroker::GetXBPython().OnSourceAdded(m_addonId, source);
+#endif
+}
+
+void CAddonMediaImporterObserver::OnSourceUpdated(const CMediaImportSource& source)
+{
+#ifdef HAS_PYTHON
+  CServiceBroker::GetXBPython().OnSourceUpdated(m_addonId, source);
+#endif
+}
+
+void CAddonMediaImporterObserver::OnSourceRemoved(const CMediaImportSource& source)
+{
+#ifdef HAS_PYTHON
+  CServiceBroker::GetXBPython().OnSourceRemoved(m_addonId, source);
+#endif
+}
+
+void CAddonMediaImporterObserver::OnSourceActivated(const CMediaImportSource& source)
+{
+#ifdef HAS_PYTHON
+  CServiceBroker::GetXBPython().OnSourceActivated(m_addonId, source);
+#endif
+}
+
+void CAddonMediaImporterObserver::OnSourceDeactivated(const CMediaImportSource& source)
+{
+#ifdef HAS_PYTHON
+  CServiceBroker::GetXBPython().OnSourceDeactivated(m_addonId, source);
+#endif
+}
+
+void CAddonMediaImporterObserver::OnImportAdded(const CMediaImport& import)
+{
+#ifdef HAS_PYTHON
+  CServiceBroker::GetXBPython().OnImportAdded(m_addonId, import);
+#endif
+}
+
+void CAddonMediaImporterObserver::OnImportUpdated(const CMediaImport& import)
+{
+#ifdef HAS_PYTHON
+  CServiceBroker::GetXBPython().OnImportUpdated(m_addonId, import);
+#endif
+}
+
+void CAddonMediaImporterObserver::OnImportRemoved(const CMediaImport& import)
+{
+#ifdef HAS_PYTHON
+  CServiceBroker::GetXBPython().OnImportRemoved(m_addonId, import);
+#endif
+}
+
+void CAddonMediaImporterObserver::Stop()
+{
+  if (!m_started)
+    return;
+
+  auto mediaImporter = GetAddon();
+  if (mediaImporter == nullptr)
+  {
+    m_logger->warn("cannot stop due to missing add-on");
+    return;
+  }
+
+  // check if the media importer add-on has an observer service
+  if (!mediaImporter->HasObserverService())
+    return;
+
+  // try to stop the observer service
+  if (!CServiceBroker::GetMediaImportAddons().StopObserver(mediaImporter))
+  {
+    m_logger->warn("failed to stop");
+    return;
+  }
+
+  m_logger->debug("successfully stopped");
+}
+
+CAddonMediaImporterFactory::CAddonMediaImporterFactory(const std::string& addonId)
+  : CAddonMediaImporterBaseInternal(addonId, "CAddonMediaImporterFactory")
+{
+}
+
+std::unique_ptr<IMediaImporterDiscoverer> CAddonMediaImporterFactory::CreateDiscoverer() const
+{
+  return std::make_unique<CAddonMediaImporterDiscoverer>(m_addonId);
+}
+
+std::unique_ptr<IMediaImporter> CAddonMediaImporterFactory::CreateImporter() const
+{
+  return std::make_unique<CAddonMediaImporter>(m_addonId);
+}
+
+std::unique_ptr<IMediaImporterObserver> CAddonMediaImporterFactory::CreateObserver() const
+{
+  return std::make_unique<CAddonMediaImporterObserver>(m_addonId);
+}
diff --git a/xbmc/media/import/importers/AddonMediaImporter.h b/xbmc/media/import/importers/AddonMediaImporter.h
new file mode 100644
index 000000000000..c7da1db7d3b3
--- /dev/null
+++ b/xbmc/media/import/importers/AddonMediaImporter.h
@@ -0,0 +1,296 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "addons/settings/IAddonSettingsCallbackExecutor.h"
+#include "commons/Exception.h"
+#include "interfaces/generic/RunningScriptsHandler.h"
+#include "media/import/MediaImportChangesetTypes.h"
+#include "media/import/importers/AddonMediaImporterExecutor.h"
+#include "media/import/importers/BaseMediaImporter.h"
+#include "settings/lib/SettingDefinitions.h"
+#include "settings/lib/SettingType.h"
+#include "utils/StaticLoggerBase.h"
+#include "utils/logtypes.h"
+
+#include <memory>
+#include <string>
+#include <unordered_set>
+
+namespace ADDON
+{
+struct AddonEvent;
+class CAddonMgr;
+class CMediaImporter;
+} // namespace ADDON
+
+class CMediaImportManager;
+
+class CAddonMediaImporterBaseInternal
+{
+public:
+  virtual ~CAddonMediaImporterBaseInternal() = default;
+
+  const std::string& GetAddonId() const { return m_addonId; }
+
+protected:
+  explicit CAddonMediaImporterBaseInternal(const std::string& addonId, const std::string& name);
+
+  std::shared_ptr<ADDON::CMediaImporter> GetAddon() const;
+
+  const std::string m_addonId;
+
+  Logger m_logger;
+};
+
+class CAddonMediaImporterBase : public virtual IMediaImporterBase,
+                                public CAddonMediaImporterBaseInternal
+{
+public:
+  ~CAddonMediaImporterBase() override = default;
+
+  // implementations of IMediaImporterBase
+  const char* GetIdentification() const override { return m_addonId.c_str(); }
+  bool CanLookupSource() const override;
+  std::string GetSourceLookupProtocol() const override;
+
+protected:
+  explicit CAddonMediaImporterBase(const std::string& addonId, const std::string& name);
+};
+
+class CAddonMediaImporterDiscoverer : public IMediaImporterDiscoverer,
+                                      public CAddonMediaImporterBase
+{
+public:
+  using HandleType = CAddonMediaImporterExecutor::HandleType;
+
+  explicit CAddonMediaImporterDiscoverer(const std::string& addonId);
+  ~CAddonMediaImporterDiscoverer() override;
+
+  // implementations of IMediaImporterDiscoverer
+  void Start() override;
+
+private:
+  void Stop();
+
+  bool m_started = false;
+};
+
+class CAddonMediaImporter : public CAddonMediaImporterBase,
+                            public CBaseMediaImporter,
+                            public ADDON::IAddonSettingsCallbackExecutor,
+                            protected CStaticLoggerBase
+{
+public:
+  using HandleType = CAddonMediaImporterExecutor::HandleType;
+
+  typedef struct SettingsCallbackData
+  {
+    enum Type
+    {
+      Source,
+      Import,
+    } type;
+    union
+    {
+      CMediaImportSource* source;
+      CMediaImport* import;
+    } data;
+  } SettingsCallbackData;
+
+  explicit CAddonMediaImporter(const std::string& addonId);
+  ~CAddonMediaImporter() override = default;
+
+  // implementation of ILocalizer
+  std::string Localize(uint32_t code) const override;
+
+  // implementations of IMediaImporter::IImporter
+  bool DiscoverSource(CMediaImportSource& source) override;
+  bool LookupSource(const CMediaImportSource& source) override;
+
+  bool CanImport(const std::string& path) override;
+  bool IsSourceReady(CMediaImportSource& source) override;
+  bool IsImportReady(CMediaImport& import) override;
+  bool LoadSourceSettings(CMediaImportSource& source) override;
+  bool LoadImportSettings(CMediaImport& import) override;
+  bool CanUpdateMetadataOnSource(const std::string& path) override;
+  bool CanUpdatePlaycountOnSource(const std::string& path) override;
+  bool CanUpdateLastPlayedOnSource(const std::string& path) override;
+  bool CanUpdateResumePositionOnSource(const std::string& path) override;
+
+  bool Import(CMediaImportImportItemsRetrievalTask* task) override;
+  bool UpdateOnSource(CMediaImportUpdateTask* task) override;
+
+  // implementations of IAddonSettingsCallbackExecutor
+  bool LoadSettings(std::shared_ptr<CSettingsBase> settings, void* data) override;
+  bool SaveSettings(std::shared_ptr<CSettingsBase> settings, void* data) override;
+  void SetSettingsLoaded(void* data) override;
+
+  void OnSettingAction(std::shared_ptr<const CSetting> setting,
+                       const std::string& callback,
+                       void* data) override;
+
+  void OnIntegerSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                     const std::string& callback,
+                                     IntegerSettingOptions& list,
+                                     int& current,
+                                     void* data) override;
+  bool SetIntegerSettingOptions(const std::string& settingId,
+                                const IntegerSettingOptions& list,
+                                void* data) override;
+
+  void OnStringSettingOptionsFiller(std::shared_ptr<const CSetting> setting,
+                                    const std::string& callback,
+                                    StringSettingOptions& list,
+                                    std::string& current,
+                                    void* data) override;
+  bool SetStringSettingOptions(const std::string& settingId,
+                               const StringSettingOptions& list,
+                               void* data) override;
+  ;
+
+  // helper methods for add-on scripts
+  static bool PrepareProviderSettings(const std::string& addonId,
+                                      MediaImportSettingsBasePtr settings);
+  static bool PrepareProviderSettings(std::shared_ptr<ADDON::CMediaImporter> addon,
+                                      MediaImportSettingsBasePtr settings);
+  static bool PrepareImportSettings(const std::string& addonId,
+                                    MediaImportSettingsBasePtr settings);
+  static bool PrepareImportSettings(std::shared_ptr<ADDON::CMediaImporter> addon,
+                                    MediaImportSettingsBasePtr settings);
+
+  // methods to interact with the add-on script(s)
+  static std::string GetImporterId(const std::string& addonId);
+
+  static void SetDiscoveredProviderDetails(
+      HandleType handle,
+      bool providerDiscovered,
+      MediaImportSourcePtr discoveredSource) throw(InvalidAddonMediaImporterHandleException);
+  static void SetProviderFound(HandleType handle, bool providerFound);
+
+  static void SetCanImport(HandleType handle,
+                           bool canImport) throw(InvalidAddonMediaImporterHandleException);
+  static void SetProviderReady(HandleType handle,
+                               bool sourceReady) throw(InvalidAddonMediaImporterHandleException);
+  static void SetImportReady(HandleType handle,
+                             bool importReady) throw(InvalidAddonMediaImporterHandleException);
+  static void SetCanUpdateMetadataOnProvider(
+      HandleType handle,
+      bool canUpdateMetadataOnSource) throw(InvalidAddonMediaImporterHandleException);
+  static void SetCanUpdatePlaycountOnProvider(
+      HandleType handle,
+      bool canUpdatePlaycountOnSource) throw(InvalidAddonMediaImporterHandleException);
+  static void SetCanUpdateLastPlayedOnProvider(
+      HandleType handle,
+      bool canUpdateLastPlayedOnSource) throw(InvalidAddonMediaImporterHandleException);
+  static void SetCanUpdateResumePositionOnProvider(
+      HandleType handle,
+      bool canUpdateResumePositionOnSource) throw(InvalidAddonMediaImporterHandleException);
+
+  // methods concerning the current state and progress of the add-on script(s)
+  static bool ShouldCancel(HandleType handle,
+                           unsigned int progress,
+                           unsigned int total) throw(InvalidAddonMediaImporterHandleException);
+  static void SetProgressStatus(HandleType handle, const std::string& status) throw(
+      InvalidAddonMediaImporterHandleException);
+
+  // general methods to interact with the add-on script(s)
+  static CAddonMediaImporter* GetImporter(HandleType handle) throw(
+      InvalidAddonMediaImporterHandleException);
+  static MediaImportSourcePtr GetMediaProvider(HandleType handle) throw(
+      InvalidAddonMediaImporterHandleException);
+  static MediaImportPtr GetMediaImport(HandleType handle) throw(
+      InvalidAddonMediaImporterHandleException);
+
+  // methods to interact with the add-on script(s) executing Import()
+  static std::vector<CFileItemPtr> GetImportedItems(
+      HandleType handle,
+      const MediaType& mediaType) throw(InvalidAddonMediaImporterHandleException);
+  static void AddImportItem(
+      HandleType handle,
+      const CFileItemPtr& item,
+      const MediaType& mediaType,
+      MediaImportChangesetType changesetType =
+          MediaImportChangesetType::None) throw(InvalidAddonMediaImporterHandleException);
+  static void AddImportItems(
+      HandleType handle,
+      const std::vector<CFileItemPtr>& items,
+      const MediaType& mediaType,
+      MediaImportChangesetType changesetType =
+          MediaImportChangesetType::None) throw(InvalidAddonMediaImporterHandleException);
+  static void FinishImport(HandleType handle, bool isChangeset = false) throw(
+      InvalidAddonMediaImporterHandleException);
+
+  // methods to interact with the add-on script(s) executing UpdateOnSource()
+  static CFileItemPtr GetUpdatedItem(HandleType handle) throw(
+      InvalidAddonMediaImporterHandleException);
+  static void FinishUpdateOnProvider(HandleType handle) throw(
+      InvalidAddonMediaImporterHandleException);
+
+private:
+  bool SetSourceOrImportOnExecutor(CAddonMediaImporterExecutor& executor,
+                                   const SettingsCallbackData& callbackData,
+                                   const std::string& callback,
+                                   std::shared_ptr<const CSetting> setting) const;
+
+  static bool LoadSettingsFromFile(const std::string& addonId,
+                                   MediaImportSettingsBasePtr settings,
+                                   const std::string& settingDefinitionsFile);
+
+  static void SetSuccess(
+      HandleType handle,
+      bool success,
+      CAddonMediaImporterExecutor::Action action) throw(InvalidAddonMediaImporterHandleException);
+
+  bool m_settingsLoaded = false;
+
+  bool m_integerSettingOptionsSet = false;
+  IntegerSettingOptions m_integerSettingOptions;
+  bool m_stringSettingOptionsSet = false;
+  StringSettingOptions m_stringSettingOptions;
+};
+
+class CAddonMediaImporterObserver : public IMediaImporterObserver,
+                                    public CAddonMediaImporterBaseInternal
+{
+public:
+  explicit CAddonMediaImporterObserver(const std::string& addonId);
+  ~CAddonMediaImporterObserver() override;
+
+  // implementations of IMediaImporterObserver
+  void Start() override;
+  void OnSourceAdded(const CMediaImportSource& source) override;
+  void OnSourceUpdated(const CMediaImportSource& source) override;
+  void OnSourceRemoved(const CMediaImportSource& source) override;
+  void OnSourceActivated(const CMediaImportSource& source) override;
+  void OnSourceDeactivated(const CMediaImportSource& source) override;
+  void OnImportAdded(const CMediaImport& import) override;
+  void OnImportUpdated(const CMediaImport& import) override;
+  void OnImportRemoved(const CMediaImport& import) override;
+
+private:
+  void Stop();
+
+  bool m_started = false;
+};
+
+class CAddonMediaImporterFactory : public IMediaImporterFactory,
+                                   protected CAddonMediaImporterBaseInternal
+{
+public:
+  CAddonMediaImporterFactory(const std::string& addonId);
+  ~CAddonMediaImporterFactory() override = default;
+
+  // implementations of IMediaImporterFactory
+  const char* GetIdentification() const override { return m_addonId.c_str(); }
+
+  std::unique_ptr<IMediaImporterDiscoverer> CreateDiscoverer() const override;
+  std::unique_ptr<IMediaImporter> CreateImporter() const override;
+  std::unique_ptr<IMediaImporterObserver> CreateObserver() const override;
+};
diff --git a/xbmc/media/import/importers/AddonMediaImporterExecutor.cpp b/xbmc/media/import/importers/AddonMediaImporterExecutor.cpp
new file mode 100644
index 000000000000..c01a1c77aaf3
--- /dev/null
+++ b/xbmc/media/import/importers/AddonMediaImporterExecutor.cpp
@@ -0,0 +1,217 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "AddonMediaImporterExecutor.h"
+
+#include "ServiceBroker.h"
+#include "URL.h"
+#include "addons/AddonManager.h"
+#include "addons/IAddon.h"
+#include "addons/MediaImporter.h"
+#include "media/import/jobs/tasks/IMediaImportTask.h"
+#include "utils/StringUtils.h"
+#include "utils/log.h"
+
+CAddonMediaImporterExecutor::CAddonMediaImporterExecutor(
+    const std::string& addonId,
+    Action action,
+    CAddonMediaImporter* importer /* = nullptr */,
+    const std::string& actionName /* = "" */)
+  : m_addonId(addonId),
+    m_action(action),
+    m_actionName(!actionName.empty() ? actionName : ActionToString(action)),
+    m_importer(importer),
+    m_logger(CServiceBroker::GetLogging().GetLogger(
+        StringUtils::Format("CAddonMediaImporterExecutor[{}]", addonId)))
+{
+}
+
+void CAddonMediaImporterExecutor::SetSource(const CMediaImportSource& source)
+{
+  SetSource(std::make_shared<CMediaImportSource>(source));
+}
+
+void CAddonMediaImporterExecutor::SetSource(MediaImportSourcePtr source)
+{
+  m_source = source;
+}
+
+void CAddonMediaImporterExecutor::SetImport(const CMediaImport& import)
+{
+  SetImport(std::make_shared<CMediaImport>(import));
+}
+
+void CAddonMediaImporterExecutor::SetImport(MediaImportPtr import)
+{
+  m_import = import;
+
+  if (m_import != nullptr && m_source == nullptr)
+    SetSource(m_import->GetSource());
+}
+
+void CAddonMediaImporterExecutor::SetTask(IMediaImportTask* task)
+{
+  m_task = task;
+}
+
+bool CAddonMediaImporterExecutor::Execute(const std::string& options)
+{
+  m_currentProgress = 0;
+  m_currentTotal = 0;
+
+  return RunScript(options);
+}
+
+bool CAddonMediaImporterExecutor::ShouldCancel(unsigned int progress, unsigned int total)
+{
+  m_currentProgress = progress;
+  m_currentTotal = total;
+
+  if (m_task != nullptr)
+    return m_task->ShouldCancel(progress, total);
+
+  return false;
+}
+
+void CAddonMediaImporterExecutor::SetProgressStatus(const std::string& status)
+{
+  if (m_task != nullptr)
+    return m_task->SetProgressText(status);
+}
+
+bool CAddonMediaImporterExecutor::IsCancelled() const
+{
+  if (m_task != nullptr)
+    return m_task->ShouldCancel(m_currentProgress, m_currentTotal);
+
+  return false;
+}
+
+std::shared_ptr<ADDON::CMediaImporter> CAddonMediaImporterExecutor::GetAddon(
+    const std::string& addonId)
+{
+  ADDON::AddonPtr addon;
+  if (!CServiceBroker::GetAddonMgr().GetAddon(addonId, addon, ADDON::ADDON_MEDIAIMPORTER, true))
+    return nullptr;
+
+  return std::static_pointer_cast<ADDON::CMediaImporter>(addon);
+}
+
+std::shared_ptr<ADDON::CMediaImporter> CAddonMediaImporterExecutor::GetAddon() const
+{
+  return GetAddon(m_addonId);
+}
+
+CAddonMediaImporterExecutor* CAddonMediaImporterExecutor::GetExecutorFromHandle(
+    HandleType handle) throw(InvalidAddonMediaImporterHandleException)
+{
+  auto importer = GetScriptFromHandle(handle);
+  if (importer != nullptr)
+    return importer;
+
+  static Logger logger = CServiceBroker::GetLogging().GetLogger("CAddonMediaImporterExecutor");
+
+  logger->error("invalid script handle {:d}", handle);
+  throw InvalidAddonMediaImporterHandleException("handle: %d", handle);
+}
+
+bool CAddonMediaImporterExecutor::CheckAction(Action action) const
+    throw(InvalidAddonMediaImporterCallbackException)
+{
+  if (m_action == action)
+    return true;
+
+  m_logger->warn("callback for unexpected action received");
+  throw InvalidAddonMediaImporterCallbackException("add-on ID: %s", m_addonId.c_str());
+}
+
+void CAddonMediaImporterExecutor::SetSuccess(bool success, Action action)
+{
+  if (!CheckAction(action))
+    return;
+
+  m_success = success;
+}
+
+bool CAddonMediaImporterExecutor::RunScript(const std::string& options)
+{
+  const auto path = GetScriptPath(options);
+  if (path.empty())
+    return false;
+
+  auto addon = GetAddon();
+  if (addon == nullptr)
+  {
+    m_logger->error("failed to find media importer add-on");
+    return false;
+  }
+
+  // reset variables
+  m_success = false;
+
+  return CRunningScriptsHandler::RunScript(this, addon, path, false);
+}
+
+std::string CAddonMediaImporterExecutor::GetScriptPath(const std::string& options /* = "" */) const
+{
+  CURL addonPath;
+  addonPath.SetProtocol("addons");
+  addonPath.SetHostName(m_addonId);
+  addonPath.SetFileName(m_actionName);
+
+  if (!options.empty())
+    addonPath.SetOptions("?" + options);
+
+  return addonPath.Get();
+}
+
+std::string CAddonMediaImporterExecutor::ActionToString(Action action)
+{
+  switch (action)
+  {
+    case Action::DiscoverSource:
+      return "discoverprovider";
+    case Action::LookupSource:
+      return "lookupprovider";
+    case Action::CanImport:
+      return "canimport";
+    case Action::IsSourceReady:
+      return "isproviderready";
+    case Action::IsImportReady:
+      return "isimportready";
+    case Action::LoadSourceSettings:
+      return "loadprovidersettings";
+    case Action::UnloadSourceSettings:
+      return "loadimportsettings";
+    case Action::LoadImportSettings:
+      return "loadimportsettings";
+    case Action::UnloadImportSettings:
+      return "unloadimportsettings";
+    case Action::CanUpdateMetadataOnSource:
+      return "canupdatemetadataonprovider";
+    case Action::CanUpdatePlaycountOnSource:
+      return "canupdateplaycountonprovider";
+    case Action::CanUpdateLastPlayedOnSource:
+      return "canupdatelastplayedonprovider";
+    case Action::CanUpdateResumePositionOnSource:
+      return "canupdateresumepositiononprovider";
+    case Action::Import:
+      return "import";
+    case Action::UpdateOnSource:
+      return "updateonprovider";
+    case Action::SettingOptionsFiller:
+      return "settingoptionsfiller";
+    case Action::SettingActionCallback:
+      return "settingactioncallback";
+
+    default:
+      break;
+  }
+
+  return "unknown";
+}
diff --git a/xbmc/media/import/importers/AddonMediaImporterExecutor.h b/xbmc/media/import/importers/AddonMediaImporterExecutor.h
new file mode 100644
index 000000000000..9980b73def05
--- /dev/null
+++ b/xbmc/media/import/importers/AddonMediaImporterExecutor.h
@@ -0,0 +1,121 @@
+/*
+ *  Copyright (C) 2013-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "commons/Exception.h"
+#include "interfaces/generic/RunningScriptsHandler.h"
+#include "media/import/MediaImport.h"
+#include "media/import/MediaImportSource.h"
+#include "utils/logtypes.h"
+
+#include <map>
+#include <string>
+
+namespace ADDON
+{
+class CMediaImporter;
+}
+
+class CAddonMediaImporter;
+class IMediaImportTask;
+
+XBMCCOMMONS_STANDARD_EXCEPTION(InvalidAddonMediaImporterHandleException);
+XBMCCOMMONS_STANDARD_EXCEPTION(InvalidAddonMediaImporterCallbackException);
+
+class CAddonMediaImporterExecutor : public CRunningScriptsHandler<CAddonMediaImporterExecutor>
+{
+public:
+  enum class Action
+  {
+    NoAction,
+    DiscoverSource,
+    LookupSource,
+    CanImport,
+    IsSourceReady,
+    IsImportReady,
+    LoadSourceSettings,
+    UnloadSourceSettings,
+    LoadImportSettings,
+    UnloadImportSettings,
+    CanUpdateMetadataOnSource,
+    CanUpdatePlaycountOnSource,
+    CanUpdateLastPlayedOnSource,
+    CanUpdateResumePositionOnSource,
+    Import,
+    UpdateOnSource,
+    SettingOptionsFiller,
+    SettingActionCallback,
+  };
+
+  CAddonMediaImporterExecutor(const std::string& addonId,
+                              Action action,
+                              CAddonMediaImporter* importer = nullptr,
+                              const std::string& actionName = "");
+  virtual ~CAddonMediaImporterExecutor() = default;
+
+  const std::string& GetAddonId() const { return m_addonId; }
+
+  CAddonMediaImporter* GetImporter() const { return m_importer; }
+  void SetImporter(CAddonMediaImporter* importer) { m_importer = importer; }
+
+  MediaImportSourcePtr GetSource() const { return m_source; }
+  void SetSource(const CMediaImportSource& source);
+  void SetSource(MediaImportSourcePtr source);
+
+  MediaImportPtr GetImport() const { return m_import; }
+  void SetImport(const CMediaImport& import);
+  void SetImport(MediaImportPtr import);
+
+  IMediaImportTask* GetTask() const { return m_task; }
+  void SetTask(IMediaImportTask* task);
+
+  bool Execute(const std::string& options);
+
+  bool ShouldCancel(unsigned int progress, unsigned int total);
+  void SetProgressStatus(const std::string& status);
+
+protected:
+  friend class CAddonMediaImporterDiscoverer;
+  friend class CAddonMediaImporter;
+
+  // implementations of CRunningScriptsHandler / CScriptRunner
+  bool IsSuccessful() const override { return m_success; }
+  bool IsCancelled() const override;
+
+  static std::shared_ptr<ADDON::CMediaImporter> GetAddon(const std::string& addonId);
+
+  static CAddonMediaImporterExecutor* GetExecutorFromHandle(HandleType handle) throw(
+      InvalidAddonMediaImporterHandleException);
+  bool CheckAction(Action action) const throw(InvalidAddonMediaImporterCallbackException);
+  void SetSuccess(bool success, Action action);
+
+private:
+  std::shared_ptr<ADDON::CMediaImporter> GetAddon() const;
+
+  bool RunScript(const std::string& options);
+  std::string GetScriptPath(const std::string& options = "") const;
+
+  static std::string ActionToString(Action action);
+
+  const std::string m_addonId;
+  const Action m_action;
+  const std::string m_actionName;
+  CAddonMediaImporter* m_importer = nullptr;
+
+  bool m_started = false;
+  unsigned int m_currentProgress = 0;
+  unsigned int m_currentTotal = 0;
+  bool m_success = false;
+
+  MediaImportPtr m_import;
+  MediaImportSourcePtr m_source;
+  IMediaImportTask* m_task = nullptr;
+
+  Logger m_logger;
+};
diff --git a/xbmc/media/import/importers/CMakeLists.txt b/xbmc/media/import/importers/CMakeLists.txt
index d113c5e639e7..531ddeaa5f8b 100644
--- a/xbmc/media/import/importers/CMakeLists.txt
+++ b/xbmc/media/import/importers/CMakeLists.txt
@@ -1,5 +1,9 @@
-set(SOURCES BaseMediaImporter.cpp)
+set(SOURCES AddonMediaImporter.cpp
+            AddonMediaImporterExecutor.cpp
+            BaseMediaImporter.cpp)
 
-set(HEADERS BaseMediaImporter.h)
+set(HEADERS AddonMediaImporter.h
+            AddonMediaImporterExecutor.h
+            BaseMediaImporter.h)
 
 core_add_library(media_import_importers)

From c78e17ba92ca0841c263ef82af923eafa209a2b2 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 13 Oct 2019 00:38:44 +0200
Subject: [PATCH 77/88] [CAddonMediaImporter][interfaces/legacy] add and
 integrate xbmcmediaimport module to support importing media items from
 add-ons

---
 cmake/treedata/optional/common/python.txt     |   1 +
 xbmc/interfaces/legacy/CMakeLists.txt         |   2 +
 xbmc/interfaces/legacy/LanguageHook.h         |   9 +
 .../legacy/ModuleXbmcmediaimport.cpp          | 277 +++++++++++
 .../interfaces/legacy/ModuleXbmcmediaimport.h | 351 +++++++++++++
 .../legacy/mediaimport/CMakeLists.txt         |   5 +
 .../legacy/mediaimport/Exceptions.h           |  19 +
 .../legacy/mediaimport/MediaImport.cpp        | 119 +++++
 .../legacy/mediaimport/MediaImport.h          | 288 +++++++++++
 .../legacy/mediaimport/MediaProvider.cpp      | 183 +++++++
 .../legacy/mediaimport/MediaProvider.h        | 463 ++++++++++++++++++
 .../legacy/mediaimport/Observer.cpp           | 142 ++++++
 xbmc/interfaces/legacy/mediaimport/Observer.h | 216 ++++++++
 xbmc/interfaces/python/AddonPythonInvoker.cpp |   5 +-
 xbmc/interfaces/python/LanguageHook.cpp       |  13 +
 xbmc/interfaces/python/LanguageHook.h         |   4 +
 xbmc/interfaces/python/XBPython.cpp           | 126 +++++
 xbmc/interfaces/python/XBPython.h             |  25 +
 .../swig/AddonModuleXbmcmediaimport.i         |  48 ++
 xbmc/interfaces/swig/CMakeLists.txt           |   1 +
 20 files changed, 2296 insertions(+), 1 deletion(-)
 create mode 100644 xbmc/interfaces/legacy/ModuleXbmcmediaimport.cpp
 create mode 100644 xbmc/interfaces/legacy/ModuleXbmcmediaimport.h
 create mode 100644 xbmc/interfaces/legacy/mediaimport/CMakeLists.txt
 create mode 100644 xbmc/interfaces/legacy/mediaimport/Exceptions.h
 create mode 100644 xbmc/interfaces/legacy/mediaimport/MediaImport.cpp
 create mode 100644 xbmc/interfaces/legacy/mediaimport/MediaImport.h
 create mode 100644 xbmc/interfaces/legacy/mediaimport/MediaProvider.cpp
 create mode 100644 xbmc/interfaces/legacy/mediaimport/MediaProvider.h
 create mode 100644 xbmc/interfaces/legacy/mediaimport/Observer.cpp
 create mode 100644 xbmc/interfaces/legacy/mediaimport/Observer.h
 create mode 100644 xbmc/interfaces/swig/AddonModuleXbmcmediaimport.i

diff --git a/cmake/treedata/optional/common/python.txt b/cmake/treedata/optional/common/python.txt
index c381a186fa25..d1e0cc8bff3c 100644
--- a/cmake/treedata/optional/common/python.txt
+++ b/cmake/treedata/optional/common/python.txt
@@ -1,4 +1,5 @@
 xbmc/interfaces/legacy interfaces/legacy # PYTHON
+xbmc/interfaces/legacy/mediaimport interfaces/legacy/mediaimport # PYTHON
 xbmc/interfaces/legacy/wsgi interfaces/legacy/wsgi # PYTHON
 xbmc/interfaces/python interfaces/python # PYTHON
 xbmc/interfaces/swig swig # PYTHON
diff --git a/xbmc/interfaces/legacy/CMakeLists.txt b/xbmc/interfaces/legacy/CMakeLists.txt
index 1f2f56f8191d..3e747a7a86f5 100644
--- a/xbmc/interfaces/legacy/CMakeLists.txt
+++ b/xbmc/interfaces/legacy/CMakeLists.txt
@@ -16,6 +16,7 @@ set(SOURCES AddonCallback.cpp
             ListItem.cpp
             ModuleXbmc.cpp
             ModuleXbmcgui.cpp
+            ModuleXbmcmediaimport.cpp
             ModuleXbmcplugin.cpp
             ModuleXbmcvfs.cpp
             Monitor.cpp
@@ -52,6 +53,7 @@ set(HEADERS Addon.h
             ListItem.h
             ModuleXbmc.h
             ModuleXbmcgui.h
+            ModuleXbmcmediaimport.h
             ModuleXbmcplugin.h
             ModuleXbmcvfs.h
             Monitor.h
diff --git a/xbmc/interfaces/legacy/LanguageHook.h b/xbmc/interfaces/legacy/LanguageHook.h
index 86abdac1ed0d..b18afc13d3fb 100644
--- a/xbmc/interfaces/legacy/LanguageHook.h
+++ b/xbmc/interfaces/legacy/LanguageHook.h
@@ -26,6 +26,11 @@ namespace XBMCAddon
     class Monitor;
   }
 
+  namespace xbmcmediaimport
+  {
+  class Observer;
+  }
+
   class LanguageHook : public AddonClass
   {
   protected:
@@ -104,6 +109,10 @@ namespace XBMCAddon
     virtual void UnregisterPlayerCallback(IPlayerCallback* player) = 0;
     virtual void RegisterMonitorCallback(XBMCAddon::xbmc::Monitor* player) = 0;
     virtual void UnregisterMonitorCallback(XBMCAddon::xbmc::Monitor* player) = 0;
+    virtual void RegisterMediaImporterObserverCallback(
+        const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer) = 0;
+    virtual void UnregisterMediaImporterObserverCallback(
+        const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer) = 0;
     virtual bool WaitForEvent(CEvent& hEvent, unsigned int milliseconds) = 0;
 
     static void SetLanguageHook(LanguageHook* languageHook);
diff --git a/xbmc/interfaces/legacy/ModuleXbmcmediaimport.cpp b/xbmc/interfaces/legacy/ModuleXbmcmediaimport.cpp
new file mode 100644
index 000000000000..df9145dadd89
--- /dev/null
+++ b/xbmc/interfaces/legacy/ModuleXbmcmediaimport.cpp
@@ -0,0 +1,277 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "ModuleXbmcmediaimport.h"
+
+#include "ServiceBroker.h"
+#include "interfaces/legacy/LanguageHook.h"
+#include "media/import/MediaImportManager.h"
+#include "media/import/importers/AddonMediaImporter.h"
+
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+bool addProvider(const MediaProvider* provider)
+{
+  if (provider == nullptr)
+    return false;
+
+  const auto importerId =
+      CAddonMediaImporter::GetImporterId(LanguageHook::GetLanguageHook()->GetAddonId());
+  provider->source->SetImporterId(importerId);
+
+  return CServiceBroker::GetMediaImportManager().AddSource(*provider->source);
+}
+
+bool addAndActivateProvider(const MediaProvider* provider)
+{
+  if (provider == nullptr)
+    return false;
+
+  const auto importerId =
+      CAddonMediaImporter::GetImporterId(LanguageHook::GetLanguageHook()->GetAddonId());
+  provider->source->SetImporterId(importerId);
+
+  return CServiceBroker::GetMediaImportManager().AddAndActivateSource(*provider->source);
+}
+
+bool activateProvider(const MediaProvider* provider)
+{
+  if (provider == nullptr)
+    return false;
+
+  const auto importerId =
+      CAddonMediaImporter::GetImporterId(LanguageHook::GetLanguageHook()->GetAddonId());
+  provider->source->SetImporterId(importerId);
+
+  return CServiceBroker::GetMediaImportManager().ActivateSource(*provider->source);
+}
+
+void deactivateProvider(const String& providerId)
+{
+  return CServiceBroker::GetMediaImportManager().DeactivateSource(providerId);
+}
+
+bool updateProvider(const MediaProvider* provider)
+{
+  if (provider == nullptr)
+    return false;
+
+  CMediaImportManager& mediaImportManager = CServiceBroker::GetMediaImportManager();
+
+  auto updatedSource = provider->source;
+  CMediaImportSource source(updatedSource->GetIdentifier());
+  if (!mediaImportManager.GetSource(updatedSource->GetIdentifier(), source))
+    return false;
+
+  if (updatedSource->GetBasePath().empty())
+    source.SetBasePath(updatedSource->GetBasePath());
+  if (!updatedSource->GetFriendlyName().empty())
+    source.SetFriendlyName(updatedSource->GetFriendlyName());
+  if (!updatedSource->GetIconUrl().empty())
+    source.SetIconUrl(updatedSource->GetIconUrl());
+  if (!updatedSource->GetAvailableMediaTypes().empty())
+    source.SetAvailableMediaTypes(updatedSource->GetAvailableMediaTypes());
+
+  return mediaImportManager.UpdateSource(source);
+}
+
+void setDiscoveredProvider(int handle, bool providerDiscovered, const MediaProvider* mediaProvider)
+{
+  MediaImportSourcePtr source;
+  if (mediaProvider == nullptr)
+    providerDiscovered = false;
+  else
+    source = mediaProvider->source;
+
+  CAddonMediaImporter::SetDiscoveredProviderDetails(handle, providerDiscovered, source);
+}
+
+void setProviderFound(int handle, bool providerFound)
+{
+  CAddonMediaImporter::SetProviderFound(handle, providerFound);
+}
+
+void setCanImport(int handle, bool canImport)
+{
+  CAddonMediaImporter::SetCanImport(handle, canImport);
+}
+
+void setProviderReady(int handle, bool providerReady)
+{
+  CAddonMediaImporter::SetProviderReady(handle, providerReady);
+}
+
+void setImportReady(int handle, bool importReady)
+{
+  CAddonMediaImporter::SetImportReady(handle, importReady);
+}
+
+void setCanUpdateMetadataOnProvider(int handle, bool canUpdateMetadataOnProvider)
+{
+  CAddonMediaImporter::SetCanUpdateMetadataOnProvider(handle, canUpdateMetadataOnProvider);
+}
+
+void setCanUpdatePlaycountOnProvider(int handle, bool canUpdatePlaycountOnProvider)
+{
+  CAddonMediaImporter::SetCanUpdatePlaycountOnProvider(handle, canUpdatePlaycountOnProvider);
+}
+
+void setCanUpdateLastPlayedOnProvider(int handle, bool canUpdateLastPlayedOnProvider)
+{
+  CAddonMediaImporter::SetCanUpdateLastPlayedOnProvider(handle, canUpdateLastPlayedOnProvider);
+}
+
+void setCanUpdateResumePositionOnProvider(int handle, bool canUpdateResumePositionOnProvider)
+{
+  CAddonMediaImporter::SetCanUpdateResumePositionOnProvider(handle,
+                                                            canUpdateResumePositionOnProvider);
+}
+
+bool shouldCancel(int handle, unsigned int progress, unsigned int total)
+{
+  return CAddonMediaImporter::ShouldCancel(handle, progress, total);
+}
+
+void setProgressStatus(int handle, const String& status)
+{
+  CAddonMediaImporter::SetProgressStatus(handle, status);
+}
+
+MediaProvider* getProvider(int handle) throw(MediaImportException)
+{
+  auto mediaImporter = CAddonMediaImporter::GetImporter(handle);
+  auto mediaProvider = CAddonMediaImporter::GetMediaProvider(handle);
+  if (mediaImporter == nullptr || mediaProvider == nullptr)
+    throw MediaImportException("Invalid media provider handle");
+
+  return new MediaProvider(mediaProvider, mediaImporter->GetAddonId(), mediaImporter);
+}
+
+MediaImport* getImport(int handle) throw(MediaImportException)
+{
+  auto mediaImporter = CAddonMediaImporter::GetImporter(handle);
+  auto mediaImport = CAddonMediaImporter::GetMediaImport(handle);
+  if (mediaImporter == nullptr || mediaImport == nullptr)
+    throw MediaImportException("Invalid media import handle");
+
+  return new MediaImport(mediaImport, mediaImporter->GetAddonId(), mediaImporter);
+}
+
+std::vector<XBMCAddon::xbmcgui::ListItem*> getImportedItems(int handle, const String& mediaType)
+{
+  const auto items = CAddonMediaImporter::GetImportedItems(handle, mediaType);
+
+  std::vector<XBMCAddon::xbmcgui::ListItem*> importedItems;
+  for (const auto& item : items)
+    importedItems.push_back(new XBMCAddon::xbmcgui::ListItem(item));
+
+  return importedItems;
+}
+
+void addImportItem(int handle,
+                   const XBMCAddon::xbmcgui::ListItem* item,
+                   const String& mediaType,
+                   int changesetType /* = MediaImportChangesetTypeNone */)
+{
+  AddonClass::Ref<xbmcgui::ListItem> pItem(item);
+
+  CAddonMediaImporter::AddImportItem(handle, pItem->item, mediaType,
+                                     static_cast<MediaImportChangesetType>(changesetType));
+}
+
+void addImportItems(int handle,
+                    const std::vector<XBMCAddon::xbmcgui::ListItem*>& items,
+                    const String& mediaType,
+                    int changesetType /* = MediaImportChangesetTypeNone */)
+{
+  std::vector<CFileItemPtr> fileItems;
+  for (const auto& item : items)
+    fileItems.push_back(item->item);
+
+  CAddonMediaImporter::AddImportItems(handle, fileItems, mediaType,
+                                      static_cast<MediaImportChangesetType>(changesetType));
+}
+
+void finishImport(int handle, bool isChangeset /* = false */)
+{
+  CAddonMediaImporter::FinishImport(handle, isChangeset);
+}
+
+XBMCAddon::xbmcgui::ListItem* getUpdatedItem(int handle) throw(MediaImportException)
+{
+  auto item = CAddonMediaImporter::GetUpdatedItem(handle);
+  return new XBMCAddon::xbmcgui::ListItem(item);
+}
+
+void finishUpdateOnProvider(int handle)
+{
+  CAddonMediaImporter::FinishUpdateOnProvider(handle);
+}
+
+bool changeImportedItems(const MediaImport* import,
+                         const std::vector<ChangesetListItem>& changedItems)
+{
+  if (import == nullptr || import->import == nullptr)
+    return false;
+
+  ChangesetItems changesetItems;
+  for (const auto& changedItem : changedItems)
+  {
+    AddonClass::Ref<XBMCAddon::xbmcgui::ListItem> pChangedItem(changedItem.second());
+
+    changesetItems.emplace_back(static_cast<MediaImportChangesetType>(changedItem.first()),
+                                pChangedItem->item);
+  }
+
+  return CServiceBroker::GetMediaImportManager().ChangeImportedItems(*import->import,
+                                                                     changesetItems);
+}
+
+MediaProvider* getProviderById(const String& providerId)
+{
+  if (providerId.empty())
+    return nullptr;
+
+  CMediaImportSource mediaProvider(providerId);
+  if (!CServiceBroker::GetMediaImportManager().GetSource(providerId, mediaProvider))
+    return nullptr;
+
+  return new MediaProvider(mediaProvider);
+}
+
+std::vector<XBMCAddon::xbmcgui::ListItem*> getImportedItemsByProvider(const MediaProvider* provider)
+{
+  if (provider == nullptr || provider->source == nullptr)
+    return {};
+
+  const auto items =
+      CServiceBroker::GetMediaImportManager().GetImportedItemsBySource(*provider->source);
+  std::vector<XBMCAddon::xbmcgui::ListItem*> importedItems;
+  for (const auto& item : items)
+    importedItems.push_back(new XBMCAddon::xbmcgui::ListItem(item));
+
+  return importedItems;
+}
+
+std::vector<XBMCAddon::xbmcgui::ListItem*> getImportedItemsByImport(const MediaImport* import)
+{
+  if (import == nullptr || import->import == nullptr)
+    return {};
+
+  const auto items =
+      CServiceBroker::GetMediaImportManager().GetImportedItemsByImport(*import->import);
+  std::vector<XBMCAddon::xbmcgui::ListItem*> importedItems;
+  for (const auto& item : items)
+    importedItems.push_back(new XBMCAddon::xbmcgui::ListItem(item));
+
+  return importedItems;
+}
+} // namespace xbmcmediaimport
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/legacy/ModuleXbmcmediaimport.h b/xbmc/interfaces/legacy/ModuleXbmcmediaimport.h
new file mode 100644
index 000000000000..2b38ec69dffe
--- /dev/null
+++ b/xbmc/interfaces/legacy/ModuleXbmcmediaimport.h
@@ -0,0 +1,351 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AddonString.h"
+#include "ListItem.h"
+#include "Tuple.h"
+#include "media/MediaType.h"
+#include "media/import/MediaImportChangesetTypes.h"
+#include "mediaimport/MediaImport.h"
+#include "mediaimport/MediaProvider.h"
+#include "swighelper.h"
+
+#include <set>
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+XBMCCOMMONS_STANDARD_EXCEPTION(MediaImportException);
+
+#endif /* DOXYGEN_SHOULD_SKIP_THIS */
+
+//
+/// \defgroup python_xbmcmediaimport Library - xbmcmediaimport
+/// @{
+/// @brief <b>Media import functions on Kodi.</b>
+///
+/// Offers classes and functions that allow a developer to import media
+/// items from external sources into Kodi's media library.
+//
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+///
+/// \ingroup python_xbmcmediaimport
+/// @brief \python_func{ xbmcmediaimport.addProvider(provider) }
+///-------------------------------------------------------------------------
+/// Add a (new) media provider from which media imports can be imported.
+///
+/// @param provider             MediaProvider - Media provider to add.
+/// @return                     Returns a bool for successful completion.
+///
+/// ------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ..
+/// xbmcmediaimport.addProvider(provider)
+/// ..
+/// ~~~~~~~~~~~~~
+///
+addProvider(...);
+#else
+bool addProvider(const MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+///
+/// \ingroup python_xbmcmediaimport
+/// @brief \python_func{ xbmcmediaimport.addAndActivateProvider(provider) }
+///-------------------------------------------------------------------------
+/// Add a (new) a media provider from which media imports can be imported
+/// and activate it.
+///
+/// @param provider             MediaProvider - Media provider to add and activate.
+/// @return                     Returns a bool for successful completion.
+///
+/// ------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ..
+/// xbmcmediaimport.addAndActivateProvider(provider)
+/// ..
+/// ~~~~~~~~~~~~~
+///
+addAndActivateProvider(...);
+#else
+bool addAndActivateProvider(const MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+///
+/// \ingroup python_xbmcmediaimport
+/// @brief \python_func{ xbmcmediaimport.activateProvider(provider) }
+///-------------------------------------------------------------------------
+/// Activate a media provider from which media imports can be imported.
+///
+/// @param provider             MediaProvider - Media provider to activate.
+/// @return                     Returns a bool for successful completion.
+///
+/// ------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ..
+/// xbmcmediaimport.activateProvider(provider)
+/// ..
+/// ~~~~~~~~~~~~~
+///
+activateProvider(...);
+#else
+bool activateProvider(const MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+///
+/// \ingroup python_xbmcmediaimport
+/// @brief \python_func{ xbmcmediaimport.deactivateProvider(providerId) }
+///-------------------------------------------------------------------------
+/// Deactivate a media provider.
+///
+/// @param providerId           string - Unique identifier for the
+///                             media provider.
+///
+/// @note You can use the above as keywords for arguments and skip certain
+///       optional arguments. Once you use a keyword, all following arguments
+///       require the keyword.
+///
+///
+/// ------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ..
+/// xbmcmediaimport.deactivateProvider("kodi")
+/// ..
+/// ~~~~~~~~~~~~~
+///
+deactivateProvider(...);
+#else
+void deactivateProvider(const String& providerId);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+///
+/// \ingroup python_xbmcmediaimport
+/// @brief \python_func{ xbmcmediaimport.updateProvider(provider) }
+///-------------------------------------------------------------------------
+/// Updates the properties of a media provider.
+///
+/// @param provider             MediaProvider - Media provider to update.
+/// @return                     Returns a bool for successful completion.
+///
+/// ------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ..
+/// xbmcmediaimport.updateProvider(provider)
+/// ..
+/// ~~~~~~~~~~~~~
+///
+updateProvider(...);
+#else
+bool updateProvider(const MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setDiscoveredProvider(int handle, bool providerDiscovered, const MediaProvider* mediaProvider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setProviderFound(int handle, bool providerFound);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+///
+/// \ingroup python_xbmcmediaimport
+/// @brief \python_func{ xbmcmediaimport.setCanImport(handle, canImport) }
+///-------------------------------------------------------------------------
+/// TODO
+///
+/// @param handle               int - handle provided by the invocation
+///                             of the "canimport" action.
+/// @param canImport            bool - Whether or not the import for the
+///                             given handle can be imported or not.
+///
+/// ------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ..
+/// xbmcmediaimport.setCanImport(handle, True)
+/// ..
+/// ~~~~~~~~~~~~~
+///
+setCanImport(...);
+#else
+void setCanImport(int handle, bool canImport);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setProviderReady(int handle, bool providerReady);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setImportReady(int handle, bool importReady);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setCanUpdateMetadataOnProvider(int handle, bool canUpdateMetadataOnProvider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setCanUpdatePlaycountOnProvider(int handle, bool canUpdatePlaycountOnProvider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setCanUpdateLastPlayedOnProvider(int handle, bool canUpdateLastPlayedOnProvider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setCanUpdateResumePositionOnProvider(int handle, bool canUpdateResumePositionOnProvider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+bool shouldCancel(int handle, unsigned int progress, unsigned int total);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void setProgressStatus(int handle, const String& status);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+MediaProvider* getProvider(int handle) throw(MediaImportException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+MediaImport* getImport(int handle) throw(MediaImportException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+std::vector<XBMCAddon::xbmcgui::ListItem*> getImportedItems(int handle, const String& mediaType);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void addImportItem(int handle,
+                   const XBMCAddon::xbmcgui::ListItem* item,
+                   const String& mediaType,
+                   int changesetType = 0 /* MediaImportChangesetTypeNone */);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void addImportItems(int handle,
+                    const std::vector<XBMCAddon::xbmcgui::ListItem*>& items,
+                    const String& mediaType,
+                    int changesetType = 0 /* MediaImportChangesetTypeNone */);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void finishImport(int handle, bool isChangeset = false);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+XBMCAddon::xbmcgui::ListItem* getUpdatedItem(int handle) throw(MediaImportException);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+void finishUpdateOnProvider(int handle);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+typedef Tuple<int, XBMCAddon::xbmcgui::ListItem*> ChangesetListItem;
+
+bool changeImportedItems(const MediaImport* import,
+                         const std::vector<ChangesetListItem>& changedItems);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+MediaProvider* getProviderById(const String& providerId);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+std::vector<XBMCAddon::xbmcgui::ListItem*> getImportedItemsByProvider(
+    const MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+// TODO(Montellese)
+#else
+std::vector<XBMCAddon::xbmcgui::ListItem*> getImportedItemsByImport(const MediaImport* import);
+#endif
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+// media types
+SWIG_CONSTANT(String, MediaTypeNone);
+SWIG_CONSTANT(String, MediaTypeMovie);
+SWIG_CONSTANT(String, MediaTypeVideoCollection);
+SWIG_CONSTANT(String, MediaTypeMusicVideo);
+SWIG_CONSTANT(String, MediaTypeTvShow);
+SWIG_CONSTANT(String, MediaTypeSeason);
+SWIG_CONSTANT(String, MediaTypeEpisode);
+
+// changeset types
+SWIG_CONSTANT2(int, MediaImportChangesetTypeNone, static_cast<int>(MediaImportChangesetType::None));
+SWIG_CONSTANT2(int, MediaImportChangesetTypeAdded, static_cast<int>(MediaImportChangesetType::Added));
+SWIG_CONSTANT2(int, MediaImportChangesetTypeChanged, static_cast<int>(MediaImportChangesetType::Changed));
+SWIG_CONSTANT2(int, MediaImportChangesetTypeRemoved, static_cast<int>(MediaImportChangesetType::Removed));
+}
+}
+#endif /* DOXYGEN_SHOULD_SKIP_THIS */
diff --git a/xbmc/interfaces/legacy/mediaimport/CMakeLists.txt b/xbmc/interfaces/legacy/mediaimport/CMakeLists.txt
new file mode 100644
index 000000000000..bb7b026c33ca
--- /dev/null
+++ b/xbmc/interfaces/legacy/mediaimport/CMakeLists.txt
@@ -0,0 +1,5 @@
+set(SOURCES MediaImport.cpp MediaProvider.cpp Observer.cpp)
+
+    set(HEADERS Exceptions.h MediaImport.h MediaProvider.h Observer.h)
+
+        core_add_library(legacy_interface_mediaimport)
diff --git a/xbmc/interfaces/legacy/mediaimport/Exceptions.h b/xbmc/interfaces/legacy/mediaimport/Exceptions.h
new file mode 100644
index 000000000000..1a697c784447
--- /dev/null
+++ b/xbmc/interfaces/legacy/mediaimport/Exceptions.h
@@ -0,0 +1,19 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "interfaces/legacy/Exception.h"
+
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+XBMCCOMMONS_STANDARD_EXCEPTION(MissingLanguageHookException);
+}
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/legacy/mediaimport/MediaImport.cpp b/xbmc/interfaces/legacy/mediaimport/MediaImport.cpp
new file mode 100644
index 000000000000..05e38cf0d92e
--- /dev/null
+++ b/xbmc/interfaces/legacy/mediaimport/MediaImport.cpp
@@ -0,0 +1,119 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaImport.h"
+
+#include "interfaces/legacy/LanguageHook.h"
+#include "interfaces/legacy/mediaimport/Exceptions.h"
+#include "interfaces/legacy/mediaimport/MediaProvider.h"
+
+#include <memory>
+
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+#ifndef SWIG
+MediaImport::MediaImport(MediaImportPtr import,
+                         const std::string& addonId /* = "" */,
+                         CAddonMediaImporter* addonMediaImporter /* = nullptr */)
+  : import(import), m_addonId(addonId), m_addonMediaImporter(addonMediaImporter)
+{
+  if (m_addonId.empty())
+  {
+    if (languageHook != nullptr)
+      m_addonId = languageHook->GetAddonId();
+
+    if (m_addonId.empty())
+      throw MissingLanguageHookException("MediaImport");
+  }
+
+  m_callbackData.type = CAddonMediaImporter::SettingsCallbackData::Import;
+  m_callbackData.data.import = import.get();
+}
+
+MediaImport::MediaImport(const CMediaImport& import,
+                         const std::string& addonId /* = "" */,
+                         CAddonMediaImporter* addonMediaImporter /* = nullptr */)
+  : MediaImport(std::make_shared<CMediaImport>(import), addonId, addonMediaImporter)
+{
+}
+#endif
+
+MediaImport::MediaImport(const String& importPath)
+  : import(std::make_shared<CMediaImport>(importPath))
+{
+  if (languageHook != nullptr)
+    m_addonId = languageHook->GetAddonId();
+
+  if (m_addonId.empty())
+    throw MissingLanguageHookException("MediaImport");
+
+  import->SetRecursive(true);
+}
+
+String MediaImport::getPath() const
+{
+  return import->GetPath();
+}
+
+MediaProvider* MediaImport::getProvider() const
+{
+  return new MediaProvider(std::make_shared<CMediaImportSource>(import->GetSource()), m_addonId,
+                           m_addonMediaImporter);
+}
+
+void MediaImport::setProvider(const MediaProvider* provider)
+{
+  if (provider == nullptr)
+    return;
+
+  import->SetSource(*provider->source);
+}
+
+std::vector<String> MediaImport::getMediaTypes() const
+{
+  return import->GetMediaTypes();
+}
+
+void MediaImport::setMediaTypes(const std::vector<String>& mediaTypes)
+{
+  import->SetMediaTypes(mediaTypes);
+}
+
+String MediaImport::getLastSynced() const
+{
+  if (!import->GetLastSynced().IsValid())
+    return emptyString;
+
+  return import->GetLastSynced().GetAsW3CDateTime(true);
+}
+
+XBMCAddon::xbmcaddon::Settings* MediaImport::prepareSettings()
+{
+  auto settings = import->Settings();
+  if (CAddonMediaImporter::PrepareImportSettings(m_addonId, settings))
+    return createSettings(settings);
+
+  return nullptr;
+}
+
+XBMCAddon::xbmcaddon::Settings* MediaImport::getSettings()
+{
+  return createSettings(import->Settings());
+}
+
+XBMCAddon::xbmcaddon::Settings* MediaImport::createSettings(MediaImportSourceSettingsPtr settings)
+{
+  if (settings == nullptr)
+    return nullptr;
+
+  return new xbmcaddon::Settings(settings, m_addonId, m_addonMediaImporter, &m_callbackData);
+}
+} // namespace xbmcmediaimport
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/legacy/mediaimport/MediaImport.h b/xbmc/interfaces/legacy/mediaimport/MediaImport.h
new file mode 100644
index 000000000000..e78eb69de1d2
--- /dev/null
+++ b/xbmc/interfaces/legacy/mediaimport/MediaImport.h
@@ -0,0 +1,288 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "commons/Exception.h"
+#include "interfaces/legacy/AddonClass.h"
+#include "interfaces/legacy/AddonString.h"
+#include "interfaces/legacy/Settings.h"
+#include "media/import/MediaImport.h"
+#include "media/import/importers/AddonMediaImporter.h"
+
+#include <set>
+#include <string>
+
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+class MediaProvider;
+
+//
+/// \defgroup python_xbmcmediaimport_mediapimport MediaImport
+/// \ingroup python_xbmcmediaimport
+/// @{
+/// @brief **Media import**
+///
+/// A media import contains the necessary information to import media
+/// items from a specific path on a media provider.
+///
+/// \python_class{ MediaImport(importPath) }
+///
+/// @param importPath           string
+///
+///
+///-----------------------------------------------------------------------
+/// @python_v19
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ...
+/// mediaImport = xbmcmediaimport.MediaImport('kodi')
+/// ...
+/// ~~~~~~~~~~~~~
+class MediaImport : public AddonClass
+{
+public:
+#if !defined SWIG && !defined DOXYGEN_SHOULD_SKIP_THIS
+  MediaImportPtr import;
+#endif
+
+#ifndef SWIG
+  explicit MediaImport(MediaImportPtr import,
+                       const std::string& addonId = "",
+                       CAddonMediaImporter* addonMediaImporter = nullptr);
+  explicit MediaImport(const CMediaImport& import,
+                       const std::string& addonId = "",
+                       CAddonMediaImporter* addonMediaImporter = nullptr);
+#endif
+
+  MediaImport(const String& importPath);
+
+  virtual ~MediaImport() {}
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediapimport
+  /// @brief \python_func{ getPath() }
+  ///-----------------------------------------------------------------------
+  /// Returns the media import's path.
+  ///
+  /// @return  Path of the media import
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getPath()
+  /// importPath = mediaImport.getPath()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getPath();
+#else
+  String getPath() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediapimport
+  /// @brief \python_func{ getProvider() }
+  ///-----------------------------------------------------------------------
+  /// Returns the media provider the media import belongs to.
+  ///
+  /// @return  Media provider the media import belongs to
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getProvider()
+  /// mediaProvider = mediaImport.getProvider()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getProvider();
+#else
+  MediaProvider* getProvider() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediapimport
+  /// @brief \python_func{ setProvider(provider) }
+  ///-----------------------------------------------------------------------
+  /// Sets the media provider the media import belongs to.
+  ///
+  /// @param provider  Media provider the media import belongs to
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # setProvider(provider)
+  /// mediaImport.setProvider(mediaProvider)
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  setProvider(...);
+#else
+  void setProvider(const MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediapimport
+  /// @brief \python_func{ getMediaTypes() }
+  ///-----------------------------------------------------------------------
+  /// Returns the media import's media types.
+  ///
+  /// @return  Media import's media types
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getMediaTypes()
+  /// mediaTypes = mediaImport.getMediaTypes()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getMediaTypes();
+#else
+  std::vector<String> getMediaTypes() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediapimport
+  /// @brief \python_func{ setMediaTypes(mediaTypes) }
+  ///-----------------------------------------------------------------------
+  /// Sets the media import's media types
+  ///
+  /// @param mediaTypes  Media import's media types
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # setMediaTypes(mediaTypes)
+  /// mediaImport.setMediaTypes(mediaTypes)
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  setMediaTypes(...);
+#else
+  void setMediaTypes(const std::vector<String>& mediaTypes);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediapimport
+  /// @brief \python_func{ getLastSynced() }
+  ///-----------------------------------------------------------------------
+  /// Returns when the media import was last synchronized.
+  ///
+  /// @return Time when the media import was last synchronized
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getLastSynced()
+  /// lastSynced = mediaImport.getLastSynced()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getLastSynced();
+#else
+  String getLastSynced() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ prepareSettings() }
+  ///-----------------------------------------------------------------------
+  /// Prepares and returns the settings of the media import.
+  ///
+  /// @return Settings of the media import
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # prepareSettings()
+  /// settings = mediaImport.prepareSettings()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  prepareSettings();
+#else
+  XBMCAddon::xbmcaddon::Settings* prepareSettings();
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediapimport
+  /// @brief \python_func{ getSettings() }
+  ///-----------------------------------------------------------------------
+  /// Returns the settings of the media import.
+  ///
+  /// @return Settings of the media import
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getSettings()
+  /// settings = mediaProvider.getSettings()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getSettings();
+#else
+  XBMCAddon::xbmcaddon::Settings* getSettings();
+#endif
+
+#ifndef SWIG
+private:
+  XBMCAddon::xbmcaddon::Settings* createSettings(MediaImportSourceSettingsPtr settings);
+
+  std::string m_addonId;
+  CAddonMediaImporter* m_addonMediaImporter;
+  CAddonMediaImporter::SettingsCallbackData m_callbackData;
+#endif
+};
+} // namespace xbmcmediaimport
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/legacy/mediaimport/MediaProvider.cpp b/xbmc/interfaces/legacy/mediaimport/MediaProvider.cpp
new file mode 100644
index 000000000000..2400066a4a3c
--- /dev/null
+++ b/xbmc/interfaces/legacy/mediaimport/MediaProvider.cpp
@@ -0,0 +1,183 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MediaProvider.h"
+
+#include "ServiceBroker.h"
+#include "interfaces/legacy/LanguageHook.h"
+#include "interfaces/legacy/mediaimport/Exceptions.h"
+#include "interfaces/legacy/mediaimport/MediaImport.h"
+#include "media/import/MediaImportManager.h"
+
+#include <memory>
+
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+#ifndef SWIG
+MediaProvider::MediaProvider(const std::string& addonId /* = "" */,
+                             CAddonMediaImporter* addonMediaImporter /* = nullptr */)
+  : MediaProvider(std::make_shared<CMediaImportSource>(""), addonId, addonMediaImporter)
+{
+}
+
+MediaProvider::MediaProvider(MediaImportSourcePtr source,
+                             const std::string& addonId /* = "" */,
+                             CAddonMediaImporter* addonMediaImporter /* = nullptr */)
+  : source(source), m_addonId(addonId), m_addonMediaImporter(addonMediaImporter)
+{
+  if (m_addonId.empty())
+  {
+    if (languageHook != nullptr)
+      m_addonId = languageHook->GetAddonId();
+
+    if (m_addonId.empty())
+      throw MissingLanguageHookException("MediaProvider");
+  }
+
+  m_callbackData.type = CAddonMediaImporter::SettingsCallbackData::Source;
+  m_callbackData.data.source = source.get();
+}
+
+MediaProvider::MediaProvider(const CMediaImportSource& source,
+                             const std::string& addonId /* = "" */,
+                             CAddonMediaImporter* addonMediaImporter /* = nullptr */)
+  : MediaProvider(std::make_shared<CMediaImportSource>(source), addonId, addonMediaImporter)
+{
+}
+#endif
+
+MediaProvider::MediaProvider(const String& identifier,
+                             const String& basePath /* = emptyString */,
+                             const String& friendlyName /* = emptyString */,
+                             const String& iconUrl /* = emptyString */,
+                             const MediaTypes& mediaTypes /* = {} */,
+                             const String& lastSynced /* = emptyString */,
+                             int handle /* = -1 */)
+  : source(std::make_shared<CMediaImportSource>(
+        identifier, basePath, friendlyName, iconUrl, mediaTypes)),
+    m_addonMediaImporter(nullptr)
+{
+  if (languageHook != nullptr)
+    m_addonId = languageHook->GetAddonId();
+
+  if (m_addonId.empty())
+    throw MissingLanguageHookException("MediaProvider");
+
+  // properly set last synced
+  if (!lastSynced.empty())
+  {
+    CDateTime dtLastSynced;
+    dtLastSynced.SetFromDBDateTime(lastSynced);
+    if (dtLastSynced.IsValid())
+      source->SetLastSynced(dtLastSynced);
+  }
+
+  if (handle >= 0)
+  {
+    m_addonMediaImporter = CAddonMediaImporter::GetImporter(handle);
+    m_callbackData.type = CAddonMediaImporter::SettingsCallbackData::Source;
+    m_callbackData.data.source = source.get();
+  }
+}
+
+String MediaProvider::getIdentifier() const
+{
+  return source->GetIdentifier();
+}
+
+String MediaProvider::getBasePath() const
+{
+  return source->GetBasePath();
+}
+
+void MediaProvider::setBasePath(const String& basePath)
+{
+  source->SetBasePath(basePath);
+}
+
+String MediaProvider::getFriendlyName() const
+{
+  return source->GetFriendlyName();
+}
+
+void MediaProvider::setFriendlyName(const String& friendlyName)
+{
+  source->SetFriendlyName(friendlyName);
+}
+
+String MediaProvider::getIconUrl() const
+{
+  return source->GetIconUrl();
+}
+
+void MediaProvider::setIconUrl(const String& iconUrl)
+{
+  source->SetIconUrl(iconUrl);
+}
+
+MediaTypes MediaProvider::getAvailableMediaTypes() const
+{
+  return source->GetAvailableMediaTypes();
+}
+
+void MediaProvider::setAvailableMediaTypes(const MediaTypes& mediaTypes)
+{
+  source->SetAvailableMediaTypes(mediaTypes);
+}
+
+String MediaProvider::getLastSynced() const
+{
+  if (!source->GetLastSynced().IsValid())
+    return emptyString;
+
+  return source->GetLastSynced().GetAsW3CDateTime(true);
+}
+
+XBMCAddon::xbmcaddon::Settings* MediaProvider::prepareSettings()
+{
+  auto settings = source->Settings();
+  if (CAddonMediaImporter::PrepareProviderSettings(m_addonId, settings))
+    return createSettings(settings);
+
+  return nullptr;
+}
+
+XBMCAddon::xbmcaddon::Settings* MediaProvider::getSettings()
+{
+  return createSettings(source->Settings());
+}
+
+bool MediaProvider::isActive() const
+{
+  return source->IsActive();
+}
+
+std::vector<MediaImport*> MediaProvider::getImports() const
+{
+  const auto imports =
+      CServiceBroker::GetMediaImportManager().GetImportsBySource(source->GetIdentifier());
+
+  std::vector<MediaImport*> result;
+  for (const auto& import : imports)
+  {
+    result.push_back(new MediaImport(import, m_addonId, m_addonMediaImporter));
+  }
+  return result;
+}
+
+XBMCAddon::xbmcaddon::Settings* MediaProvider::createSettings(MediaImportSourceSettingsPtr settings)
+{
+  if (settings == nullptr)
+    return nullptr;
+
+  return new xbmcaddon::Settings(settings, m_addonId, m_addonMediaImporter, &m_callbackData);
+}
+} // namespace xbmcmediaimport
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/legacy/mediaimport/MediaProvider.h b/xbmc/interfaces/legacy/mediaimport/MediaProvider.h
new file mode 100644
index 000000000000..b9cba9cc35ad
--- /dev/null
+++ b/xbmc/interfaces/legacy/mediaimport/MediaProvider.h
@@ -0,0 +1,463 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "commons/Exception.h"
+#include "interfaces/legacy/AddonClass.h"
+#include "interfaces/legacy/AddonString.h"
+#include "interfaces/legacy/Settings.h"
+#include "media/import/MediaImportSource.h"
+#include "media/import/importers/AddonMediaImporter.h"
+
+#include <set>
+#include <string>
+
+#ifndef SWIG
+class CAddonMediaImporter;
+#endif
+
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+class MediaImport;
+
+typedef std::set<String> MediaTypes;
+
+//
+/// \defgroup python_xbmcmediaimport_mediaimport MediaProvider
+/// \ingroup python_xbmcmediaimport
+/// @{
+/// @brief **Media provider capable of importing media items from**
+///
+/// A media provider represents a source from which media items can be imported.
+///
+/// \python_class{ MediaProvider(identifier [, basePath, friendlyName, iconUrl, availableMediaTypes,
+/// lastSynced, settingValues]) }
+///
+/// @param identifier           string
+/// @param basePath             [opt] string
+/// @param friendlyName         [opt] string
+/// @param iconUrl              [opt] string
+/// @param availableMediaTypes  [opt] MediaTypes
+/// @param lastSynced           [opt] string
+///
+///
+///-----------------------------------------------------------------------
+/// @python_v19
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ...
+/// mediaProvider = xbmcmediaimport.MediaProvider('kodi')
+/// ...
+/// ~~~~~~~~~~~~~
+class MediaProvider : public AddonClass
+{
+public:
+#if !defined SWIG && !defined DOXYGEN_SHOULD_SKIP_THIS
+  MediaImportSourcePtr source;
+#endif
+
+#ifndef SWIG
+  explicit MediaProvider(const std::string& addonId = "",
+                         CAddonMediaImporter* addonMediaImporter = nullptr);
+  explicit MediaProvider(MediaImportSourcePtr source,
+                         const std::string& addonId = "",
+                         CAddonMediaImporter* addonMediaImporter = nullptr);
+  explicit MediaProvider(const CMediaImportSource& source,
+                         const std::string& addonId = "",
+                         CAddonMediaImporter* addonMediaImporter = nullptr);
+#endif
+
+  MediaProvider(const String& identifier,
+                const String& basePath = emptyString,
+                const String& friendlyName = emptyString,
+                const String& iconUrl = emptyString,
+                const MediaTypes& mediaTypes = {},
+                const String& lastSynced = emptyString,
+                int handle = -1);
+
+  virtual ~MediaProvider() {}
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ getIdentifier() }
+  ///-----------------------------------------------------------------------
+  /// Returns the media provider's identifier.
+  ///
+  /// @return  Identifier of the media provider
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # geIdentifier()
+  /// identifier = mediaProvider.getIdentifier()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getIdentifier();
+#else
+  String getIdentifier() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ getBasePath() }
+  ///-----------------------------------------------------------------------
+  /// Returns the media provider's base path.
+  ///
+  /// @return  Base path of the media provider
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getBasePath()
+  /// basePath = mediaProvider.getBasePath()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getBasePath();
+#else
+  String getBasePath() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ setBasePath(basePath) }
+  ///-----------------------------------------------------------------------
+  /// Sets the media provider's base path.
+  ///
+  /// @param basePath  string or unicode - base path of the media provider.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # setBasePath(basePath)
+  /// mediaProvider.setBasePath('http://localhost/')
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  setBasePath(...);
+#else
+  void setBasePath(const String& basePath);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ getFriendlyName() }
+  ///-----------------------------------------------------------------------
+  /// Returns the media provider's human readable name.
+  ///
+  /// @return  Human readable name of the media provider
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getFriendlyName()
+  /// name = mediaProvider.getFriendlyName()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getFriendlyName();
+#else
+  String getFriendlyName() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ setFriendlyName(friendlyName) }
+  ///-----------------------------------------------------------------------
+  /// Sets the media provider's human readable name.
+  ///
+  /// @param friendlyName  string or unicode - human readable name of the media provider.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # setFriendlyName(friendlyName)
+  /// mediaProvider.setFriendlyName('Kodi')
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  setFriendlyName(...);
+#else
+  void setFriendlyName(const String& friendlyName);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ getIconUrl() }
+  ///-----------------------------------------------------------------------
+  /// Returns the media provider's icon URL.
+  ///
+  /// @return Icon URL of the media provider
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getIconUrl()
+  /// iconUrl = mediaProvider.getIconUrl()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getIconUrl();
+#else
+  String getIconUrl() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ setIconUrl(iconUrl) }
+  ///-----------------------------------------------------------------------
+  /// Sets the media provider's icon URL.
+  ///
+  /// @param iconUrl  string or unicode - icon URL of the media provider.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # setIconUrl(iconUrl)
+  /// mediaProvider.setIconUrl('http://kodi/icon.png')
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  setIconUrl(...);
+#else
+  void setIconUrl(const String& iconUrl);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ getAvailableMediaTypes() }
+  ///-----------------------------------------------------------------------
+  /// Returns the media provider's available media types.
+  ///
+  /// @return Media types available from the media provider
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getAvailableMediaTypes()
+  /// mediaTypes = mediaProvider.getAvailableMediaTypes()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getAvailableMediaTypes();
+#else
+  MediaTypes getAvailableMediaTypes() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ setAvailableMediaTypes(mediaTypes) }
+  ///-----------------------------------------------------------------------
+  /// Sets the media provider's icon URL.
+  ///
+  /// @param mediaTypes  set - set of media types available from the media provider.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # setAvailableMediaTypes(mediaTypes)
+  /// mediaProvider.setAvailableMediaTypes('http://kodi/icon.png')
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  setAvailableMediaTypes(...);
+#else
+  void setAvailableMediaTypes(const MediaTypes& mediaTypes);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ getLastSynced() }
+  ///-----------------------------------------------------------------------
+  /// Returns when the media provider was last synchronized.
+  ///
+  /// @return Time when the media provider was last synchronized
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getLastSynced()
+  /// lastSynced = mediaProvider.getLastSynced()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getLastSynced();
+#else
+  String getLastSynced() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ prepareSettings() }
+  ///-----------------------------------------------------------------------
+  /// Prepares and returns the settings of the media provider.
+  ///
+  /// @return Settings of the media provider
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # prepareSettings()
+  /// settings = mediaProvider.prepareSettings()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  prepareSettings();
+#else
+  XBMCAddon::xbmcaddon::Settings* prepareSettings();
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ getSettings() }
+  ///-----------------------------------------------------------------------
+  /// Returns the settings of the media provider.
+  ///
+  /// @return Settings of the media provider
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getSettings()
+  /// settings = mediaProvider.getSettings()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getSettings();
+#else
+  XBMCAddon::xbmcaddon::Settings* getSettings();
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ isActive() }
+  ///-----------------------------------------------------------------------
+  /// Returns whether the media provider is active or not.
+  ///
+  /// @return True if the media provider is active otherwise false
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # isActive()
+  /// isActive = mediaProvider.isActive()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  isActive();
+#else
+  bool isActive() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_mediaimport
+  /// @brief \python_func{ getImports() }
+  ///-----------------------------------------------------------------------
+  /// Returns all media imports belonging to the provider.
+  ///
+  /// @return List of media imports belonging to the provider.
+  ///
+  ///
+  ///-----------------------------------------------------------------------
+  /// @python_v19
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.py}
+  /// ...
+  /// # getImports()
+  /// imports = mediaProvider.getImports()
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  getImports();
+#else
+  std::vector<MediaImport*> getImports() const;
+#endif
+
+#ifndef SWIG
+private:
+  XBMCAddon::xbmcaddon::Settings* createSettings(MediaImportSourceSettingsPtr settings);
+
+  std::string m_addonId;
+  CAddonMediaImporter* m_addonMediaImporter;
+  CAddonMediaImporter::SettingsCallbackData m_callbackData;
+#endif
+};
+} // namespace xbmcmediaimport
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/legacy/mediaimport/Observer.cpp b/xbmc/interfaces/legacy/mediaimport/Observer.cpp
new file mode 100644
index 000000000000..bcb156cd4c40
--- /dev/null
+++ b/xbmc/interfaces/legacy/mediaimport/Observer.cpp
@@ -0,0 +1,142 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "Observer.h"
+
+#include "interfaces/legacy/AddonUtils.h"
+#include "utils/log.h"
+
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+Observer::Observer()
+{
+  XBMC_TRACE;
+
+  // now that we're done register me in the system
+  if (languageHook)
+  {
+    m_importerId = languageHook->GetAddonId();
+    if (m_importerId.empty())
+      throw ObserverException("Invalid importer identification");
+    languageHook->RegisterMediaImporterObserverCallback(m_importerId, this);
+  }
+}
+
+Observer::~Observer()
+{
+  XBMC_TRACE;
+
+  deallocating();
+
+  // we're shutting down so unregister me
+  if (languageHook)
+  {
+    DelayedCallGuard dc(languageHook);
+    languageHook->UnregisterMediaImporterObserverCallback(m_importerId, this);
+  }
+}
+
+void Observer::OnSourceAdded(const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  invokeCallback(new CallbackFunction<Observer, MediaProvider*>(
+      this, &Observer::onProviderAdded, new MediaProvider(source, m_importerId)));
+}
+
+void Observer::OnSourceUpdated(const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  invokeCallback(new CallbackFunction<Observer, MediaProvider*>(
+      this, &Observer::onProviderUpdated, new MediaProvider(source, m_importerId)));
+}
+
+void Observer::OnSourceRemoved(const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  invokeCallback(new CallbackFunction<Observer, MediaProvider*>(
+      this, &Observer::onProviderRemoved, new MediaProvider(source, m_importerId)));
+}
+
+void Observer::OnSourceActivated(const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  invokeCallback(new CallbackFunction<Observer, MediaProvider*>(
+      this, &Observer::onProviderActivated, new MediaProvider(source, m_importerId)));
+}
+
+void Observer::OnSourceDeactivated(const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  invokeCallback(new CallbackFunction<Observer, MediaProvider*>(
+      this, &Observer::onProviderDeactivated, new MediaProvider(source, m_importerId)));
+}
+
+void Observer::OnImportAdded(const CMediaImport& import)
+{
+  XBMC_TRACE;
+  invokeCallback(new CallbackFunction<Observer, MediaImport*>(
+      this, &Observer::onImportAdded, new MediaImport(import, m_importerId)));
+}
+
+void Observer::OnImportUpdated(const CMediaImport& import)
+{
+  XBMC_TRACE;
+  invokeCallback(new CallbackFunction<Observer, MediaImport*>(
+      this, &Observer::onImportUpdated, new MediaImport(import, m_importerId)));
+}
+
+void Observer::OnImportRemoved(const CMediaImport& import)
+{
+  XBMC_TRACE;
+  invokeCallback(new CallbackFunction<Observer, MediaImport*>(
+      this, &Observer::onImportRemoved, new MediaImport(import, m_importerId)));
+}
+
+void Observer::onProviderAdded(MediaProvider* provider)
+{
+  XBMC_TRACE;
+}
+
+void Observer::onProviderUpdated(MediaProvider* provider)
+{
+  XBMC_TRACE;
+}
+
+void Observer::onProviderRemoved(MediaProvider* provider)
+{
+  XBMC_TRACE;
+}
+
+void Observer::onProviderActivated(MediaProvider* provider)
+{
+  XBMC_TRACE;
+}
+
+void Observer::onProviderDeactivated(MediaProvider* provider)
+{
+  XBMC_TRACE;
+}
+
+void Observer::onImportAdded(MediaImport* import)
+{
+  XBMC_TRACE;
+}
+
+void Observer::onImportUpdated(MediaImport* import)
+{
+  XBMC_TRACE;
+}
+
+void Observer::onImportRemoved(MediaImport* import)
+{
+  XBMC_TRACE;
+}
+} // namespace xbmcmediaimport
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/legacy/mediaimport/Observer.h b/xbmc/interfaces/legacy/mediaimport/Observer.h
new file mode 100644
index 000000000000..9c71386070d8
--- /dev/null
+++ b/xbmc/interfaces/legacy/mediaimport/Observer.h
@@ -0,0 +1,216 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "interfaces/legacy/AddonCallback.h"
+#include "interfaces/legacy/AddonString.h"
+#include "interfaces/legacy/Exception.h"
+#include "interfaces/legacy/mediaimport/MediaImport.h"
+#include "interfaces/legacy/mediaimport/MediaProvider.h"
+#include "interfaces/legacy/swighelper.h"
+#include "media/import/IMediaImporter.h"
+
+#include <vector>
+
+namespace XBMCAddon
+{
+namespace xbmcmediaimport
+{
+XBMCCOMMONS_STANDARD_EXCEPTION(ObserverException);
+
+//
+/// \defgroup python_xbmcmediaimport_observer Observer
+/// \ingroup python_xbmcmediaimport
+/// @{
+/// @brief TODO(Montellese)
+///
+/// \python_class{ xbmcmediaimport.Observer() }
+///
+/// TODO(Montellese)
+///
+///
+///
+///--------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.py}
+/// ...
+/// xbmcmediaimport.Observer()
+/// TODO(Montellese)
+/// ...
+/// ~~~~~~~~~~~~~
+//
+class Observer : public AddonCallback, public IMediaImporterObserver
+{
+public:
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+  // Construct an Observer proxying the given generated binding. The
+  //  construction of an Observer needs to identify whether or not any
+  //  callbacks will be executed asynchronously or not.
+  Observer();
+  ~Observer() override;
+#endif
+
+  //
+  /// @defgroup python_xbmcmediaimport_observer_ObserverCB Callback functions from Kodi to Add-On
+  /// \ingroup python_xbmcmediaimport_observer
+  /// @{
+  /// @brief **Callback functions.**
+  ///
+  /// Functions to handle control callbacks from Kodi to Add-On.
+  ///
+  /// ----------------------------------------------------------------------
+  ///
+  /// @link python_xbmcmediaimport_observer Go back to normal functions from observer@endlink
+  //
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_observer_ObserverCB
+  /// @brief \python_func{ onProviderAdded(provider) }
+  ///-----------------------------------------------------------------------
+  /// onProviderAdded method.
+  ///
+  /// Will be called when a new media provider has been added.
+  ///
+  /// @param provider               [MediaProvider] Media provider which has been added
+  ///
+  onProviderAdded(MediaProvider* provider);
+#else
+  virtual void onProviderAdded(MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_observer_ObserverCB
+  /// @brief \python_func{ onProviderUpdated(provider) }
+  ///-----------------------------------------------------------------------
+  /// onProviderUpdated method.
+  ///
+  /// Will be called when a media provider has been updated.
+  ///
+  /// @param provider               [MediaProvider] Media provider which has been updated
+  ///
+  onProviderUpdated(MediaProvider* provider);
+#else
+  virtual void onProviderUpdated(MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_observer_ObserverCB
+  /// @brief \python_func{ onProviderRemoved(provider) }
+  ///-----------------------------------------------------------------------
+  /// onProviderRemoved method.
+  ///
+  /// Will be called when a media provider has been removed.
+  ///
+  /// @param provider               [MediaProvider] Media provider which has been removed
+  ///
+  onProviderRemoved(MediaProvider* provider);
+#else
+  virtual void onProviderRemoved(MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_observer_ObserverCB
+  /// @brief \python_func{ onProviderActivated(provider) }
+  ///-----------------------------------------------------------------------
+  /// onProviderActivated method.
+  ///
+  /// Will be called when a media provider has been activated.
+  ///
+  /// @param provider               [MediaProvider] Media provider which has been activated
+  ///
+  onProviderActivated(MediaProvider* provider);
+#else
+  virtual void onProviderActivated(MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_observer_ObserverCB
+  /// @brief \python_func{ onProviderDeactivated(provider) }
+  ///-----------------------------------------------------------------------
+  /// onProviderDeactivated method.
+  ///
+  /// Will be called when a media provider has been deactivated.
+  ///
+  /// @param provider               [MediaProvider] Media provider which has been deactivated
+  ///
+  onProviderDeactivated(MediaProvider* provider);
+#else
+  virtual void onProviderDeactivated(MediaProvider* provider);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_observer_ObserverCB
+  /// @brief \python_func{ onImportAdded(import) }
+  ///-----------------------------------------------------------------------
+  /// onImportAdded method.
+  ///
+  /// Will be called when a new media import has been added.
+  ///
+  /// @param import               [MediaImport] Media import which has been added
+  ///
+  onImportAdded(MediaImport* import);
+#else
+  virtual void onImportAdded(MediaImport* import);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_observer_ObserverCB
+  /// @brief \python_func{ onImportUpdated(import) }
+  ///-----------------------------------------------------------------------
+  /// onImportUpdated method.
+  ///
+  /// Will be called when a media import has been updated.
+  ///
+  /// @param import               [MediaImport] Media import which has been updated
+  ///
+  onImportUpdated(MediaImport* import);
+#else
+  virtual void onImportUpdated(MediaImport* import);
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+  ///
+  /// \ingroup python_xbmcmediaimport_observer_ObserverCB
+  /// @brief \python_func{ onImportRemoved(import) }
+  ///-----------------------------------------------------------------------
+  /// onImportRemoved method.
+  ///
+  /// Will be called when a media import has been removed.
+  ///
+  /// @param import               [MediaImport] Media import which has been removed
+  ///
+  onImportRemoved(MediaImport* import);
+#else
+  virtual void onImportRemoved(MediaImport* import);
+#endif
+
+#if !defined SWIG && !defined DOXYGEN_SHOULD_SKIP_THIS
+  SWIGHIDDENVIRTUAL void OnSourceAdded(const CMediaImportSource& source) override;
+  SWIGHIDDENVIRTUAL void OnSourceUpdated(const CMediaImportSource& source) override;
+  SWIGHIDDENVIRTUAL void OnSourceRemoved(const CMediaImportSource& source) override;
+  SWIGHIDDENVIRTUAL void OnSourceActivated(const CMediaImportSource& source) override;
+  SWIGHIDDENVIRTUAL void OnSourceDeactivated(const CMediaImportSource& source) override;
+  SWIGHIDDENVIRTUAL void OnImportAdded(const CMediaImport& import) override;
+  SWIGHIDDENVIRTUAL void OnImportUpdated(const CMediaImport& import) override;
+  SWIGHIDDENVIRTUAL void OnImportRemoved(const CMediaImport& import) override;
+#endif
+
+private:
+  String m_importerId;
+};
+} // namespace xbmcmediaimport
+} // namespace XBMCAddon
diff --git a/xbmc/interfaces/python/AddonPythonInvoker.cpp b/xbmc/interfaces/python/AddonPythonInvoker.cpp
index 091a95a09dd9..9b9ddc760d1d 100644
--- a/xbmc/interfaces/python/AddonPythonInvoker.cpp
+++ b/xbmc/interfaces/python/AddonPythonInvoker.cpp
@@ -69,6 +69,7 @@ PyObject* PyInit_Module_xbmc(void);
 PyObject* PyInit_Module_xbmcplugin(void);
 PyObject* PyInit_Module_xbmcaddon(void);
 PyObject* PyInit_Module_xbmcvfs(void);
+PyObject* PyInit_Module_xbmcmediaimport(void);
 }
 
 using namespace PythonBindings;
@@ -86,7 +87,8 @@ static PythonModule PythonModules[] =
     { "xbmc",       PyInit_Module_xbmc       },
     { "xbmcplugin", PyInit_Module_xbmcplugin },
     { "xbmcaddon",  PyInit_Module_xbmcaddon  },
-    { "xbmcvfs",    PyInit_Module_xbmcvfs    }
+    { "xbmcvfs",    PyInit_Module_xbmcvfs    },
+    { "xbmcmediaimport", PyInit_Module_xbmcmediaimport },
   };
 
 CAddonPythonInvoker::CAddonPythonInvoker(ILanguageInvocationHandler *invocationHandler)
@@ -98,6 +100,7 @@ CAddonPythonInvoker::CAddonPythonInvoker(ILanguageInvocationHandler *invocationH
   PyImport_AppendInittab("xbmcplugin", PyInit_Module_xbmcplugin);
   PyImport_AppendInittab("xbmcaddon", PyInit_Module_xbmcaddon);
   PyImport_AppendInittab("xbmcvfs", PyInit_Module_xbmcvfs);
+  PyImport_AppendInittab("xbmcmediaimport", PyInit_Module_xbmcmediaimport);
 }
 
 CAddonPythonInvoker::~CAddonPythonInvoker() = default;
diff --git a/xbmc/interfaces/python/LanguageHook.cpp b/xbmc/interfaces/python/LanguageHook.cpp
index 1fc4b03017e9..83946bc5e644 100644
--- a/xbmc/interfaces/python/LanguageHook.cpp
+++ b/xbmc/interfaces/python/LanguageHook.cpp
@@ -181,6 +181,19 @@ namespace XBMCAddon
       CServiceBroker::GetXBPython().UnregisterPythonMonitorCallBack(monitor);
     }
 
+    void PythonLanguageHook::RegisterMediaImporterObserverCallback(
+        const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer)
+    {
+      XBMC_TRACE;
+      CServiceBroker::GetXBPython().RegisterPythonMediaImporterObserverCallback(importerId, observer);
+    }
+    void PythonLanguageHook::UnregisterMediaImporterObserverCallback(
+        const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer)
+    {
+      XBMC_TRACE;
+      CServiceBroker::GetXBPython().UnregisterPythonMediaImporterObserverCallback(importerId, observer);
+    }
+
     bool PythonLanguageHook::WaitForEvent(CEvent& hEvent, unsigned int milliseconds)
     {
       XBMC_TRACE;
diff --git a/xbmc/interfaces/python/LanguageHook.h b/xbmc/interfaces/python/LanguageHook.h
index 1e2ad61ee1b8..2a8f0cac7f07 100644
--- a/xbmc/interfaces/python/LanguageHook.h
+++ b/xbmc/interfaces/python/LanguageHook.h
@@ -67,6 +67,10 @@ namespace XBMCAddon
       void UnregisterPlayerCallback(IPlayerCallback* player) override;
       void RegisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) override;
       void UnregisterMonitorCallback(XBMCAddon::xbmc::Monitor* monitor) override;
+      void RegisterMediaImporterObserverCallback(
+          const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer) override;
+      void UnregisterMediaImporterObserverCallback(
+          const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer) override;
       bool WaitForEvent(CEvent& hEvent, unsigned int milliseconds) override;
 
       static AddonClass::Ref<PythonLanguageHook> GetIfExists(PyInterpreterState* interp);
diff --git a/xbmc/interfaces/python/XBPython.cpp b/xbmc/interfaces/python/XBPython.cpp
index 199e5254eb45..8474dd4cb980 100644
--- a/xbmc/interfaces/python/XBPython.cpp
+++ b/xbmc/interfaces/python/XBPython.cpp
@@ -31,6 +31,7 @@
 
 #include "interfaces/legacy/Monitor.h"
 #include "interfaces/legacy/AddonUtils.h"
+#include "interfaces/legacy/mediaimport/Observer.h"
 #include "interfaces/python/AddonPythonInvoker.h"
 #include "interfaces/python/PythonInvoker.h"
 #include "ServiceBroker.h"
@@ -46,6 +47,7 @@ XBPython::XBPython()
   m_pDll              = NULL;
   m_vecPlayerCallbackList.clear();
   m_vecMonitorCallbackList.clear();
+  m_mapMediaImporterObserverCallbackList.clear();
 
   CServiceBroker::GetAnnouncementManager()->AddAnnouncer(this);
 }
@@ -409,6 +411,130 @@ void XBPython::OnNotification(const std::string &sender, const std::string &meth
   }
 }
 
+void XBPython::RegisterPythonMediaImporterObserverCallback(
+    const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer)
+{
+  XBMC_TRACE;
+  CSingleLock lock(m_mapMediaImporterObserverCallbackList);
+  m_mapMediaImporterObserverCallbackList.emplace(importerId, observer);
+}
+
+void XBPython::UnregisterPythonMediaImporterObserverCallback(
+    const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer)
+{
+  XBMC_TRACE;
+  CSingleLock lock(m_mapMediaImporterObserverCallbackList);
+  if (m_mapMediaImporterObserverCallbackList.erase(importerId) > 0)
+    m_mapMediaImporterObserverCallbackList.hadSomethingRemoved = true;
+}
+
+// this is necessary because we can't pass a type containing a comma as a single argument to a macro
+#define XBMC_SINGLE_ARG(...) __VA_ARGS__
+
+void XBPython::OnSourceAdded(const std::string& addonId, const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(
+      XBMC_SINGLE_ARG(std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>), tmp,
+      m_mapMediaImporterObserverCallbackList);
+  for (auto& it : tmp)
+  {
+    if (CHECK_FOR_ENTRY(m_mapMediaImporterObserverCallbackList, it) && it.first == addonId)
+      it.second->OnSourceAdded(source);
+  }
+}
+
+void XBPython::OnSourceUpdated(const std::string& addonId, const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(
+      XBMC_SINGLE_ARG(std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>), tmp,
+      m_mapMediaImporterObserverCallbackList);
+  for (auto& it : tmp)
+  {
+    if (CHECK_FOR_ENTRY(m_mapMediaImporterObserverCallbackList, it) && it.first == addonId)
+      it.second->OnSourceUpdated(source);
+  }
+}
+
+void XBPython::OnSourceRemoved(const std::string& addonId, const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(
+      XBMC_SINGLE_ARG(std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>), tmp,
+      m_mapMediaImporterObserverCallbackList);
+  for (auto& it : tmp)
+  {
+    if (CHECK_FOR_ENTRY(m_mapMediaImporterObserverCallbackList, it) && it.first == addonId)
+      it.second->OnSourceRemoved(source);
+  }
+}
+
+void XBPython::OnSourceActivated(const std::string& addonId, const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(
+      XBMC_SINGLE_ARG(std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>), tmp,
+      m_mapMediaImporterObserverCallbackList);
+  for (auto& it : tmp)
+  {
+    if (CHECK_FOR_ENTRY(m_mapMediaImporterObserverCallbackList, it) && it.first == addonId)
+      it.second->OnSourceActivated(source);
+  }
+}
+
+void XBPython::OnSourceDeactivated(const std::string& addonId, const CMediaImportSource& source)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(
+      XBMC_SINGLE_ARG(std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>), tmp,
+      m_mapMediaImporterObserverCallbackList);
+  for (auto& it : tmp)
+  {
+    if (CHECK_FOR_ENTRY(m_mapMediaImporterObserverCallbackList, it) && it.first == addonId)
+      it.second->OnSourceDeactivated(source);
+  }
+}
+
+void XBPython::OnImportAdded(const std::string& addonId, const CMediaImport& import)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(
+      XBMC_SINGLE_ARG(std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>), tmp,
+      m_mapMediaImporterObserverCallbackList);
+  for (auto& it : tmp)
+  {
+    if (CHECK_FOR_ENTRY(m_mapMediaImporterObserverCallbackList, it) && it.first == addonId)
+      it.second->OnImportAdded(import);
+  }
+}
+
+void XBPython::OnImportUpdated(const std::string& addonId, const CMediaImport& import)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(
+      XBMC_SINGLE_ARG(std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>), tmp,
+      m_mapMediaImporterObserverCallbackList);
+  for (auto& it : tmp)
+  {
+    if (CHECK_FOR_ENTRY(m_mapMediaImporterObserverCallbackList, it) && it.first == addonId)
+      it.second->OnImportUpdated(import);
+  }
+}
+
+void XBPython::OnImportRemoved(const std::string& addonId, const CMediaImport& import)
+{
+  XBMC_TRACE;
+  LOCK_AND_COPY(
+      XBMC_SINGLE_ARG(std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>), tmp,
+      m_mapMediaImporterObserverCallbackList);
+  for (auto& it : tmp)
+  {
+    if (CHECK_FOR_ENTRY(m_mapMediaImporterObserverCallbackList, it) && it.first == addonId)
+      it.second->OnImportRemoved(import);
+  }
+}
+
 void XBPython::RegisterExtensionLib(LibraryLoader *pLib)
 {
   if (!pLib)
diff --git a/xbmc/interfaces/python/XBPython.h b/xbmc/interfaces/python/XBPython.h
index ff4d93990fd0..a39306e1ba80 100644
--- a/xbmc/interfaces/python/XBPython.h
+++ b/xbmc/interfaces/python/XBPython.h
@@ -16,8 +16,12 @@
 #include "threads/Thread.h"
 
 #include <memory>
+#include <unordered_map>
 #include <vector>
 
+
+class CMediaImport;
+class CMediaImportSource;
 class CPythonInvoker;
 class CVariant;
 
@@ -35,6 +39,11 @@ namespace XBMCAddon
   {
     class Monitor;
   }
+
+  namespace xbmcmediaimport
+  {
+  class Observer;
+  }
 }
 
 template <class T> struct LockableType : public T, public CCriticalSection
@@ -42,6 +51,8 @@ template <class T> struct LockableType : public T, public CCriticalSection
 
 typedef LockableType<std::vector<void*> > PlayerCallbackList;
 typedef LockableType<std::vector<XBMCAddon::xbmc::Monitor*> > MonitorCallbackList;
+typedef LockableType<std::unordered_map<std::string, XBMCAddon::xbmcmediaimport::Observer*>>
+    MediaImporterObserverCallbackList;
 typedef LockableType<std::vector<PyElem> > PyList;
 typedef std::vector<LibraryLoader*> PythonExtensionLibraries;
 
@@ -82,6 +93,19 @@ class XBPython :
   void OnCleanFinished(const std::string &library);
   void OnNotification(const std::string &sender, const std::string &method, const std::string &data);
 
+  void RegisterPythonMediaImporterObserverCallback(const std::string& importerId,
+                                                   XBMCAddon::xbmcmediaimport::Observer* observer);
+  void UnregisterPythonMediaImporterObserverCallback(
+      const std::string& importerId, XBMCAddon::xbmcmediaimport::Observer* observer);
+  void OnSourceAdded(const std::string& addonId, const CMediaImportSource& source);
+  void OnSourceUpdated(const std::string& addonId, const CMediaImportSource& source);
+  void OnSourceRemoved(const std::string& addonId, const CMediaImportSource& source);
+  void OnSourceActivated(const std::string& addonId, const CMediaImportSource& source);
+  void OnSourceDeactivated(const std::string& addonId, const CMediaImportSource& source);
+  void OnImportAdded(const std::string& addonId, const CMediaImport& import);
+  void OnImportUpdated(const std::string& addonId, const CMediaImport& import);
+  void OnImportRemoved(const std::string& addonId, const CMediaImport& import);
+
   void Process() override;
   void PulseGlobalEvent() override;
   void Uninitialize() override;
@@ -111,6 +135,7 @@ class XBPython :
   PyList              m_vecPyList;
   PlayerCallbackList  m_vecPlayerCallbackList;
   MonitorCallbackList m_vecMonitorCallbackList;
+  MediaImporterObserverCallbackList m_mapMediaImporterObserverCallbackList;
   LibraryLoader*      m_pDll;
 
   // any global events that scripts should be using
diff --git a/xbmc/interfaces/swig/AddonModuleXbmcmediaimport.i b/xbmc/interfaces/swig/AddonModuleXbmcmediaimport.i
new file mode 100644
index 000000000000..c3842d216cdb
--- /dev/null
+++ b/xbmc/interfaces/swig/AddonModuleXbmcmediaimport.i
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (C) 2017-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+%module xbmcmediaimport
+
+%begin %{
+#if defined(TARGET_WINDOWS) || defined(TARGET_WIN10)
+#  if !defined(WIN32_LEAN_AND_MEAN)
+#    define WIN32_LEAN_AND_MEAN
+#  endif
+#  include <windows.h>
+#endif
+
+#include "interfaces/legacy/ModuleXbmcmediaimport.h"
+#include "interfaces/legacy/mediaimport/Exceptions.h"
+#include "interfaces/legacy/mediaimport/MediaImport.h"
+#include "interfaces/legacy/mediaimport/MediaProvider.h"
+#include "interfaces/legacy/mediaimport/Observer.h"
+
+using namespace XBMCAddon;
+using namespace xbmcmediaimport;
+
+#if defined(__GNUG__) && (__GNUC__>4) || (__GNUC__==4 && __GNUC_MINOR__>=2)
+#pragma GCC diagnostic ignored "-Wstrict-aliasing"
+#endif
+
+%}
+
+// This is all about warning suppression. It's OK that these base classes are 
+// not part of what swig parses.
+%feature("knownbasetypes") XBMCAddon::xbmcaddon "AddonClass"
+%feature("knownapitypes") XBMCAddon::xbmcmediaimport "XBMCAddon::xbmcaddon::Settings,XBMCAddon::xbmcgui::ListItem"
+
+%feature("director") Observer;
+
+%include "interfaces/legacy/swighelper.h"
+%include "interfaces/legacy/AddonString.h"
+%include "interfaces/legacy/ModuleXbmcmediaimport.h"
+%include "interfaces/legacy/mediaimport/Exceptions.h"
+%include "interfaces/legacy/mediaimport/MediaImport.h"
+%include "interfaces/legacy/mediaimport/MediaProvider.h"
+%include "interfaces/legacy/mediaimport/Observer.h"
+
diff --git a/xbmc/interfaces/swig/CMakeLists.txt b/xbmc/interfaces/swig/CMakeLists.txt
index 3abe31a3f5d0..c51c56e9ffe4 100644
--- a/xbmc/interfaces/swig/CMakeLists.txt
+++ b/xbmc/interfaces/swig/CMakeLists.txt
@@ -32,6 +32,7 @@ set(INPUTS AddonModuleXbmcaddon.i
            AddonModuleXbmcdrm.i
            AddonModuleXbmcgui.i
            AddonModuleXbmc.i
+           AddonModuleXbmcmediaimport.i
            AddonModuleXbmcplugin.i
            AddonModuleXbmcvfs.i
            AddonModuleXbmcwsgi.i)

From d66696df12b16e463db1f54c39679f07f58e0bde Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 7 Jan 2020 23:13:16 +0100
Subject: [PATCH 78/88] [CAddonMediaImporter][legacy/ListItem] add
 getMediaProviderId() and getMediaImportPath()

---
 xbmc/interfaces/legacy/ListItem.cpp | 10 ++++++++
 xbmc/interfaces/legacy/ListItem.h   | 36 +++++++++++++++++++++++++++++
 2 files changed, 46 insertions(+)

diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index 47db8603e4fa..0a1caaf12e13 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -868,5 +868,15 @@ namespace XBMCAddon
     {
       return item->GetVideoInfoTag();
     }
+
+    String ListItem::getMediaProviderId() const
+    {
+      return item->GetSource();
+    }
+
+    String ListItem::getMediaImportPath() const
+    {
+      return item->GetImportPath();
+    }
   }
 }
diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index e5682c4b2ad9..5120f83d79dd 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -1174,6 +1174,42 @@ namespace XBMCAddon
       xbmc::InfoTagMusic* getMusicInfoTag();
 #endif
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcgui_listitem
+      /// @brief \python_func{ getMediaProviderId() }
+      ///-----------------------------------------------------------------------
+      /// Returns the identifier of the media provider this item was imported from.
+      ///
+      /// @return    media provider identifer
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      /// @python_v19 New function added.
+      ///
+      getMediaProviderId();
+#else
+      String getMediaProviderId() const;
+#endif
+
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_xbmcgui_listitem
+      /// @brief \python_func{ getMediaImportPath() }
+      ///-----------------------------------------------------------------------
+      /// Returns the path of the media import this item was imported from.
+      ///
+      /// @return    media import path
+      ///
+      ///
+      ///-----------------------------------------------------------------------
+      /// @python_v19 New function added.
+      ///
+      getMediaImportPath();
+#else
+      String getMediaImportPath() const;
+#endif
+
 private:
       std::vector<std::string> getStringArray(const InfoLabelValue& alt, const std::string& tag, std::string value = "");
 

From d9b8fa94673a6bfd2851229e01ddab6c3f26c4ef Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 13 Oct 2019 00:39:57 +0200
Subject: [PATCH 79/88] [CAddonMediaImporter] fully integrate
 CMediaImportAddonManager

---
 xbmc/Application.cpp    |  2 ++
 xbmc/ServiceBroker.cpp  |  5 +++++
 xbmc/ServiceBroker.h    |  2 ++
 xbmc/ServiceManager.cpp | 11 ++++++++++-
 xbmc/ServiceManager.h   |  3 +++
 5 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index a019be50aa89..26f4ca632ee9 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -18,6 +18,7 @@
 #include "PlayListPlayer.h"
 #include "URL.h"
 #include "Util.h"
+#include "addons/MediaImporter.h"
 #include "addons/Skin.h"
 #include "addons/VFSEntry.h"
 #include "cores/AudioEngine/Engines/ActiveAE/ActiveAE.h"
@@ -2642,6 +2643,7 @@ void CApplication::Stop(int exitCode)
     m_ExitCode = exitCode;
     CLog::Log(LOGINFO, "Stopping all");
 
+    CServiceBroker::GetMediaImportAddons().Stop();
     CServiceBroker::GetMediaImportManager().Uninitialize();
 
     // cancel any jobs from the jobmanager
diff --git a/xbmc/ServiceBroker.cpp b/xbmc/ServiceBroker.cpp
index b322c078d65a..468275760c82 100644
--- a/xbmc/ServiceBroker.cpp
+++ b/xbmc/ServiceBroker.cpp
@@ -137,6 +137,11 @@ CMediaImportManager& CServiceBroker::GetMediaImportManager()
   return g_application.m_ServiceManager->GetMediaImportManager();
 }
 
+ADDON::CMediaImportAddonManager& CServiceBroker::GetMediaImportAddons()
+{
+  return g_application.m_ServiceManager->GetMediaImportAddons();
+}
+
 PERIPHERALS::CPeripherals& CServiceBroker::GetPeripherals()
 {
   return g_application.m_ServiceManager->GetPeripherals();
diff --git a/xbmc/ServiceBroker.h b/xbmc/ServiceBroker.h
index d99a90b76cec..e577e0fe8b3b 100644
--- a/xbmc/ServiceBroker.h
+++ b/xbmc/ServiceBroker.h
@@ -16,6 +16,7 @@ namespace ADDON {
 class CAddonMgr;
 class CBinaryAddonManager;
 class CBinaryAddonCache;
+class CMediaImportAddonManager;
 class CVFSAddonCache;
 class CServiceAddonManager;
 class CRepositoryUpdater;
@@ -105,6 +106,7 @@ class CServiceBroker
   static KODI::GAME::CGameServices& GetGameServices();
   static KODI::RETRO::CGUIGameRenderManager& GetGameRenderManager();
   static CMediaImportManager& GetMediaImportManager();
+  static ADDON::CMediaImportAddonManager& GetMediaImportAddons();
   static PERIPHERALS::CPeripherals& GetPeripherals();
   static CFavouritesService& GetFavouritesService();
   static ADDON::CServiceAddonManager& GetServiceAddons();
diff --git a/xbmc/ServiceManager.cpp b/xbmc/ServiceManager.cpp
index 8c8efffd5b2b..1c13728b961c 100644
--- a/xbmc/ServiceManager.cpp
+++ b/xbmc/ServiceManager.cpp
@@ -12,6 +12,7 @@
 #include "DatabaseManager.h"
 #include "PlayListPlayer.h"
 #include "addons/BinaryAddonCache.h"
+#include "addons/MediaImporter.h"
 #include "addons/RepositoryUpdater.h"
 #include "addons/VFSEntry.h"
 #include "addons/binary-addons/BinaryAddonManager.h"
@@ -140,6 +141,7 @@ bool CServiceManager::InitStageTwo(const CAppParamParser &params, const std::str
   m_fileExtensionProvider.reset(new CFileExtensionProvider(*m_addonMgr));
 
   m_mediaImportManager.reset(new CMediaImportManager());
+  m_mediaImportAddons.reset(new ADDON::CMediaImportAddonManager(*m_addonMgr));
 
   m_powerManager.reset(new CPowerManager());
   m_powerManager->Initialize();
@@ -174,6 +176,7 @@ bool CServiceManager::InitStageThree(const std::shared_ptr<CProfileManager>& pro
   m_playerCoreFactory.reset(new CPlayerCoreFactory(*profileManager));
 
   m_mediaImportManager->Initialize();
+  m_mediaImportAddons->Start();
 
   init_level = 3;
   return true;
@@ -216,6 +219,8 @@ void CServiceManager::DeinitStageTwo()
 
   m_mediaManager->Stop();
   m_mediaManager.reset();
+  m_mediaImportAddons.reset();
+  m_mediaImportManager.reset();
 }
 
 void CServiceManager::DeinitStageOne()
@@ -228,7 +233,6 @@ void CServiceManager::DeinitStageOne()
   CScriptInvocationManager::GetInstance().UnregisterLanguageInvocationHandler(m_XBPython.get());
   m_XBPython.reset();
 #endif
-  m_mediaImportManager.reset();
 }
 
 ADDON::CAddonMgr &CServiceManager::GetAddonMgr()
@@ -261,6 +265,11 @@ ADDON::CRepositoryUpdater &CServiceManager::GetRepositoryUpdater()
   return *m_repositoryUpdater;
 }
 
+ADDON::CMediaImportAddonManager &CServiceManager::GetMediaImportAddons()
+{
+  return *m_mediaImportAddons;
+}
+
 #ifdef HAS_PYTHON
 XBPython& CServiceManager::GetXBPython()
 {
diff --git a/xbmc/ServiceManager.h b/xbmc/ServiceManager.h
index 0062f3ce64f0..5310f7b07098 100644
--- a/xbmc/ServiceManager.h
+++ b/xbmc/ServiceManager.h
@@ -22,6 +22,7 @@ namespace ADDON
   class CVFSAddonCache;
   class CServiceAddonManager;
   class CRepositoryUpdater;
+  class CMediaImportAddonManager;
 }
 
 namespace PVR
@@ -94,6 +95,7 @@ class CServiceManager
   ADDON::CVFSAddonCache& GetVFSAddonCache();
   ADDON::CServiceAddonManager& GetServiceAddons();
   ADDON::CRepositoryUpdater& GetRepositoryUpdater();
+  ADDON::CMediaImportAddonManager& GetMediaImportAddons();
   CNetworkBase& GetNetwork();
 #ifdef HAS_PYTHON
   XBPython& GetXBPython();
@@ -150,6 +152,7 @@ class CServiceManager
   std::unique_ptr<ADDON::CVFSAddonCache> m_vfsAddonCache;
   std::unique_ptr<ADDON::CServiceAddonManager> m_serviceAddons;
   std::unique_ptr<ADDON::CRepositoryUpdater> m_repositoryUpdater;
+  std::unique_ptr<ADDON::CMediaImportAddonManager> m_mediaImportAddons;
 #ifdef HAS_PYTHON
   std::unique_ptr<XBPython> m_XBPython;
 #endif

From a234d31a7cb7929631554a6ebd5db1c3f7159d6f Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Fri, 17 Jan 2020 14:56:06 +0100
Subject: [PATCH 80/88] [WIP][CAddonMediaImporter][IPlayer] add overload for
 AddSubtitle() which also takes its name and language

---
 xbmc/ApplicationPlayer.cpp             |  8 +++++
 xbmc/ApplicationPlayer.h               |  2 ++
 xbmc/cores/IPlayer.h                   |  2 ++
 xbmc/cores/VideoPlayer/IVideoPlayer.h  |  8 +++++
 xbmc/cores/VideoPlayer/VideoPlayer.cpp | 46 +++++++++++++++++++++-----
 xbmc/cores/VideoPlayer/VideoPlayer.h   |  5 ++-
 6 files changed, 61 insertions(+), 10 deletions(-)

diff --git a/xbmc/ApplicationPlayer.cpp b/xbmc/ApplicationPlayer.cpp
index af0008f31460..aae759824a81 100644
--- a/xbmc/ApplicationPlayer.cpp
+++ b/xbmc/ApplicationPlayer.cpp
@@ -716,6 +716,14 @@ void CApplicationPlayer::AddSubtitle(const std::string& strSubPath)
     player->AddSubtitle(strSubPath);
 }
 
+void CApplicationPlayer::AddSubtitle(const std::string& strSubPath, const std::string& name,
+  const std::string& language, bool activate /* = true */)
+{
+  std::shared_ptr<IPlayer> player = GetInternal();
+  if (player)
+    player->AddSubtitle(strSubPath, name, language, activate);
+}
+
 void CApplicationPlayer::SetSubTitleDelay(float fValue)
 {
   std::shared_ptr<IPlayer> player = GetInternal();
diff --git a/xbmc/ApplicationPlayer.h b/xbmc/ApplicationPlayer.h
index 8c103827a6b8..397ba8005478 100644
--- a/xbmc/ApplicationPlayer.h
+++ b/xbmc/ApplicationPlayer.h
@@ -70,6 +70,8 @@ class CApplicationPlayer
 
   // proxy calls
   void AddSubtitle(const std::string& strSubPath);
+  void AddSubtitle(const std::string& strSubPath, const std::string& name,
+    const std::string& language, bool activate = true);
   bool CanPause();
   bool CanSeek();
   void DoAudioWork();
diff --git a/xbmc/cores/IPlayer.h b/xbmc/cores/IPlayer.h
index efe3e3407f8b..4a0918f18d01 100644
--- a/xbmc/cores/IPlayer.h
+++ b/xbmc/cores/IPlayer.h
@@ -127,6 +127,8 @@ class IPlayer
   *   \param[in] strSubPath The full path of the subtitle file.
   */
   virtual void  AddSubtitle(const std::string& strSubPath) {};
+  virtual void  AddSubtitle(const std::string& strSubPath, const std::string& name,
+    const std::string& language, bool activate = true) {};
 
   virtual int  GetAudioStreamCount()  { return 0; }
   virtual int  GetAudioStream()       { return -1; }
diff --git a/xbmc/cores/VideoPlayer/IVideoPlayer.h b/xbmc/cores/VideoPlayer/IVideoPlayer.h
index d8130fce5222..56ad440a1526 100644
--- a/xbmc/cores/VideoPlayer/IVideoPlayer.h
+++ b/xbmc/cores/VideoPlayer/IVideoPlayer.h
@@ -69,6 +69,14 @@ struct SStateMsg
   int player;
 };
 
+struct SSubtitleMsg
+{
+  std::string path;
+  std::string name;
+  std::string language;
+  bool activate;
+};
+
 class CDVDVideoCodec;
 
 class IDVDStreamPlayerVideo : public IDVDStreamPlayer
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index c00d388abba1..d72ecf299fb1 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -58,6 +58,7 @@
 #include "storage/MediaManager.h"
 #include "dialogs/GUIDialogKaiToast.h"
 #include "utils/JobManager.h"
+#include "utils/LangCodeExpander.h"
 #include "utils/StringUtils.h"
 #include "video/Bookmark.h"
 #include "video/VideoInfoTag.h"
@@ -2905,8 +2906,9 @@ void CVideoPlayer::HandleMessages()
     }
     else if (pMsg->IsType(CDVDMsg::SUBTITLE_ADDFILE))
     {
-      int id = AddSubtitleFile(static_cast<CDVDMsgType<std::string>*>(pMsg)->m_value);
-      if (id >= 0)
+      const auto subtitleMsg = static_cast<CDVDMsgType<SSubtitleMsg>*>(pMsg)->m_value;
+      int id = AddSubtitleFile(subtitleMsg.path, "", subtitleMsg.name, subtitleMsg.language);
+      if (id >= 0 && subtitleMsg.activate)
       {
         SetSubtitle(id);
         SetSubtitleVisibleInternal(true);
@@ -4425,7 +4427,18 @@ int64_t CVideoPlayer::GetChapterPos(int chapterIdx)
 
 void CVideoPlayer::AddSubtitle(const std::string& strSubPath)
 {
-  m_messenger.Put(new CDVDMsgType<std::string>(CDVDMsg::SUBTITLE_ADDFILE, strSubPath));
+  AddSubtitle(strSubPath, "", "", true);
+}
+
+void CVideoPlayer::AddSubtitle(const std::string& strSubPath, const std::string& name,
+  const std::string& language, bool activate /* = true */)
+{
+  SSubtitleMsg msg;
+  msg.path = strSubPath;
+  msg.name = name;
+  msg.language = language;
+  msg.activate = activate;
+  m_messenger.Put(new CDVDMsgType<SSubtitleMsg>(CDVDMsg::SUBTITLE_ADDFILE, msg));
 }
 
 bool CVideoPlayer::IsCaching() const
@@ -4447,7 +4460,8 @@ double CVideoPlayer::GetQueueTime()
   return std::max(a, v) * 8000.0 / 100;
 }
 
-int CVideoPlayer::AddSubtitleFile(const std::string& filename, const std::string& subfilename)
+int CVideoPlayer::AddSubtitleFile(const std::string& filename, const std::string& subfilename,
+  const std::string& name, const std::string& language)
 {
   std::string ext = URIUtils::GetExtension(filename);
   std::string vobsubfile = subfilename;
@@ -4504,11 +4518,25 @@ int CVideoPlayer::AddSubtitleFile(const std::string& filename, const std::string
   s.type     = STREAM_SUBTITLE;
   s.id       = 0;
   s.filename = filename;
-  ExternalStreamInfo info = CUtil::GetExternalStreamDetailsFromFilename(m_item.GetDynPath(), filename);
-  s.name = info.name;
-  s.language = info.language;
-  if (static_cast<StreamFlags>(info.flag) != StreamFlags::FLAG_NONE)
-    s.flags = static_cast<StreamFlags>(info.flag);
+  s.name = name;
+
+  if (!language.empty())
+  {
+    std::string langCode;
+    if (g_LangCodeExpander.ConvertToISO6392B(language, langCode))
+      s.language = langCode;
+  }
+
+  if (s.name.empty() || s.language.empty())
+  {
+    ExternalStreamInfo info = CUtil::GetExternalStreamDetailsFromFilename(m_item.GetDynPath(), filename);
+    if (s.name.empty())
+      s.name = info.name;
+    if (s.language.empty())
+      s.language = info.language;
+    if (static_cast<StreamFlags>(info.flag) != StreamFlags::FLAG_NONE)
+      s.flags = static_cast<StreamFlags>(info.flag);
+  }
 
   m_SelectionStreams.Update(s);
   UpdateContent();
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.h b/xbmc/cores/VideoPlayer/VideoPlayer.h
index 8661a172c137..c49ef497c8e0 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.h
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.h
@@ -269,6 +269,8 @@ class CVideoPlayer : public IPlayer, public CThread, public IVideoPlayer,
   bool GetSubtitleVisible() override;
   void SetSubtitleVisible(bool bVisible) override;
   void AddSubtitle(const std::string& strSubPath) override;
+  void AddSubtitle(const std::string& strSubPath, const std::string& name,
+    const std::string& language, bool activate = true) override;
 
   int GetAudioStreamCount() override;
   int GetAudioStream() override;
@@ -378,7 +380,8 @@ class CVideoPlayer : public IPlayer, public CThread, public IVideoPlayer,
   void ProcessTeletextData(CDemuxStream* pStream, DemuxPacket* pPacket);
   void ProcessRadioRDSData(CDemuxStream* pStream, DemuxPacket* pPacket);
 
-  int  AddSubtitleFile(const std::string& filename, const std::string& subfilename = "");
+  int  AddSubtitleFile(const std::string& filename, const std::string& subfilename = "",
+    const std::string& name = "", const std::string& language = "");
   void SetSubtitleVisibleInternal(bool bVisible);
 
   /**

From 8982c6fcfb8f53b16ba3e8aef86fe32137fbb4f2 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Fri, 17 Jan 2020 14:56:38 +0100
Subject: [PATCH 81/88] [WIP][CAddonMediaImporter][interfaces/legacy] add
 Player.addSubtitle(file, name, language, activate)

---
 xbmc/interfaces/legacy/Player.cpp | 13 +++++++++++++
 xbmc/interfaces/legacy/Player.h   | 18 ++++++++++++++++++
 2 files changed, 31 insertions(+)

diff --git a/xbmc/interfaces/legacy/Player.cpp b/xbmc/interfaces/legacy/Player.cpp
index 1fb2b189a312..d3e8a61533de 100644
--- a/xbmc/interfaces/legacy/Player.cpp
+++ b/xbmc/interfaces/legacy/Player.cpp
@@ -436,6 +436,19 @@ namespace XBMCAddon
       g_application.SeekTime( pTime );
     }
 
+    void Player::addSubtitle(const char* subtitleFile, const char* name, const char* language,
+      bool activate /* = true */)
+    {
+      XBMC_TRACE;
+      if (subtitleFile == nullptr || name == nullptr || language == nullptr)
+        return;
+
+      if (g_application.GetAppPlayer().HasPlayer())
+      {
+        g_application.GetAppPlayer().AddSubtitle(subtitleFile, name, language, activate);
+      }
+    }
+
     void Player::setSubtitles(const char* cLine)
     {
       XBMC_TRACE;
diff --git a/xbmc/interfaces/legacy/Player.h b/xbmc/interfaces/legacy/Player.h
index 3e1fa3e8e42a..764e195d545e 100644
--- a/xbmc/interfaces/legacy/Player.h
+++ b/xbmc/interfaces/legacy/Player.h
@@ -508,6 +508,24 @@ namespace XBMCAddon
       void seekTime(double seekTime);
 #endif
 
+#ifdef DOXYGEN_SHOULD_USE_THIS
+      ///
+      /// \ingroup python_Player
+      /// @brief \python_func{ addSubtitle(subtitleFile, name, language, activate) }
+      ///-----------------------------------------------------------------------
+      /// Add subtitle file with name and language and optionally activate it.
+      ///
+      /// @param subtitleFile        File to use as source ofsubtitles
+      /// @param name                Name of the subtitle to display
+      /// @param language            Language of the subtitlte to use
+      /// @param activate            Whether or not to activate the subtitle
+      ///
+      addSubtitle(...);
+#else
+      void addSubtitle(const char* subtitleFile, const char* name, const char* language,
+        bool activate = true);
+#endif
+
 #ifdef DOXYGEN_SHOULD_USE_THIS
       ///
       /// \ingroup python_Player

From 8933877733bac1455f0055cc544dd198cef3d08b Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sat, 8 Oct 2016 23:23:24 +0200
Subject: [PATCH 82/88] [TEMP][estuary] add "Media source" entry to settings
 overview

---
 addons/resource.language.en_gb/resources/strings.po | 5 ++++-
 addons/skin.estuary/xml/Settings.xml                | 5 +++++
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index cb0c51777f71..75be952ecec3 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -3411,7 +3411,10 @@ msgctxt "#752"
 msgid "Opacity"
 msgstr ""
 
-#empty string with id 753
+#: addons/skin.estuary/xml/Settings.xml
+msgctxt "#753"
+msgid "Media sources"
+msgstr ""
 
 msgctxt "#754"
 msgid "Add program link"
diff --git a/addons/skin.estuary/xml/Settings.xml b/addons/skin.estuary/xml/Settings.xml
index 18ad10234b8f..46933bffa3c0 100644
--- a/addons/skin.estuary/xml/Settings.xml
+++ b/addons/skin.estuary/xml/Settings.xml
@@ -80,6 +80,11 @@
 						<onclick>ActivateWindow(MediaSettings)</onclick>
 						<icon>icons/settings/media.png</icon>
 					</item>
+					<item>
+						<label>$LOCALIZE[753]</label>
+						<onclick>ActivateWindow(MediaSourceBrowser)</onclick>
+						<icon>icons/settings/mediasources.png</icon>
+					</item>
 					<item>
 						<label>$LOCALIZE[14204]</label>
 						<onclick>ActivateWindow(PVRSettings)</onclick>

From f95d70ef0ed5750c8c7a1de33248a009c99c1ea7 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 9 Oct 2016 00:23:53 +0200
Subject: [PATCH 83/88] [WIP][estuary] add MediaSourceBrowser.xml

---
 .../resources/strings.po                      |  1 +
 .../skin.estuary/xml/MediaSourceBrowser.xml   | 35 +++++++++++++++++++
 addons/skin.estuary/xml/View_55_WideList.xml  |  2 +-
 3 files changed, 37 insertions(+), 1 deletion(-)
 create mode 100644 addons/skin.estuary/xml/MediaSourceBrowser.xml

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 75be952ecec3..b0cc9894a431 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -3412,6 +3412,7 @@ msgid "Opacity"
 msgstr ""
 
 #: addons/skin.estuary/xml/Settings.xml
+#: addons/skin.estuary/xml/MediaSourceBrowser.xml
 msgctxt "#753"
 msgid "Media sources"
 msgstr ""
diff --git a/addons/skin.estuary/xml/MediaSourceBrowser.xml b/addons/skin.estuary/xml/MediaSourceBrowser.xml
new file mode 100644
index 000000000000..2fc65e826f73
--- /dev/null
+++ b/addons/skin.estuary/xml/MediaSourceBrowser.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<window>
+	<defaultcontrol always="true">50</defaultcontrol>
+	<backgroundcolor>background</backgroundcolor>
+	<views>50,55</views>
+	<menucontrol>9000</menucontrol>
+	<controls>
+		<include>DefaultBackground</include>
+		<control type="group">
+			<animation effect="fade" start="100" end="0" time="200" tween="sine" condition="$EXP[infodialog_active]">Conditional</animation>
+			<include>View_50_List</include>
+			<include>View_55_WideList</include>
+			<include>CommonScrollbars</include>
+			<control type="group">
+				<include>OpenClose_Left</include>
+				<visible>Control.IsVisible(55)</visible>
+				<include>Visible_Left</include>
+				<include>ListThumbInfoPanel</include>
+			</control>
+			<include content="TopBar">
+				<param name="breadcrumbs_label" value="$LOCALIZE[753]" />
+			</include>
+			<include content="BottomBar"></include>
+			<include>MediaMenuMouseOverlay</include>
+			<control type="group">
+				<include>MediaMenuCommon</include>
+				<control type="grouplist" id="9000">
+					<top>50</top>
+					<include>MediaMenuListCommon</include>
+					<include>MediaMenuNowPlaying</include>
+				</control>
+			</control>
+		</control>
+	</controls>
+</window>
diff --git a/addons/skin.estuary/xml/View_55_WideList.xml b/addons/skin.estuary/xml/View_55_WideList.xml
index d67bac561189..b24403e16c3c 100644
--- a/addons/skin.estuary/xml/View_55_WideList.xml
+++ b/addons/skin.estuary/xml/View_55_WideList.xml
@@ -20,7 +20,7 @@
 				<onup>55</onup>
 				<ondown>55</ondown>
 				<viewtype label="$LOCALIZE[31107]">list</viewtype>
-				<focusedlayout height="list_item_height" condition="Container.Content(tvshows) | Container.Content(seasons) | Container.Content(episodes) | Container.Content(movies) | Container.Content(musicvideos) | Container.Content(videos) | Container.Content(games) | Window.IsActive(videoplaylist) | Window.IsActive(musicplaylist)">
+				<focusedlayout height="list_item_height" condition="Container.Content(tvshows) | Container.Content(seasons) | Container.Content(episodes) | Container.Content(movies) | Container.Content(musicvideos) | Container.Content(videos) | Container.Content(games) | Container.Content(sources) | Container.Content(imports) | Window.IsActive(videoplaylist) | Window.IsActive(musicplaylist)">
 					<control type="image">
 						<left>0</left>
 						<right>0</right>

From bf7826962903d8b706b67fb5f31f89eedeb1db94 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 9 Oct 2016 02:24:21 +0200
Subject: [PATCH 84/88] [WIP][estuary] add DialogMediaImportInfo.xml

---
 .../resources/strings.po                      |  27 +-
 .../xml/DialogMediaImportInfo.xml             | 254 ++++++++++++++++++
 2 files changed, 280 insertions(+), 1 deletion(-)
 create mode 100644 addons/skin.estuary/xml/DialogMediaImportInfo.xml

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index b0cc9894a431..e90a8c253a51 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -22479,4 +22479,29 @@ msgctxt "#39701"
 msgid "Media import information"
 msgstr ""
 
-#strings from 39702 to 39799 are reserved for media import GUI info
+#: addons/skin.estuary/xml/DialogMediaImportInfo.xml
+msgctxt "#39702"
+msgid "Provider"
+msgstr ""
+
+#: addons/skin.estuary/xml/DialogMediaImportInfo.xml
+msgctxt "#39703"
+msgid "Media type"
+msgstr ""
+
+#: addons/skin.estuary/xml/DialogMediaImportInfo.xml
+msgctxt "#39704"
+msgid "Status"
+msgstr ""
+
+#: addons/skin.estuary/xml/DialogMediaImportInfo.xml
+msgctxt "#39705"
+msgid "Last synced"
+msgstr ""
+
+#: addons/skin.estuary/xml/DialogMediaImportInfo.xml
+msgctxt "#39706"
+msgid "Available media types"
+msgstr ""
+
+#strings from 39707 to 39799 are reserved for media import GUI info
diff --git a/addons/skin.estuary/xml/DialogMediaImportInfo.xml b/addons/skin.estuary/xml/DialogMediaImportInfo.xml
new file mode 100644
index 000000000000..55c5106ce4b4
--- /dev/null
+++ b/addons/skin.estuary/xml/DialogMediaImportInfo.xml
@@ -0,0 +1,254 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<window>
+	<defaultcontrol always="true">28</defaultcontrol>
+	<include>Animation_DialogPopupOpenClose</include>
+	<controls>
+		<control type="group">
+			<centertop>50%</centertop>
+			<height>900</height>
+			<centerleft>50%</centerleft>
+			<width>1820</width>
+			<include content="DialogBackgroundCommons">
+				<param name="width" value="1820" />
+				<param name="height" value="900" />
+				<param name="header_label" value="" />
+				<param name="header_id" value="20" />
+			</include>
+			<!-- Icon -->
+			<control type="group">
+				<left>20</left>
+				<top>70</top>
+				<control type="image">
+					<width>388</width>
+					<height>388</height>
+					<texture background="true">$INFO[ListItem.Icon]</texture>
+					<aspectratio>scale</aspectratio>
+					<bordertexture border="20">overlays/shadow.png</bordertexture>
+					<bordersize>20</bordersize>
+				</control>
+			</control>
+			<!-- Details -->
+			<control type="group">
+				<left>400</left>
+				<top>70</top>
+				<control type="image">
+					<width>1100</width>
+					<height>388</height>
+					<texture border="40">buttons/dialogbutton-nofo.png</texture>
+				</control>
+				<!-- Title -->
+				<control type="group">
+					<left>40</left>
+					<top>20</top>
+					<control type="label">
+						<width>1020</width>
+						<height>65</height>
+						<align>left</align>
+						<aligny>center</aligny>
+						<font>font12_title</font>
+						<textcolor>white</textcolor>
+						<label>[B]$INFO[ListItem.Property(Import.Name)][/B]</label>
+						<scroll>true</scroll>
+						<visible>!IsEmpty(ListItem.Property(Import.Path))</visible>
+					</control>
+					<control type="label">
+						<width>1020</width>
+						<height>65</height>
+						<align>left</align>
+						<aligny>center</aligny>
+						<font>font12_title</font>
+						<textcolor>white</textcolor>
+						<label>[B]$INFO[ListItem.Property(Source.Name)][/B]</label>
+						<scroll>true</scroll>
+						<visible>IsEmpty(ListItem.Property(Import.Path))</visible>
+					</control>
+				</control>
+				<!-- Metadata -->
+				<control type="grouplist">
+					<left>40</left>
+					<top>85</top>
+					<height>220</height>
+					<orientation>vertical</orientation>
+					<itemgap>-8</itemgap>
+					<control type="button" id="147">
+						<width>1020</width>
+						<height>49</height>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textoffsetx>0</textoffsetx>
+						<font>font12</font>
+						<texturefocus />
+						<texturenofocus />
+						<onclick>noop</onclick>
+						<label>[COLOR button_focus]$LOCALIZE[39702]: [/COLOR]$INFO[ListItem.Property(Source.Name)]</label>
+						<visible>!IsEmpty(ListItem.Property(Import.Path)) + !String.IsEmpty(ListItem.Property(Source.Name))</visible>
+					</control>
+					<control type="button" id="148">
+						<width>1020</width>
+						<height>49</height>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textoffsetx>0</textoffsetx>
+						<font>font12</font>
+						<texturefocus />
+						<texturenofocus />
+						<onclick>noop</onclick>
+						<label>[COLOR button_focus]$LOCALIZE[39703]: [/COLOR]$INFO[ListItem.Property(Import.MediaTypesLabel)]</label>
+						<visible>!IsEmpty(ListItem.Property(Import.Path)) + !String.IsEmpty(ListItem.Property(Import.MediaTypesLabel))</visible>
+					</control>
+					<control type="button" id="149">
+						<width>1020</width>
+						<height>49</height>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textoffsetx>0</textoffsetx>
+						<font>font12</font>
+						<texturefocus />
+						<texturenofocus />
+						<onclick>noop</onclick>
+						<label>[COLOR button_focus]$LOCALIZE[39706]: [/COLOR]$INFO[ListItem.Property(Source.MediaTypesLabel)]</label>
+						<visible>IsEmpty(ListItem.Property(Import.Path)) + !String.IsEmpty(ListItem.Property(Source.MediaTypesLabel))</visible>
+					</control>
+					<control type="button" id="150">
+						<width>1020</width>
+						<height>49</height>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textoffsetx>0</textoffsetx>
+						<font>font12</font>
+						<texturefocus />
+						<texturenofocus />
+						<onclick>noop</onclick>
+						<label>[COLOR button_focus]$LOCALIZE[573]: [/COLOR]$INFO[ListItem.Property(Import.Path)]</label>
+						<visible>!IsEmpty(ListItem.Property(Import.Path)) + !String.IsEmpty(ListItem.Property(Import.Path))</visible>
+					</control>
+					<control type="button" id="151">
+						<width>1020</width>
+						<height>49</height>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textoffsetx>0</textoffsetx>
+						<font>font12</font>
+						<texturefocus />
+						<texturenofocus />
+						<onclick>noop</onclick>
+						<label>[COLOR button_focus]$LOCALIZE[39704]: [/COLOR]$INFO[ListItem.Property(Source.ActiveLabel)]</label>
+						<visible>!String.IsEmpty(ListItem.Property(Source.ActiveLabel))</visible>
+					</control>
+					<control type="button" id="152">
+						<width>1020</width>
+						<height>49</height>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textoffsetx>0</textoffsetx>
+						<font>font12</font>
+						<texturefocus />
+						<texturenofocus />
+						<onclick>noop</onclick>
+						<label>[COLOR button_focus]$LOCALIZE[39705]: [/COLOR]$INFO[ListItem.DateTime]</label>
+						<!-- <visible>!String.IsEmpty(ListItem.DateTime)</visible> -->
+					</control>
+				</control>
+			</control>
+			<!-- Setting Categories -->
+			<control type="grouplist" id="3">
+				<description>button area</description>
+				<left>20</left>
+				<top>440</top>
+				<width>400</width>
+				<height>800</height>
+				<itemgap>-25</itemgap>
+				<orientation>vertical</orientation>
+				<onleft>9001</onleft>
+				<onright>5</onright>
+				<onup>9</onup>
+				<ondown>9</ondown>
+			</control>
+			<control type="button" id="10">
+				<description>Default Category Button</description>
+				<height>120</height>
+				<width>390</width>
+				<textoffsetx>20</textoffsetx>
+				<align>center</align>
+				<aligny>center</aligny>
+				<font>font25_title</font>
+				<texturenofocus border="40">buttons/dialogbutton-nofo.png</texturenofocus>
+			</control>
+			<!-- Settings -->
+			<control type="image">
+				<left>400</left>
+				<top>440</top>
+				<width>1100</width>
+				<height>452</height>
+				<texture border="40">buttons/dialogbutton-nofo.png</texture>
+			</control>
+			<control type="grouplist" id="5">
+				<description>control area</description>
+				<left>420</left>
+				<top>460</top>
+				<width>1060</width>
+				<height>410</height>
+				<onleft>3</onleft>
+				<onright>9000</onright>
+				<onup>5</onup>
+				<ondown>5</ondown>
+			</control>
+			<control type="button" id="7">
+				<description>Default Button</description>
+				<include>DefaultSettingButton</include>
+			</control>
+			<control type="radiobutton" id="8">
+				<description>Default RadioButton</description>
+				<include>DefaultSettingButton</include>
+				<textwidth>900</textwidth>
+			</control>
+			<control type="spincontrolex" id="9">
+				<description>Default SpinControlex</description>
+				<include>DefaultSettingButton</include>
+				<textwidth>900</textwidth>
+			</control>
+			<control type="image" id="11">
+				<description>separator image</description>
+				<height>3</height>
+				<texture colordiffuse="AAAAAAAA" border="3">dialogs/separator-grey.png</texture>
+			</control>
+			<control type="edit" id="12">
+				<include>DefaultSettingButton</include>
+			</control>
+			<control type="sliderex" id="13">
+				<description>Default Slider</description>
+				<include>DefaultSettingButton</include>
+			</control>
+			<control type="label" id="14">
+				<description>Default Label</description>
+				<include>DefaultSettingLabel</include>
+			</control>
+			<!-- Buttons -->
+			<control type="grouplist" id="9000">
+				<right>20</right>
+				<top>70</top>
+				<width>300</width>
+				<height>700</height>
+				<itemgap>dialogbuttons_itemgap</itemgap>
+				<align>left</align>
+				<orientation>vertical</orientation>
+				<onup>9000</onup>
+				<ondown>9000</ondown>
+				<onleft>5</onleft>
+				<onright>5</onright>
+				<include content="DefaultDialogButton">
+					<param name="id" value="28" />
+					<param name="label" value="$LOCALIZE[186]" />
+				</include>
+				<include content="DefaultDialogButton">
+					<param name="id" value="29" />
+					<param name="label" value="$LOCALIZE[222]" />
+				</include>
+				<include content="DefaultDialogButton">
+					<param name="id" value="30" />
+					<param name="label" value="$LOCALIZE[409]" />
+				</include>
+			</control>
+		</control>
+	</controls>
+</window>

From 68c1dd885ef8a18f56a0ad62a28938c179e6ac70 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Sun, 13 Oct 2019 00:40:30 +0200
Subject: [PATCH 85/88] [TEMP] add mediaimporter.emby to import media items
 from an Emby server

---
 .gitmodules                         | 3 +++
 addons/mediaimporter.emby           | 1 +
 cmake/installdata/common/addons.txt | 1 +
 3 files changed, 5 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 addons/mediaimporter.emby

diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 000000000000..87692eaa5ad2
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "addons/mediaimporter.emby"]
+	path = addons/mediaimporter.emby
+	url = git@github.com:Montellese/mediaimporter.emby
diff --git a/addons/mediaimporter.emby b/addons/mediaimporter.emby
new file mode 160000
index 000000000000..c1da2e2d86cb
--- /dev/null
+++ b/addons/mediaimporter.emby
@@ -0,0 +1 @@
+Subproject commit c1da2e2d86cbc53b0a950b4d298e14ddeb18ea13
diff --git a/cmake/installdata/common/addons.txt b/cmake/installdata/common/addons.txt
index 897420faa7a4..c766d5696870 100644
--- a/cmake/installdata/common/addons.txt
+++ b/cmake/installdata/common/addons.txt
@@ -44,3 +44,4 @@ addons/metadata.generic.artists/*
 addons/metadata.themoviedb.org/*
 addons/metadata.tvshows.themoviedb.org/*
 addons/kodi.vfs/*
+addons/mediaimporter.emby/*

From 5067b351fe577eed5a74e6e8d2979f1b4ee7deed Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Wed, 27 Nov 2019 00:50:09 +0100
Subject: [PATCH 86/88] [TEMP] add mediaimporter.plex to import media items
 from a Plex Media Server

---
 .gitmodules                         | 3 +++
 addons/mediaimporter.plex           | 1 +
 cmake/installdata/common/addons.txt | 1 +
 3 files changed, 5 insertions(+)
 create mode 160000 addons/mediaimporter.plex

diff --git a/.gitmodules b/.gitmodules
index 87692eaa5ad2..8be253038bd3 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,6 @@
 [submodule "addons/mediaimporter.emby"]
 	path = addons/mediaimporter.emby
 	url = git@github.com:Montellese/mediaimporter.emby
+[submodule "addons/mediaimporter.plex"]
+	path = addons/mediaimporter.plex
+	url = git@github.com:Montellese/mediaimporter.plex
diff --git a/addons/mediaimporter.plex b/addons/mediaimporter.plex
new file mode 160000
index 000000000000..58db49112144
--- /dev/null
+++ b/addons/mediaimporter.plex
@@ -0,0 +1 @@
+Subproject commit 58db49112144f12050a2ceb788a3c8a89849fcc9
diff --git a/cmake/installdata/common/addons.txt b/cmake/installdata/common/addons.txt
index c766d5696870..259b54bfc897 100644
--- a/cmake/installdata/common/addons.txt
+++ b/cmake/installdata/common/addons.txt
@@ -45,3 +45,4 @@ addons/metadata.themoviedb.org/*
 addons/metadata.tvshows.themoviedb.org/*
 addons/kodi.vfs/*
 addons/mediaimporter.emby/*
+addons/mediaimporter.plex/*

From fbcdb4f89dbfd03a2486b18d50b317b111ac3809 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 16 Jan 2020 21:18:44 +0100
Subject: [PATCH 87/88] [TEMP] add repository.mediaimport

---
 addons/repository.mediaimport/addon.xml     | 18 ++++++++++++++++++
 addons/repository.mediaimport/changelog.txt | 12 ++++++++++++
 cmake/installdata/common/addons.txt         |  1 +
 3 files changed, 31 insertions(+)
 create mode 100644 addons/repository.mediaimport/addon.xml
 create mode 100644 addons/repository.mediaimport/changelog.txt

diff --git a/addons/repository.mediaimport/addon.xml b/addons/repository.mediaimport/addon.xml
new file mode 100644
index 000000000000..df9eea8f15a9
--- /dev/null
+++ b/addons/repository.mediaimport/addon.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="repository.mediaimport" name="Media Import Repository" version="0.0.4" provider-name="Montellese">
+	<extension point="xbmc.addon.repository" name="Media Import Repository">
+		<info compressed="false">https://raw.github.com/Montellese/repository.mediaimport/master/addons.xml</info>
+		<checksum>https://raw.github.com/Montellese/repository.mediaimport/master/addons.xml.md5</checksum>
+		<datadir zip="true">https://raw.github.com/Montellese/repository.mediaimport/master/downloads/</datadir>
+	</extension>
+	<extension point="xbmc.addon.metadata">
+		<summary lang="en_GB">Media Import Repository</summary>
+		<description lang="en_GB">Kodi media importer and additional add-ons.</description>
+		<disclaimer lang="en_GB"></disclaimer>
+		<platform>all</platform>
+		<license>GPL-2.0-or-later</license>
+		<source>https://github.com/Montellese/repository.mediaimport/</source>
+		<website>https://github.com/Montellese/</website>
+		<email>montellese@kodi.tv</email>
+	</extension>
+</addon>
diff --git a/addons/repository.mediaimport/changelog.txt b/addons/repository.mediaimport/changelog.txt
new file mode 100644
index 000000000000..901e50b95eff
--- /dev/null
+++ b/addons/repository.mediaimport/changelog.txt
@@ -0,0 +1,12 @@
+[B]Version 0.0.4[/B]
+- Support direct play and direct stream in mediaimporter.emby
+
+[B]Version 0.0.3[/B]
+- Update to Python 2 and 3 compatible version of mediaimporter.emby
+- Update to Python 2 and 3 compatible version of mediaimporter.plex
+
+[B]Version 0.0.2[/B]
+- Add script.module.websocket_client (thanks enen92)
+
+[B]Version 0.0.1[/B]
+- Initial version
\ No newline at end of file
diff --git a/cmake/installdata/common/addons.txt b/cmake/installdata/common/addons.txt
index 259b54bfc897..b449864f4d23 100644
--- a/cmake/installdata/common/addons.txt
+++ b/cmake/installdata/common/addons.txt
@@ -46,3 +46,4 @@ addons/metadata.tvshows.themoviedb.org/*
 addons/kodi.vfs/*
 addons/mediaimporter.emby/*
 addons/mediaimporter.plex/*
+addons/repository.mediaimport/*

From 21bd957c9e256935ca5ab7faa3425c8b22bc1877 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Micha=C5=82=20Piechowiak?= <misiek.piechowiak@gmail.com>
Date: Fri, 2 Aug 2013 19:30:39 +0200
Subject: [PATCH 88/88] [TEMP] win32: allow to run mulitple xbmc instances

---
 xbmc/platform/win32/WinMain.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/platform/win32/WinMain.cpp b/xbmc/platform/win32/WinMain.cpp
index 51fecd30f1e5..9712588bdc00 100644
--- a/xbmc/platform/win32/WinMain.cpp
+++ b/xbmc/platform/win32/WinMain.cpp
@@ -61,6 +61,7 @@ INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR commandLine, INT)
   // check if Kodi is already running
   std::string appName = CCompileInfo::GetAppName();
   HANDLE appRunningMutex = CreateMutex(nullptr, FALSE, ToW(appName + " Media Center").c_str());
+  /*
   if (GetLastError() == ERROR_ALREADY_EXISTS)
   {
     auto appNameW = ToW(appName);
@@ -74,6 +75,7 @@ INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR commandLine, INT)
     ReleaseMutex(appRunningMutex);
     return 0;
   }
+  */
 
   //Initialize COM
   CoInitializeEx(nullptr, COINIT_MULTITHREADED);
